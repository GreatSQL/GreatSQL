SET sql_mode=ORACLE;
SET SESSION debug='+d,skip_dd_table_access_check';
set @@udt_format_result='DBA';
#
# test of create type as table
#
create or replace type t_air as object(id int,type varchar(10));
create or replace type my_integer is varray(100) of integer;
SELECT name,type,options FROM mysql.routines where name='my_integer';
name	type	options
my_integer	TYPE	ref_count=0;table_type=0;udt_size=5;varray_limit=100;
create or replace type my_varchar is table of varchar2(8000);
SELECT name,type,options FROM mysql.routines where name='my_varchar';
name	type	options
my_varchar	TYPE	ref_count=0;table_type=1;udt_size=32003;varray_limit=0;
CREATE OR REPLACE TYPE t_air_table AS table OF my_integer;
ERROR 42000: This version of MySQL doesn't yet support 'create type as table object of udt table object'
show create type my_integer;
Type	sql_mode	Create Type	character_set_client	collation_connection	Database Collation
my_integer	PIPES_AS_CONCAT,ANSI_QUOTES,IGNORE_SPACE,ONLY_FULL_GROUP_BY,ORACLE,STRICT_TRANS_TABLES,STRICT_ALL_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION	CREATE DEFINER="root"@"localhost" TYPE "my_integer" AS VARRAY(100) OF integer	utf8mb4	utf8mb4_0900_ai_ci	utf8mb4_0900_ai_ci
show create type my_varchar;
Type	sql_mode	Create Type	character_set_client	collation_connection	Database Collation
my_varchar	PIPES_AS_CONCAT,ANSI_QUOTES,IGNORE_SPACE,ONLY_FULL_GROUP_BY,ORACLE,STRICT_TRANS_TABLES,STRICT_ALL_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION	CREATE DEFINER="root"@"localhost" TYPE "my_varchar" AS TABLE OF varchar2(8000)	utf8mb4	utf8mb4_0900_ai_ci	utf8mb4_0900_ai_ci
#
# test of select type_table
#
select my_integer(1,2,null);
my_integer(1,2,null)
my_integer(1,2,NULL)
select my_integer(1,2,'a');
ERROR HY000: Incorrect integer value: 'a' for column 'column_value' at row 1
select my_integer(t_air(1,'aa'));
ERROR HY000: inconsistent datatypes: udt type and non udt type
#
# test of table function
#
select * from table(my_integer(1,2,null));
column_value
1
2
NULL
select * from table(my_varchar(1,'dd',null)) a;
column_value
1
dd
NULL
select * from table(my_varchar(1,'dd',null)) a union select * from table(my_integer(1,2,null)) a;
column_value
1
dd
NULL
2
select * from table(my_varchar(1,'dd',null)) union
select * from table(my_integer(1,2,null));
column_value
1
dd
NULL
2
select * from table(my_varchar(1,'dd',null)) a,table(my_integer(1,2,null)) b;
column_value	column_value
1	1
1	2
1	NULL
dd	1
dd	2
dd	NULL
NULL	1
NULL	2
NULL	NULL
select * from table(my_varchar(1,'dd',null)),table(my_integer(1,2,null));
column_value	column_value
1	1
1	2
1	NULL
dd	1
dd	2
dd	NULL
NULL	1
NULL	2
NULL	NULL
select * from table(my_varchar(1,'dd',null)) a,table(my_integer(1,2,null)) a;
ERROR 42000: Not unique table/alias: 'a'
select * from table(my_integer(1,2,null))  where column_value>1;
column_value
2
select * from table(my_varchar(1,'dd',null)) where column_value is not null;
column_value
1
dd
#
# test of create table as select table function
#
create table ss_table as select * from table(my_integer(1,2,null));
select * from ss_table;
column_value
1
2
NULL
insert into ss_table select * from table(my_integer(10,20,null));
select * from ss_table;
column_value
1
2
NULL
10
20
NULL
select my_integer(column_value) from ss_table;
my_integer(column_value)
my_integer(1)
my_integer(2)
my_integer(NULL)
my_integer(10)
my_integer(20)
my_integer(NULL)
insert into ss_table values(my_integer(10,20,null));
ERROR HY000: inconsistent datatypes: udt type and non udt type
select * from ss_table where column_value=my_integer(10,20,null);
ERROR 42000: This version of MySQL doesn't yet support 'compare with udt table'
select my_integer(10,20,null)+1 from dual;
ERROR 42000: This version of MySQL doesn't yet support 'udt columns used in function'
drop table ss_table;
#
# test of create type as VARRAY
#
create or replace type my_integer is varray(1) of integer;
show variables like 'tf_udt_table_max_rows';
Variable_name	Value
tf_udt_table_max_rows	1048576
set GLOBAL tf_udt_table_max_rows=10485;
show variables like 'tf_udt_table_max_rows';
Variable_name	Value
tf_udt_table_max_rows	10485
create or replace type my_integer is varray(10486) of integer;
ERROR HY000: The number of records generated by UDT_TABLE() cannot exceed 1048576 (10486 requested). Try increasing @@tf_udt_table_max_rows to a larger value.
set GLOBAL tf_udt_table_max_rows=1048576;
#
# test of select type_array
#
select my_integer(1);
my_integer(1)
my_integer(1)
select my_integer(1,2);
ERROR HY000: Out of memory
#
# test of prepare stmt
#
prepare ps2 from 'select my_integer(?)';
set @a=1;
execute ps2 using @a;
my_integer(?)
my_integer(1)
set @a=10;
execute ps2 using @a;
my_integer(?)
my_integer(10)
DEALLOCATE PREPARE ps2;
#
# test of error with udt table
#
create table tt_of of my_integer;
ERROR 42000: This version of MySQL doesn't yet support 'create table with udt table'
create table tabl1 (id int, u1 my_integer);
ERROR 42000: This version of MySQL doesn't yet support 'create table with udt table'
CREATE OR REPLACE TYPE my_integer1 AS VARRAY(10) OF my_integer;
ERROR 42000: This version of MySQL doesn't yet support 'create type as table object of udt table object'
#
# test of conditions of with udt table
#
create or replace type my_integer is varray(10) of integer;
select * from table(my_integer(10,20,null)) where my_integer(10,20,null)=my_integer(10,20,null);
column_value
10
20
NULL
select * from table(my_integer(10,20,null)) where my_integer(10,20,null)=my_varchar(10,20,null);
ERROR HY000: inconsistent datatypes: expected 'test'.'my_varchar' got 'test'.'my_integer'
#
# test of different db of udt table
#
create database db2;
use db2;
create or replace type my_integer is varray(100) of integer;
use test;
select * from table(db2.my_integer(10,20,null));
column_value
10
20
NULL
use db2;
drop type my_integer;
use test;
drop database db2;
#
# test of table(a.udt_col)
#
create table tt_air(id int,name t_air);
insert into tt_air values(10,t_air(10,'aabb10'));
insert into tt_air values(11,t_air(11,'aabb11'));
select * from tt_air;
id	name
10	id:10 | type:aabb10
11	id:11 | type:aabb11
select * from tt_air b,table(my_integer(b.id)) a;
id	name	column_value
10	id:10 | type:aabb10	10
11	id:11 | type:aabb11	11
select my_integer(a.id) from tt_air a;
my_integer(a.id)
my_integer(10)
my_integer(11)
select * from tt_air a order by my_integer(a.id);
ERROR HY000: cannot ORDER objects without window function or ORDER method
select name || my_integer(id) from tt_air;
ERROR 42000: This version of MySQL doesn't yet support 'udt columns used in function'
select my_integer(id)-1 from tt_air;
ERROR 42000: This version of MySQL doesn't yet support 'udt columns used in function'
#
# test of udt type in sp with uninitialized composite
#
CREATE or replace PROCEDURE p1() as
rec1 t_air;
BEGIN
select rec1,rec1.id;
rec1.id := 1;
select rec1.id;
END;
$$
call p1();
rec1	rec1.id
NULL	NULL
ERROR HY000: Reference to uninitialized composite
drop PROCEDURE p1;
#
# test of udt type in sp
#
CREATE or replace PROCEDURE p1() as
rec1 t_air;
to_id int;
BEGIN
rec1 := t_air(1,'aa');
select rec1,rec1.id;
rec1.id := 10;
select rec1.id;
select * from tt_air;
insert into tt_air values(21,rec1);
select * from tt_air;
select name into rec1 from tt_air where id=10;
select rec1;
select id,name into to_id,rec1 from tt_air where id=11;
select to_id,rec1;
END;
$$
call p1();
rec1	rec1.id
id:1 | type:aa	1
rec1.id
10
id	name
10	id:10 | type:aabb10
11	id:11 | type:aabb11
id	name
10	id:10 | type:aabb10
11	id:11 | type:aabb11
21	id:10 | type:aa
rec1
id:10 | type:aabb10
to_id	rec1
11	id:11 | type:aabb11
drop PROCEDURE p1;
#
# test of udt type in sp with null value
#
CREATE or replace PROCEDURE p1() as
rec1 t_air := null;
BEGIN
select * from tt_air;
insert into tt_air values(22,rec1);
select * from tt_air;
end;
$$
call p1();
id	name
10	id:10 | type:aabb10
11	id:11 | type:aabb11
21	id:10 | type:aa
id	name
10	id:10 | type:aabb10
11	id:11 | type:aabb11
21	id:10 | type:aa
22	NULL
drop PROCEDURE p1;
#
# test of record type in sp with default value
#
CREATE or replace PROCEDURE p1() as
TYPE name_rec IS RECORD (
first_name  int := 1,
last_name   varchar(30) := 'qwe'
  );
rec name_rec := name_rec(10,'bb');
rec1 name_rec;
rec2 name_rec := null;
BEGIN
select rec,rec.first_name,rec.last_name;
select rec1,rec1.first_name,rec1.last_name;
select rec2,rec2.first_name,rec2.last_name;
end;
$$
call p1();
rec	rec.first_name	rec.last_name
first_name:10 | last_name:bb	10	bb
rec1	rec1.first_name	rec1.last_name
first_name:1 | last_name:qwe	1	qwe
rec2	rec2.first_name	rec2.last_name
NULL	NULL	NULL
call p1();
rec	rec.first_name	rec.last_name
first_name:10 | last_name:bb	10	bb
rec1	rec1.first_name	rec1.last_name
first_name:1 | last_name:qwe	1	qwe
rec2	rec2.first_name	rec2.last_name
NULL	NULL	NULL
drop PROCEDURE p1;
#
# test of record name is same with udt type in sp
#
CREATE or replace PROCEDURE p1() as
TYPE t_air IS RECORD (
first_name  int,
last_name   varchar(30),
i int
);
rec t_air := t_air(10,'bb',1);
BEGIN
select rec,rec.first_name,rec.last_name;
end;
$$
ERROR 42000: Incorrect number of arguments for TYPE test.t_air; expected 2, got 3
#
# test of record name is same with udt type in sp
#
CREATE or replace PROCEDURE p1() as
type t_air is record(
id int := 1,
name_d  t_air,
score float := 0
);
rec1 t_air := t_air(10,null);
BEGIN
select rec1.score;
end;
$$
call p1;
ERROR HY000: Row variable 'rec1' does not have a field 'score'
drop PROCEDURE p1;
#
# test of record with udt type in sp
#
CREATE or replace PROCEDURE p1() as
TYPE t_air1 IS RECORD (
first_name  int,
last_name   varchar(30),
i int
);
rec t_air1 := t_air(10,'bb');
BEGIN
select rec,rec.first_name,rec.last_name;
end;
$$
ERROR HY000: inconsistent datatypes: expected 'test'.'t_air1' got 'test'.'t_air'
#
# test of udt table type in sp
#
CREATE OR REPLACE TYPE t_air_table AS table OF t_air;
CREATE OR REPLACE TYPE t_air_varray AS VARRAY(10) OF t_air;
CREATE or replace PROCEDURE p1() as
rec1 t_air_table := null;
BEGIN
select rec1;
rec1 := t_air_table(t_air(1,'aa'),t_air(2,'bb'));
for i in rec1.first .. rec1.last loop
select rec1(i).id,rec1(i).type;
end loop;
end;
$$
call p1();
rec1
NULL
rec1(i).id	rec1(i).type
1	aa
rec1(i).id	rec1(i).type
2	bb
drop PROCEDURE p1;
#
# test of udt table type in sp
#
CREATE or replace PROCEDURE p1() as
rec1 t_air_table := t_air_table(t_air(1,'aa'),t_air(2,'bb'));
BEGIN
rec1(1).id := 10;
rec1(1).type := 'aa10';
for i in rec1.first .. rec1.last loop
select rec1(i).id,rec1(i).type;
end loop;
end;
$$
call p1();
rec1(i).id	rec1(i).type
10	aa10
rec1(i).id	rec1(i).type
2	bb
drop PROCEDURE p1;
#
# test of udt table type in sp
#
CREATE or replace PROCEDURE p1() as
rec1 my_integer := null;
BEGIN
select rec1;
rec1 := my_integer(1,2,3);
for i in rec1.first .. rec1.last loop
select rec1(i).column_value;
end loop;
end;
$$
call p1();
rec1
NULL
rec1(i).column_value
1
rec1(i).column_value
2
rec1(i).column_value
3
drop PROCEDURE p1;
#
# test of udt table type in sp
#
CREATE or replace PROCEDURE p1() as
rec1 t_air_table := null;
to_id int;
BEGIN
select rec1;
select id,name into to_id,rec1 from tt_air where id=11;
select rec1;
end;
$$
call p1();
rec1
NULL
ERROR HY000: inconsistent datatypes: udt type and non udt type
drop PROCEDURE p1;
#
# test of udt type in sp with default value
#
create or replace procedure p1 as
type stu_record is record(
id int := 1,
name_d  varchar(20) ,
score float := 0
);
type stu_record1 is record(
ii int := 1,
stu_record_val1 stu_record := stu_record(10,'aa',3.3)
);
stu_record_val stu_record1;
begin
select stu_record_val.stu_record_val1.id,stu_record_val.stu_record_val1.name_d,stu_record_val.stu_record_val1.score;
end;
$$
call p1();
stu_record_val.stu_record_val1.id	stu_record_val.stu_record_val1.name_d	stu_record_val.stu_record_val1.score
10	aa	3.3
call p1();
stu_record_val.stu_record_val1.id	stu_record_val.stu_record_val1.name_d	stu_record_val.stu_record_val1.score
10	aa	3.3
drop PROCEDURE p1;
#
# test of udt type in sp with default value
#
create or replace procedure p1 as
type stu is record(
id int := 1,
name_d  varchar(20) ,
score float := 0
);
type stu_record is record(
id int := 1,
name_d  stu,
score float := 0
);
type stu_record1 is record(
ii int := 1,
stu_record_val1 stu_record := stu_record(10,stu(1,'bb',11),1.1)
);
stu_record_val stu_record1;
begin
select stu_record_val.stu_record_val1.id,stu_record_val.stu_record_val1.name_d,stu_record_val.stu_record_val1.score;
select stu_record_val.stu_record_val1.name_d.id,stu_record_val.stu_record_val1.name_d.name_d,stu_record_val.stu_record_val1.name_d.score;
end;
$$
call p1();
stu_record_val.stu_record_val1.id	stu_record_val.stu_record_val1.name_d	stu_record_val.stu_record_val1.score
10	id:1 | name_d:bb | score:11	1.1
stu_record_val.stu_record_val1.name_d.id	stu_record_val.stu_record_val1.name_d.name_d	stu_record_val.stu_record_val1.name_d.score
1	bb	11
call p1();
stu_record_val.stu_record_val1.id	stu_record_val.stu_record_val1.name_d	stu_record_val.stu_record_val1.score
10	id:1 | name_d:bb | score:11	1.1
stu_record_val.stu_record_val1.name_d.id	stu_record_val.stu_record_val1.name_d.name_d	stu_record_val.stu_record_val1.name_d.score
1	bb	11
drop PROCEDURE p1;
#
# test of udt type in sp with default value
#
create or replace procedure p1 as
type stu is record(
id int := 1,
name_d  varchar(20) ,
score float := 0
);
type stu_record is record(
id int := 1,
name_d  stu,
score float := 0
);
type stu_record1 is record(
ii int := 1,
stu_record_val1 stu_record := stu_record(10,stu_record(1,'bb',11),1.1)
);
stu_record_val stu_record1;
begin
select stu_record_val.stu_record_val1.id,stu_record_val.stu_record_val1.name_d,stu_record_val.stu_record_val1.score;
select stu_record_val.stu_record_val1.name_d.id,stu_record_val.stu_record_val1.name_d.name_d,stu_record_val.stu_record_val1.name_d.score;
end;
$$
call p1();
ERROR HY000: inconsistent datatypes: expected 'test'.'stu' got 'test'.'stu_record'
drop PROCEDURE p1;
#
# test of record table type in sp with default value
#
create or replace procedure p1 as
type stu is record(
id int := 1,
name_d  varchar(20) ,
score float := 0
);
type tklist1 is table of stu index by binary_integer;
type stu_record is record(
id int := 1,
name_d  tklist1,
score float := 0
);
type stu_record1 is record(
ii int := 1,
stu_record_val1 stu_record := stu_record(10,tklist1(1=>stu(1,'bb',1)),1.1)
);
stu_record_val stu_record1;
begin
select stu_record_val.stu_record_val1.name_d(1).name_d;
end;
$$
call p1();
stu_record_val.stu_record_val1.name_d(1).name_d
bb
drop PROCEDURE p1;
#
# test of error ER_SP_NOT_EXIST_OF_RECORD_TABLE with udt table
#
create or replace procedure p1 as
type stu_record is record(
id int := 1,
name_d  t_air_table,
score float := 0
);
stu_record_val stu_record;
begin
select stu_record_val.id;
select stu_record_val.name_d(0).id;
end;
$$
call p1;
stu_record_val.id
1
ERROR HY000: The data of record table variable: name_d does not exist.
drop PROCEDURE p1;
#
# test of inited with udt table
#
create or replace procedure p1 as
type stu_record is record(
id int := 1,
name_d  t_air_table,
score float := 0
);
stu_record_val stu_record := stu_record(10,t_air_table(t_air(3,'cc'),t_air(4,'dd')),1.1);
begin
select stu_record_val.id;
select stu_record_val.name_d(1).id,stu_record_val.name_d(1).type,stu_record_val.name_d(2).id,stu_record_val.name_d(2).type;
end;
$$
call p1;
stu_record_val.id
10
stu_record_val.name_d(1).id	stu_record_val.name_d(1).type	stu_record_val.name_d(2).id	stu_record_val.name_d(2).type
3	cc	4	dd
drop PROCEDURE p1;
#
# test of record table type in sp with default value
#
create or replace procedure p1 as
type stu is record(
id int := 1,
name_d  varchar(20) ,
score float := 0
);
type tklist1 is table of stu index by binary_integer;
type stu_record is record(
id int := 1,
name_d  tklist1,
score float := 0
);
type stu_record1 is record(
ii int := 1,
stu_record_val1 stu_record
);
stu_record_val stu_record1 := stu_record1(10,stu_record(1,tklist1(),9));
begin
end;
$$
call p1;
drop PROCEDURE p1;
#
# test of udt table type in sp with default value
#
create or replace procedure p1 as
type stu_record is record(
id int := 1,
name_d  t_air_table,
score float := 0
);
type stu_record1 is record(
ii int := 1,
stu_record_val1 stu_record:= stu_record(10,t_air_table(t_air(3,'cc')),1.1)
);
stu_record_val stu_record1;
begin
select stu_record_val.stu_record_val1.name_d(1).id,stu_record_val.stu_record_val1.name_d(1).type;
stu_record_val.stu_record_val1.name_d(2).type := 'ddd';
end;
$$
call p1();
stu_record_val.stu_record_val1.name_d(1).id	stu_record_val.stu_record_val1.name_d(1).type
3	cc
ERROR HY000: Subscript outside of limit/count
drop PROCEDURE p1;
#
# test of udt array type in sp with default value
#
create or replace procedure p1 as
type stu_record is record(
id int := 1,
name_d  t_air_varray,
score float := 0
);
type stu_record1 is record(
ii int := 1,
stu_record_val1 stu_record:= stu_record(10,t_air_varray(t_air(3,'cc')),1.1)
);
stu_record_val stu_record1;
begin
select stu_record_val.stu_record_val1.name_d(1).id,stu_record_val.stu_record_val1.name_d(1).type;
stu_record_val.stu_record_val1:= stu_record(10,t_air_varray(t_air(30,'cc30'),t_air(40,'dd40')),1.1);
select stu_record_val.stu_record_val1.name_d(1).id,stu_record_val.stu_record_val1.name_d(1).type;
select stu_record_val.stu_record_val1.name_d(2).id,stu_record_val.stu_record_val1.name_d(2).type;
end;
$$
call p1();
stu_record_val.stu_record_val1.name_d(1).id	stu_record_val.stu_record_val1.name_d(1).type
3	cc
stu_record_val.stu_record_val1.name_d(1).id	stu_record_val.stu_record_val1.name_d(1).type
30	cc30
stu_record_val.stu_record_val1.name_d(2).id	stu_record_val.stu_record_val1.name_d(2).type
40	dd40
drop PROCEDURE p1;
#
# test for %type
#
CREATE or replace PROCEDURE p1() as
rec tt_air.name%type;
BEGIN
rec := t_air(1,'sd');
select rec,rec.id,rec.type;
end;
$$
call p1();
rec	rec.id	rec.type
id:1 | type:sd	1	sd
drop PROCEDURE p1;
#
# test for %type and select into
#
CREATE or replace PROCEDURE p1() as
rec tt_air.name%type;
rec1 t_air;
BEGIN
select name into rec from tt_air where id=10;
select rec.id,rec.type;
select name into rec1 from tt_air where id=11;
select rec1.id,rec1.type;
select rec into rec1;
select rec1.id,rec1.type;
end;
$$
call p1();
rec.id	rec.type
10	aabb10
rec1.id	rec1.type
11	aabb11
rec1.id	rec1.type
10	aabb10
call p1();
rec.id	rec.type
10	aabb10
rec1.id	rec1.type
11	aabb11
rec1.id	rec1.type
10	aabb10
drop PROCEDURE p1;
#
# test of cursor for udt column
#
CREATE or replace PROCEDURE p2() as
CURSOR c_country (ii int) IS SELECT * FROM tt_air WHERE id =ii;
rec1 tt_air.name%type;
BEGIN
FOR rec IN c_country(10)
loop
select rec.name into rec1;
select rec1.id,rec1.type;
END loop;
insert into tt_air values(12,rec);
END;
$$
call p2;
rec1.id	rec1.type
10	aabb10
ERROR 42S22: Unknown column 'rec' in 'field list'
drop PROCEDURE p2;
#
# test of cursor for udt column
#
CREATE or replace PROCEDURE p2() as
CURSOR c_country (ii int) IS SELECT * FROM tt_air WHERE id =ii;
rec1 tt_air.name%type;
BEGIN
FOR rec IN c_country(10)
loop
select rec,rec.id,rec.name;
select rec.name into rec1;
select rec1.id,rec1.type;
END loop;
select * from tt_air;
END;
$$
call p2;
rec	rec.id	rec.name
id:10 | name:id:10 | type:aabb10	10	id:10 | type:aabb10
rec1.id	rec1.type
10	aabb10
id	name
10	id:10 | type:aabb10
11	id:11 | type:aabb11
21	id:10 | type:aa
22	NULL
drop PROCEDURE p2;
#
# test for set record to null 
#
CREATE or replace PROCEDURE p1() as
type stu_record is record(
id int := 1,
name_d  varchar(20) := 'a',
score float := 0
);
stu_record_val stu_record;
begin
stu_record_val := NULL;
stu_record_val.id :=10;
select stu_record_val.id,stu_record_val.name_d,stu_record_val.score;
end;
$$
call p1();
stu_record_val.id	stu_record_val.name_d	stu_record_val.score
10	NULL	NULL
drop PROCEDURE p1;
#
# test for set record table to null
#
CREATE or replace PROCEDURE p1() as
type stu_record is record(
id int := 1,
name_d  varchar(20) := 'a',
score float := 0
);
type tklist is table of stu_record index by binary_integer;
stu_record_val tklist;
begin
stu_record_val := NULL;
end;
$$
call p1();
ERROR 23000: Column 'stu_record_val' cannot be null
drop PROCEDURE p1;
#
# test for set udt table to null 
#
CREATE or replace PROCEDURE p1() as
stu_record_val t_air_table;
begin
stu_record_val := NULL;
end;
$$
call p1();
drop PROCEDURE p1;
#
# test for replace type
#
create or replace type t_air1 as object(id int,type varchar(10),i int);
CREATE or replace PROCEDURE p1() as
stu_record_val t_air1 := t_air1(1,'aa',2);
begin
select stu_record_val.id,stu_record_val.type,stu_record_val.i;
end;
$$
call p1();
stu_record_val.id	stu_record_val.type	stu_record_val.i
1	aa	2
create or replace type t_air1 as object(id int,type varchar(10));
call p1();
ERROR HY000: Failed to load routine 'test.p1'.
drop PROCEDURE p1;
#
# test for replace type
#
create or replace type t_air1 as object(id int,type varchar(10),i int);
CREATE or replace PROCEDURE p1() as
stu_record_val t_air_table := t_air_table(t_air(1,'aa'));
begin
select stu_record_val(1).id,stu_record_val(1).type;
end;
$$
call p1();
stu_record_val(1).id	stu_record_val(1).type
1	aa
CREATE OR REPLACE TYPE t_air_table AS table OF t_air1;
call p1();
ERROR HY000: inconsistent datatypes: expected 'test'.'t_air1' got 'test'.'t_air'
drop PROCEDURE p1;
#
# test for replace type AS table
#
CREATE OR REPLACE TYPE t_air_table AS table OF t_air;
create or replace type t_air1 as object(id int,type varchar(10),i int);
CREATE or replace PROCEDURE p1() as
stu_record_val t_air1 := t_air1(1,'aa',2);
begin
select stu_record_val.id,stu_record_val.type;
end;
$$
call p1();
stu_record_val.id	stu_record_val.type
1	aa
create or replace type t_air1 as object(id int,type varchar(10));
call p1();
ERROR HY000: Failed to load routine 'test.p1'.
create or replace type t_air1 as object(id int,type int,i int);
call p1();
ERROR HY000: Incorrect integer value: 'aa' for column 'type' at row 1
create or replace type t_air1 as object(id1 int,type1 varchar(10),i1 int);
call p1();
ERROR HY000: Row variable 'stu_record_val' does not have a field 'id'
drop PROCEDURE p1;
#
# test for replace type AS VARRAY
#
create or replace type t_air1 as object(id int,type varchar(10),i int);
CREATE or replace PROCEDURE p1() as
stu_record_val t_air_varray := t_air_varray(t_air(1,'aa'),t_air(2,'bb'));
begin
select stu_record_val(1).id,stu_record_val(1).type;
end;
$$
call p1();
stu_record_val(1).id	stu_record_val(1).type
1	aa
CREATE OR REPLACE TYPE t_air_varray AS VARRAY(1) OF t_air;
call p1();
ERROR HY000: Failed to load routine 'test.p1'.
CREATE OR REPLACE TYPE t_air_varray AS VARRAY(10) OF t_air1;
call p1();
ERROR HY000: inconsistent datatypes: expected 'test'.'t_air1' got 'test'.'t_air'
CREATE OR REPLACE TYPE t_air_varray AS VARRAY(10) OF t_air;
call p1();
stu_record_val(1).id	stu_record_val(1).type
1	aa
drop PROCEDURE p1;
#
# test for replace type AS table
#
CREATE OR REPLACE TYPE t_air_table AS table OF t_air;
create or replace type t_air1 as object(id int,type varchar(10),i int);
create or replace procedure p1 as
type stu_record is record(
id int := 1,
name_d  t_air_table,
score float := 0
);
type stu_record1 is record(
ii int := 1,
stu_record_val1 stu_record:= stu_record(10,t_air_table(t_air(3,'cc')),1.1)
);
stu_record_val stu_record1;
begin
select stu_record_val.stu_record_val1.name_d(1).id,stu_record_val.stu_record_val1.name_d(1).type;
stu_record_val.stu_record_val1.name_d(1).type := 'ddd';
select stu_record_val.stu_record_val1.name_d(1).type;
end;
$$
call p1();
stu_record_val.stu_record_val1.name_d(1).id	stu_record_val.stu_record_val1.name_d(1).type
3	cc
stu_record_val.stu_record_val1.name_d(1).type
ddd
CREATE OR REPLACE TYPE t_air_table AS table OF t_air1;
call p1();
ERROR HY000: inconsistent datatypes: expected 'test'.'t_air1' got 'test'.'t_air'
CREATE OR REPLACE TYPE t_air_table AS table OF t_air;
drop PROCEDURE p1;
#
# test for replace type AS table
#
CREATE OR REPLACE TYPE t_air_table AS table OF t_air;
create or replace type t_air1 as object(id int,type varchar(10),i int);
create or replace procedure p1 as
type stu_record is record(
id int := 1,
name_d  t_air_table,
score float := 0
);
type stu_record1 is record(
ii int := 1,
stu_record_val1 stu_record:= stu_record(10,t_air_table(t_air(3,'cc')),1.1)
);
stu_record_val stu_record1;
begin
select stu_record_val.stu_record_val1.name_d(1).id,stu_record_val.stu_record_val1.name_d(1).type;
stu_record_val.stu_record_val1.name_d(2).type := 'ddd';
select stu_record_val.stu_record_val1.name_d(2).type;
end;
$$
call p1();
stu_record_val.stu_record_val1.name_d(1).id	stu_record_val.stu_record_val1.name_d(1).type
3	cc
ERROR HY000: Subscript outside of limit/count
drop PROCEDURE p1;
#
# test of udt type in sp and insert into table
#
CREATE or replace PROCEDURE p1() as
type stu_record is record(
id int := 1,
name_d  t_air,
score float := 0
);
rec1 stu_record;
BEGIN
rec1.name_d := t_air(2,'ee');
select * from tt_air;
insert into tt_air values(30,rec1.name_d);
select * from tt_air;
end;
$$
call p1();
id	name
10	id:10 | type:aabb10
11	id:11 | type:aabb11
21	id:10 | type:aa
22	NULL
id	name
10	id:10 | type:aabb10
11	id:11 | type:aabb11
21	id:10 | type:aa
22	NULL
30	id:2 | type:ee
drop PROCEDURE p1;
#
# test of udt type in sp and BULK COLLECT into
#
CREATE or replace PROCEDURE p1() as
type dr_type is table of tt_air%ROWTYPE index by binary_integer;
dr_table dr_type;
begin
select * BULK COLLECT into dr_table from tt_air;
for i IN dr_table.first .. dr_table.last loop
select dr_table(i).id,dr_table(i).name,dr_table(i).name.id,dr_table(i).name.type;
end loop;
end;
$$
call p1();
dr_table(i).id	dr_table(i).name	dr_table(i).name.id	dr_table(i).name.type
10	id:10 | type:aabb10	10	aabb10
dr_table(i).id	dr_table(i).name	dr_table(i).name.id	dr_table(i).name.type
11	id:11 | type:aabb11	11	aabb11
dr_table(i).id	dr_table(i).name	dr_table(i).name.id	dr_table(i).name.type
21	id:10 | type:aa	10	aa
dr_table(i).id	dr_table(i).name	dr_table(i).name.id	dr_table(i).name.type
22	NULL	10	aa
dr_table(i).id	dr_table(i).name	dr_table(i).name.id	dr_table(i).name.type
30	id:2 | type:ee	2	ee
drop PROCEDURE p1;
#
# test of udt type in sp and FORALL
#
create table tt_air1(id int,name t_air);
CREATE or replace PROCEDURE p1() as
type dr_type is table of tt_air%ROWTYPE index by binary_integer;
dr_table dr_type;
begin
dr_table(100).id := 100;
dr_table(100).name := t_air(2,'eert');
select dr_table(100).id,dr_table(100).name,dr_table(100).name.id,dr_table(100).name.type;
FORALL i IN dr_table.first .. dr_table.last
insert into tt_air1 values dr_table (i);
select * from tt_air1;
end;
$$
call p1();
dr_table(100).id	dr_table(100).name	dr_table(100).name.id	dr_table(100).name.type
100	id:2 | type:eert	2	eert
id	name
100	id:2 | type:eert
drop PROCEDURE p1;
drop table tt_air1;
#
# test of sp variable used as record table's row number
#
CREATE or replace PROCEDURE p1() as
type dr_type is table of tt_air%ROWTYPE index by binary_integer;
dr_table dr_type;
idx int := 100;
begin
dr_table(100).id := 100;
dr_table(100).name := t_air(2,'eert');
select dr_table(idx).id,dr_table(idx).name,dr_table(idx).name.id,dr_table(idx).name.type;
dr_table(100).name.id := 10;
select dr_table(100).name.id,dr_table(100).name.type;
end;
$$
call p1();
dr_table(idx).id	dr_table(idx).name	dr_table(idx).name.id	dr_table(idx).name.type
100	id:2 | type:eert	2	eert
dr_table(100).name.id	dr_table(100).name.type
10	eert
drop PROCEDURE p1;
#
# test of sp variable used as variable with `
#
CREATE or replace PROCEDURE p1() as
type dr_type is table of tt_air%ROWTYPE index by binary_integer;
dr_table dr_type;
idx int := 100;
begin
dr_table(100).id := 100;
dr_table(100).name := t_air(2,'eert');
select dr_table(`idx`).id,dr_table(`idx`).name,dr_table(`idx`).name.id,dr_table(`idx`).name.type;
end;
$$
call p1();
dr_table(`idx`).id	dr_table(`idx`).name	dr_table(`idx`).name.id	dr_table(`idx`).name.type
100	id:2 | type:eert	2	eert
drop PROCEDURE p1;
#
# test of sp variable used as variable with `
#
CREATE or replace PROCEDURE p1() as
type dr_type is table of tt_air%ROWTYPE index by binary_integer;
dr_table dr_type;
idx int := 100;
begin
dr_table(100).id := 100;
dr_table(100).name := t_air(2,'eert');
select dr_table(`1`).id;
end;
$$
call p1();
ERROR 42S22: Unknown column '1' in 'field list'
drop PROCEDURE p1;
#
# test of sp variable used as variable with null
#
CREATE or replace PROCEDURE p1() as
type dr_type is table of tt_air%ROWTYPE index by binary_integer;
dr_table dr_type;
idx int := 100;
begin
dr_table(100).id := 100;
dr_table(100).name := t_air(2,'eert');
select dr_table(null).id;
end;
$$
call p1();
ERROR HY000: Incorrect parameter 'null' to type table variable.
drop PROCEDURE p1;
#
# test of sp variable used as variable with row_result item
#
CREATE or replace PROCEDURE p1() as
type dr_type is table of tt_air%ROWTYPE index by binary_integer;
dr_table dr_type;
idx int := 100;
begin
dr_table(100).id := 100;
dr_table(100).name := t_air(2,'eert');
select dr_table(dr_table).id;
end;
$$
call p1();
ERROR HY000: Incorrect parameter 'dr_table' to type table variable.
drop PROCEDURE p1;
#
# test of sp variable used as record table's row number
#
CREATE or replace PROCEDURE p1() as
type dr_type is table of tt_air%ROWTYPE index by binary_integer;
dr_table dr_type;
begin
dr_table(100).name.id := 100;
end;
$$
call p1();
ERROR HY000: Reference to uninitialized composite
drop PROCEDURE p1;
#
# test of sp variable used as record table's row number
#
CREATE or replace PROCEDURE p1() as
type dr_type is table of tt_air%ROWTYPE index by binary_integer;
dr_table dr_type;
idx int := 99;
begin
dr_table(100).id := 100;
dr_table(100).name := t_air(2,'eert');
select dr_table(idx+1).id;
end;
$$
call p1();
dr_table(idx+1).id
100
drop PROCEDURE p1;
#
# test of sp variable used as record table's row number
#
CREATE or replace PROCEDURE p1() as
type dr_type is table of tt_air%ROWTYPE index by binary_integer;
dr_table dr_type;
idx int := 99;
begin
dr_table(100).id := 100;
dr_table(100).name := t_air(2,'eert');
select dr_table(`idx+1`).id;
end;
$$
call p1();
ERROR 42S22: Unknown column 'idx+1' in 'field list'
drop PROCEDURE p1;
#
# set to record table with different row
#
CREATE or replace PROCEDURE p1() as
type stu_record is record(
id int := 1,
name_d  varchar(20) := 'a',
score float := 0
);
type tklist is table of stu_record index by binary_integer;
stu_record_val tklist;
stu_record_val1 tklist;
begin
stu_record_val(0).id := 2;
stu_record_val(0).score := 1;
stu_record_val1(10).id := 20;
stu_record_val1 := stu_record_val;
select stu_record_val(0).id,stu_record_val(0).name_d,stu_record_val(0).score;
select stu_record_val1(0).id,stu_record_val1(0).name_d,stu_record_val1(0).score;
end;
$$
call p1();
stu_record_val(0).id	stu_record_val(0).name_d	stu_record_val(0).score
2	a	1
stu_record_val1(0).id	stu_record_val1(0).name_d	stu_record_val1(0).score
2	a	1
drop PROCEDURE p1;
#
# test of table().table()
#
CREATE or replace PROCEDURE p1() as
TYPE rec1 IS RECORD (
col1  t_air,
col2   varchar(30) := 'col2',
col3   varchar(30) := 'col3'
  ); 
TYPE t_rec1 IS TABLE OF rec1 index by binary_integer;
TYPE rec2 IS RECORD (
v_t_rec1  t_rec1,  
col4 varchar(30) := 'col4'
  );
TYPE t_rec2 IS TABLE OF rec2 index by binary_integer; 
TYPE rec3 IS RECORD (
v_t_rec2  t_rec2,  
col5 varchar(30) := 'col5'
  );
TYPE t_rec3 IS TABLE OF rec3 index by binary_integer; 
v_t_rec3 rec3;
BEGIN
v_t_rec3.col5 := 'abc';
v_t_rec3.v_t_rec2(0).v_t_rec1(0).col1.type :='abc';
END;
$$
call p1;
ERROR HY000: Reference to uninitialized composite
drop PROCEDURE p1;
#
# test of table().table()
#
CREATE or replace PROCEDURE p1() as
TYPE rec1 IS RECORD (
col1  t_air := t_air(1,'col1'),
col2   varchar(30) := 'col2',
col3   varchar(30) := 'col3'
  ); 
TYPE t_rec1 IS TABLE OF rec1 index by binary_integer;
TYPE rec2 IS RECORD (
v_t_rec1  t_rec1,  
col4 varchar(30) := 'col4'
  );
TYPE t_rec2 IS TABLE OF rec2 index by binary_integer; 
TYPE rec3 IS RECORD (
v_t_rec2  t_rec2,  
col5 varchar(30) := 'col5'
  );
TYPE t_rec3 IS TABLE OF rec3 index by binary_integer; 
v_t_rec3 rec3;
BEGIN
v_t_rec3.col5 := 'abc';
v_t_rec3.v_t_rec2(0).v_t_rec1(0).col1.type :='type';
select v_t_rec3.v_t_rec2(0).col4,v_t_rec3.col5;
v_t_rec3.v_t_rec2(0).v_t_rec1(1).col2 :='123qwe';
v_t_rec3.v_t_rec2(1).v_t_rec1(0).col2 :='qqqq';
select v_t_rec3.v_t_rec2(0).v_t_rec1(0).col1, v_t_rec3.v_t_rec2(0).v_t_rec1(0).col1.id,v_t_rec3.v_t_rec2(0).v_t_rec1(0).col1.type,v_t_rec3.v_t_rec2(0).v_t_rec1(0).col2,
v_t_rec3.v_t_rec2(0).v_t_rec1(0).col3 ;
select v_t_rec3.v_t_rec2(1).v_t_rec1(0).col1, v_t_rec3.v_t_rec2(1).v_t_rec1(0).col1.id,v_t_rec3.v_t_rec2(1).v_t_rec1(0).col1.type,v_t_rec3.v_t_rec2(1).v_t_rec1(0).col2,
v_t_rec3.v_t_rec2(1).v_t_rec1(0).col3 ;
select v_t_rec3.v_t_rec2(0).v_t_rec1(1).col1, v_t_rec3.v_t_rec2(0).v_t_rec1(1).col1.id,v_t_rec3.v_t_rec2(0).v_t_rec1(1).col1.type,v_t_rec3.v_t_rec2(0).v_t_rec1(1).col2,
v_t_rec3.v_t_rec2(0).v_t_rec1(1).col3 ;
END;
$$
call p1;
v_t_rec3.v_t_rec2(0).col4	v_t_rec3.col5
col4	abc
v_t_rec3.v_t_rec2(0).v_t_rec1(0).col1	v_t_rec3.v_t_rec2(0).v_t_rec1(0).col1.id	v_t_rec3.v_t_rec2(0).v_t_rec1(0).col1.type	v_t_rec3.v_t_rec2(0).v_t_rec1(0).col2	v_t_rec3.v_t_rec2(0).v_t_rec1(0).col3
id:1 | type:type	1	type	col2	col3
v_t_rec3.v_t_rec2(1).v_t_rec1(0).col1	v_t_rec3.v_t_rec2(1).v_t_rec1(0).col1.id	v_t_rec3.v_t_rec2(1).v_t_rec1(0).col1.type	v_t_rec3.v_t_rec2(1).v_t_rec1(0).col2	v_t_rec3.v_t_rec2(1).v_t_rec1(0).col3
id:1 | type:col1	1	col1	qqqq	col3
v_t_rec3.v_t_rec2(0).v_t_rec1(1).col1	v_t_rec3.v_t_rec2(0).v_t_rec1(1).col1.id	v_t_rec3.v_t_rec2(0).v_t_rec1(1).col1.type	v_t_rec3.v_t_rec2(0).v_t_rec1(1).col2	v_t_rec3.v_t_rec2(0).v_t_rec1(1).col3
id:1 | type:col1	1	col1	123qwe	col3
drop PROCEDURE p1;
#
# test of table().table()
#
CREATE or replace PROCEDURE p1() as
TYPE t_rec1 IS TABLE OF tt_air%ROWTYPE index by binary_integer; 
TYPE rec2 IS RECORD (
v_t_rec1  t_rec1,  
col4 varchar(30) := 'col4'
  );
TYPE t_rec2 IS TABLE OF rec2 index by binary_integer; 
TYPE rec3 IS RECORD (
v_t_rec2  t_rec2,  
col5 varchar(30) := 'col5'
  );
TYPE t_rec3 IS TABLE OF rec3 index by binary_integer; 
v_t_rec3 rec3;
BEGIN
v_t_rec3.col5 := 'abc';
v_t_rec3.v_t_rec2(0).v_t_rec1(0).name.type :='abc';
END;
$$
call p1;
ERROR HY000: Reference to uninitialized composite
drop PROCEDURE p1;
#
# test of table().table()
#
CREATE or replace PROCEDURE p1() as
TYPE t_rec1 IS TABLE OF tt_air%ROWTYPE index by binary_integer; 
TYPE rec2 IS RECORD (
v_t_rec1  t_rec1,  
col4 varchar(30) := 'col4'
  );
TYPE t_rec2 IS TABLE OF rec2 index by binary_integer; 
TYPE rec3 IS RECORD (
v_t_rec2  t_rec2,  
col5 varchar(30) := 'col5'
  );
TYPE t_rec3 IS TABLE OF rec3 index by binary_integer; 
v_t_rec3 rec3;
BEGIN
v_t_rec3.col5 := 'abc';
v_t_rec3.v_t_rec2(0).v_t_rec1(0).name :=t_air(0,'type');
select v_t_rec3.v_t_rec2(0).v_t_rec1(0).name,v_t_rec3.v_t_rec2(0).v_t_rec1(0).name.id,v_t_rec3.v_t_rec2(0).v_t_rec1(0).name.type;
END;
$$
call p1;
v_t_rec3.v_t_rec2(0).v_t_rec1(0).name	v_t_rec3.v_t_rec2(0).v_t_rec1(0).name.id	v_t_rec3.v_t_rec2(0).v_t_rec1(0).name.type
id:0 | type:type	0	type
drop PROCEDURE p1;
#
# test of table().udt_table()
#
CREATE or replace PROCEDURE p1() as
TYPE rec2 IS RECORD (
v_t_rec1  t_air_table,  
col4 varchar(30) := 'col4'
  );
TYPE t_rec2 IS TABLE OF rec2 index by binary_integer; 
TYPE rec3 IS RECORD (
v_t_rec2  t_rec2,  
col5 varchar(30) := 'col5'
  );
TYPE t_rec3 IS TABLE OF rec3 index by binary_integer; 
v_t_rec3 rec3;
BEGIN
v_t_rec3.col5 := 'abc';
v_t_rec3.v_t_rec2(0).v_t_rec1 := t_air_table(t_air(1,'col1'));
select v_t_rec3.v_t_rec2(0).v_t_rec1(1).id,v_t_rec3.v_t_rec2(0).v_t_rec1(1).type;
select v_t_rec3.v_t_rec2(0).col4;
END;
$$
call p1;
v_t_rec3.v_t_rec2(0).v_t_rec1(1).id	v_t_rec3.v_t_rec2(0).v_t_rec1(1).type
1	col1
v_t_rec3.v_t_rec2(0).col4
col4
create or replace type t_air1 as object(id int,type varchar(10),i int);
CREATE OR REPLACE TYPE t_air_table AS table OF t_air1;
call p1;
ERROR HY000: inconsistent datatypes: expected 'test'.'t_air1' got 'test'.'t_air'
drop PROCEDURE p1;
#
# test of var as type
#
CREATE or replace PROCEDURE p1() as
TYPE rec2 IS RECORD (
v_t_rec1  t_air_table,  
col4 varchar(30) := 'col4'
  );
TYPE t_rec2 IS TABLE OF rec2 index by binary_integer; 
t_rec t_rec2;
TYPE rec3 IS RECORD (
v_t_rec2  t_rec2 := t_rec(),  
col5 varchar(30) := 'col5'
  );
v_t_rec3 rec3;
BEGIN
END;
$$
ERROR 42000: This version of MySQL doesn't yet support 'the sp variable used like the style e.g: var(a,b..),1=>var()..'
drop table tt_air;
drop type t_air_table;
SELECT name,type,options FROM mysql.routines where name='t_air';
name	type	options
t_air	TYPE	ref_count=1;udt_size=46;
drop type t_air_varray;
SELECT name,type,options FROM mysql.routines where name='t_air';
name	type	options
t_air	TYPE	ref_count=0;udt_size=46;
drop type t_air;
drop type t_air1;
drop type my_integer;
drop type my_varchar;
