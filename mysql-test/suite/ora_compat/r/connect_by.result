set sql_mode=oracle;
SELECT level FROM dual CONNECT BY level <= 5;
level 
1
2
3
4
5
CREATE TABLE student (
id       INT,
name  VARCHAR(10),
grade INT
);
INSERT INTO student VALUES(1, 'John', NULL);
INSERT INTO student VALUES(2, 'Paul', 1);
INSERT INTO student VALUES(3, 'Nancy', 1);
INSERT INTO student VALUES(4, 'Sarah', 3);
SELECT id, name, grade, level
FROM student
CONNECT BY PRIOR id = grade
ORDER BY id;
id	name	grade	level

1	John	NULL	1
2	Paul	1	2
2	Paul	1	1
3	Nancy	1	2
3	Nancy	1	1
4	Sarah	3	3
4	Sarah	3	2
4	Sarah	3	1
SELECT DISTINCT id, name, grade
FROM student
CONNECT BY PRIOR id = grade
ORDER BY id;
id	name	grade
1	John	NULL
2	Paul	1
3	Nancy	1
4	Sarah	3
SELECT id, name, grade, level path
FROM student
CONNECT BY PRIOR id = grade
ORDER BY id;
id	name	grade	path
1	John	NULL	1
2	Paul	1	2
2	Paul	1	1
3	Nancy	1	2
3	Nancy	1	1
4	Sarah	3	3
4	Sarah	3	2
4	Sarah	3	1
SELECT id, name, grade, level  path
FROM student
CONNECT BY  id = PRIOR grade
ORDER BY id;
id	name	grade	path
1	John	NULL	1
1	John	NULL	2
1	John	NULL	2
1	John	NULL	3
2	Paul	1	1
3	Nancy	1	1
3	Nancy	1	2
4	Sarah	3	1
SELECT id, name, grade, level
FROM student
START WITH id > 1
CONNECT BY  id =  grade
ORDER BY id;
id	name	grade	level

2	Paul	1	1
3	Nancy	1	1
4	Sarah	3	1
SELECT id, name, grade, level
FROM student t1
START WITH id > 1
CONNECT BY  prior t1.id =  t1.grade
ORDER BY id;
id	name	grade	level

2	Paul	1	1
3	Nancy	1	1
4	Sarah	3	2
4	Sarah	3	1
SELECT t1.id, name, grade, level
FROM student t1
START WITH id > 1
CONNECT BY  prior t1.id =  t1.grade
ORDER BY id;
id	name	grade	level

2	Paul	1	1
3	Nancy	1	1
4	Sarah	3	2
4	Sarah	3	1
SELECT id, name, grade, level
FROM student
CONNECT BY  id =  grade
START WITH id > 1
ORDER BY id;
id	name	grade	level

2	Paul	1	1
3	Nancy	1	1
4	Sarah	3	1
SELECT id, name, grade, level
FROM student
where id > 1
CONNECT BY  id =  grade
ORDER BY id;
id	name	grade	level

2	Paul	1	1
3	Nancy	1	1
4	Sarah	3	1
SELECT id, name, grade, level
FROM student
where id > 1
start with grade < 3
CONNECT BY  id =  grade
ORDER BY id;
id	name	grade	level

2	Paul	1	1
3	Nancy	1	1
SELECT id, name, grade, level
FROM student
start with grade =1
CONNECT BY  id =  grade
ORDER BY id;
id	name	grade	level

2	Paul	1	1
3	Nancy	1	1
SELECT t.id, name, grade, (t.id+1),level
FROM student t
start with grade =1
CONNECT BY  id =  grade
ORDER BY id;
id	name	grade	(t.id+1)	level

2	Paul	1	3	1
3	Nancy	1	4	1
SELECT id, name, grade, level FROM student t1 CONNECT BY PRIOR id = grade order by  id desc, level ;
id	name	grade	level 
4	Sarah	3	1
4	Sarah	3	2
4	Sarah	3	3
3	Nancy	1	1
3	Nancy	1	2
2	Paul	1	1
2	Paul	1	2
1	John	NULL	1
SELECT id,name, grade, level FROM student t1 CONNECT BY PRIOR id = grade order by  t1.id desc, level ;
id	name	grade	level 
4	Sarah	3	1
4	Sarah	3	2
4	Sarah	3	3
3	Nancy	1	1
3	Nancy	1	2
2	Paul	1	1
2	Paul	1	2
1	John	NULL	1
SELECT t1.name, grade, level FROM student t1 CONNECT BY PRIOR id = grade order by  id desc, level ;
name	grade	level 
Sarah	3	1
Sarah	3	2
Sarah	3	3
Nancy	1	1
Nancy	1	2
Paul	1	1
Paul	1	2
John	NULL	1
SELECT t1.name, grade, level FROM  student t1 CONNECT BY PRIOR id = grade order by  t1.id , level ;
name	grade	level 
John	NULL	1
Paul	1	1
Paul	1	2
Nancy	1	1
Nancy	1	2
Sarah	3	1
Sarah	3	2
Sarah	3	3
select 1 , 'b' , 'c' from student t1 connect by prior id = grade ;
1	b	c
1	b	c
1	b	c
1	b	c
1	b	c
1	b	c
1	b	c
1	b	c
1	b	c
SELECT t1.name, grade, level, rownum FROM  student t1 CONNECT BY PRIOR id = grade  ;
name	grade	level	rownum
John	NULL	1	1
Paul	1	2	2
Nancy	1	2	3
Sarah	3	3	4
Paul	1	1	5
Nancy	1	1	6
Sarah	3	2	7
Sarah	3	1	8
SELECT level, rownum FROM  student t1  where rownum < 3 CONNECT BY PRIOR id = grade  ;
level	rownum
1	1
2	2
SET @v = 0;
prepare stmt FROM 'SELECT t1.name, grade, level FROM student t1 CONNECT BY PRIOR id = grade start with id >? ';
EXECUTE stmt using @v;
name	grade	level 
John	NULL	1
Paul	1	2
Nancy	1	2
Sarah	3	3
Paul	1	1
Nancy	1	1
Sarah	3	2
Sarah	3	1
DEALLOCATE prepare stmt;
prepare stmt FROM 'SELECT t1.name, grade, level FROM ( select  * from student where id < ? )  t1 CONNECT BY PRIOR id = grade ';
EXECUTE stmt using @v;
name	grade	level 
DEALLOCATE prepare stmt;
SELECT id,PRIOR name, grade, level  path
FROM student
CONNECT BY  id = PRIOR grade
ORDER BY id;
id	PRIOR name	grade	path
1	NULL	NULL	1
1	Paul	NULL	2
1	Nancy	NULL	2
1	Nancy	NULL	3
2	NULL	1	1
3	NULL	1	1
3	Sarah	1	2
4	NULL	3	1
explain format =tree
SELECT id,count(id)
FROM student
where id > 1
start with grade < 3
CONNECT BY  id =  grade
group by id;
EXPLAIN
-> Group aggregate: count(student.id)
    -> Sort: student.id
        -> Stream results  (cost=*** rows=***)
            -> Filter: (student.id > 1)  (cost=*** rows=***)
                -> connect by scan:(student.id = student.grade) start with: (student.grade < 3)  (cost=*** rows=***)
                    -> Table scan on student  (cost=*** rows=***)

explain SELECT id, name, grade, level
FROM student
CONNECT BY PRIOR id = grade order by id;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	student	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Connect By; Using temporary; Using filesort
Warnings:
Note	1003	/* select#1 */ select "test"."student"."id" AS "id","test"."student"."name" AS "name","test"."student"."grade" AS "grade",level AS "level
" from "test"."student" connect by (prior "test"."student"."id" = "test"."student"."grade") order by "test"."student"."id"
explain format=tree
SELECT id, name, grade, level
FROM student
CONNECT BY PRIOR id = grade order by id;
EXPLAIN
-> Sort: student.id
    -> Stream results  (cost=*** rows=***)
        -> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior student.id) (reverse)  (cost=*** rows=***)
            -> Table scan on student  (cost=*** rows=***)

SELECT t1.id, name, grade, t1.level
FROM student t1
START WITH id > 1
CONNECT BY  prior t1.id =  t1.grade
ORDER BY id;
ERROR 42S22: Unknown column 't1.level' in 'field list'
SELECT t1.id, name, grade
FROM student t1
START WITH id > 1
CONNECT BY  prior t2.id =  t1.grade
ORDER BY id;
ERROR 42S22: Unknown column 't2.id' in 'connect by clause'
SELECT t1.id, name, grade
FROM student t1
START WITH t2.id > 1
CONNECT BY  prior id =  t1.grade
ORDER BY id;
ERROR 42S22: Unknown column 't2.id' in 'start with clause'
SELECT t1.id, name, grade
FROM student t1
CONNECT BY  prior id =  t1.grade
ORDER BY t2.id;
ERROR 42S22: Unknown column 't2.id' in 'order clause'
SELECT t2.id, name, grade
FROM student t1
CONNECT BY  prior id =  t1.grade
ORDER BY id;
ERROR 42S22: Unknown column 't2.id' in 'field list'
SELECT id, name, grade
FROM student t1
where t2.id != 0
CONNECT BY  prior id =  t1.grade
ORDER BY id;
ERROR 42S22: Unknown column 't2.id' in 'where clause'
CREATE TABLE t2 (
id       INT,
name  VARCHAR(10),
grade INT
);
SELECT t1.id, t2.name, t1.grade
FROM student t1,t2
START WITH t2.id > 1
CONNECT BY  prior t2.id =  t1.grade
ORDER BY t1.id;
id	name	grade
drop table t2;
SELECT a.id,name, grade, level FROM student a where a.id > 1  CONNECT BY PRIOR id = grade;
id	name	grade	level 
2	Paul	1	2
3	Nancy	1	2
4	Sarah	3	3
2	Paul	1	1
3	Nancy	1	1
4	Sarah	3	2
4	Sarah	3	1
SELECT id,name, grade, level FROM student a where a.id > 1  CONNECT BY PRIOR id = grade;
id	name	grade	level 
2	Paul	1	2
3	Nancy	1	2
4	Sarah	3	3
2	Paul	1	1
3	Nancy	1	1
4	Sarah	3	2
4	Sarah	3	1
SELECT * FROM student a where a.id > 1  CONNECT BY PRIOR id = grade;
id	name	grade
2	Paul	1
3	Nancy	1
4	Sarah	3
2	Paul	1
3	Nancy	1
4	Sarah	3
4	Sarah	3
SELECT *,id FROM student a CONNECT BY PRIOR id = grade;
id	name	grade	id
1	John	NULL	1
2	Paul	1	2
3	Nancy	1	3
4	Sarah	3	4
2	Paul	1	2
3	Nancy	1	3
4	Sarah	3	4
4	Sarah	3	4
SELECT id FROM student a CONNECT BY PRIOR id = grade group by id ;
id
1
2
3
4
SELECT id FROM student a CONNECT BY PRIOR id = grade group by a.id ;
id
1
2
3
4
SELECT id FROM student a CONNECT BY PRIOR id = grade group by t2.id;
ERROR 42S22: Unknown column 't2.id' in 'group statement'
SELECT id FROM student a CONNECT BY PRIOR id = grade group by a.id having id > 1;
id
2
3
4
SELECT id FROM student a CONNECT BY PRIOR id = grade group by a.id having a.id > 1;
id
2
3
4
SELECT id FROM student a CONNECT BY PRIOR id = grade group by a.id having b.id > 1;
ERROR 42S22: Unknown column 'b.id' in 'having clause'
SELECT t1.name, grade, level FROM  student t1 CONNECT BY level;
ERROR HY000: An expression of non-boolean type specified to a check constraint 'connect by'.
select *  from student connect by prior id = grade;
id	name	grade
1	John	NULL
2	Paul	1
3	Nancy	1
4	Sarah	3
2	Paul	1
3	Nancy	1
4	Sarah	3
4	Sarah	3
select * from student connect by NOCYCLE  prior id = (grade+1);
id	name	grade
1	John	NULL
2	Paul	1
3	Nancy	1
3	Nancy	1
4	Sarah	3
select id from student connect by  prior id = grade;
id
1
2
3
4
2
3
4
4
select name from student connect by  prior id = grade;
name
John
Paul
Nancy
Sarah
Paul
Nancy
Sarah
Sarah
select grade from student connect by  prior id = grade;
grade
NULL
1
1
3
1
1
3
3
select name,prior name  from student connect by  prior id = grade;
name	prior name  
John	NULL
Paul	John
Nancy	John
Sarah	Nancy
Paul	NULL
Nancy	NULL
Sarah	Nancy
Sarah	NULL
select *,prior name from student connect by  prior id = grade;
id	name	grade	prior name 
1	John	NULL	NULL
2	Paul	1	John
3	Nancy	1	John
4	Sarah	3	Nancy
2	Paul	1	NULL
3	Nancy	1	NULL
4	Sarah	3	Nancy
4	Sarah	3	NULL
select *,prior id from student connect by  prior id = grade;
id	name	grade	prior id 
1	John	NULL	NULL
2	Paul	1	1
3	Nancy	1	1
4	Sarah	3	3
2	Paul	1	NULL
3	Nancy	1	NULL
4	Sarah	3	3
4	Sarah	3	NULL
select *,prior grade from student connect by  prior id = grade;
id	name	grade	prior grade 
1	John	NULL	NULL
2	Paul	1	NULL
3	Nancy	1	NULL
4	Sarah	3	1
2	Paul	1	NULL
3	Nancy	1	NULL
4	Sarah	3	1
4	Sarah	3	NULL
select *,level from student connect by  prior id = grade;
id	name	grade	level 
1	John	NULL	1
2	Paul	1	2
3	Nancy	1	2
4	Sarah	3	3
2	Paul	1	1
3	Nancy	1	1
4	Sarah	3	2
4	Sarah	3	1
select id,grade, level,SYS_CONNECT_BY_PATH(id ,'->'),prior name, CONNECT_BY_ROOT id from student connect by prior id = grade;
id	grade	level	SYS_CONNECT_BY_PATH(id ,'->')	prior name	CONNECT_BY_ROOT id 
1	NULL	1	->1	NULL	1
2	1	2	->1->2	John	1
3	1	2	->1->3	John	1
4	3	3	->1->3->4	Nancy	1
2	1	1	->2	NULL	2
3	1	1	->3	NULL	3
4	3	2	->3->4	Nancy	3
4	3	1	->4	NULL	4
select * from  student connect by  prior id = (grade+1);
ERROR HY000: connect by loop in user data
select * from  student connect by NOCYCLE  prior id = (grade+1);
id	name	grade
1	John	NULL
2	Paul	1
3	Nancy	1
3	Nancy	1
4	Sarah	3
select *,connect_by_iscycle from  student connect by prior id = (grade+1);
ERROR HY000: connect_by_iscycle specified pseudocolumn or operator not allowed : without nocycle
select *,connect_by_isleaf from  student connect by NOCYCLE  prior id = (grade+1);
id	name	grade	connect_by_isleaf 
1	John	NULL	1
2	Paul	1	0
3	Nancy	1	1
3	Nancy	1	1
4	Sarah	3	1
select id,grade, level,concat(SYS_CONNECT_BY_PATH(id ,'->'),'tetst')  from student connect by prior id = grade;
id	grade	level	concat(SYS_CONNECT_BY_PATH(id ,'->'),'tetst')
1	NULL	1	->1tetst
2	1	2	->1->2tetst
3	1	2	->1->3tetst
4	3	3	->1->3->4tetst
2	1	1	->2tetst
3	1	1	->3tetst
4	3	2	->3->4tetst
4	3	1	->4tetst
select id,grade, level,concat(SYS_CONNECT_BY_PATH(id ,'->'),'tetst')  from student connect by prior id = (grade+1);
ERROR HY000: connect by loop in user data
select id,grade, level,concat(SYS_CONNECT_BY_PATH(id ,'->'),'tetst')  from student connect by NOCYCLE prior id = (grade+1);
id	grade	level	concat(SYS_CONNECT_BY_PATH(id ,'->'),'tetst')
1	NULL	1	->1tetst
2	1	1	->2tetst
3	1	2	->2->3tetst
3	1	1	->3tetst
4	3	1	->4tetst
select 12,'test1' from student connect by prior id = grade;
12	test1
12	test1
12	test1
12	test1
12	test1
12	test1
12	test1
12	test1
12	test1
select 12,23 from student connect by prior id = grade+1;
ERROR HY000: connect by loop in user data
select 12,23,level from student connect by prior id = grade+1;
ERROR HY000: connect by loop in user data
select 12,23,CONNECT_BY_ROOT name from student connect by prior id = grade+1;
ERROR HY000: connect by loop in user data
select id,CONNECT_BY_ROOT name from student connect by NOCYCLE prior id = grade+1;
id	CONNECT_BY_ROOT name 
1	John
2	Paul
3	Paul
3	Nancy
4	Sarah
DROP TABLE student;
set sql_mode=default;
DROP TABLE IF EXISTS `t_ucp_authelement`;
Warnings:
Note	1051	Unknown table 'test.t_ucp_authelement'
CREATE TABLE `t_ucp_authelement` (
`AUTHID` varchar(80) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`MODULEID` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`AUTHCODE` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`SUPERCODE` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`AUTHNAME` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`MENUFLAG` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`DESCRIPTION` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`HOSTEDCCID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`AUTHTYPE` tinyint DEFAULT '1',
`REGION` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CREATOR` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CREATEORG` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ISPUBLIC` tinyint DEFAULT '1',
`CREATEDATE` datetime DEFAULT NULL,
`STATUS` tinyint DEFAULT '1',
`STATUSDATE` datetime DEFAULT NULL,
`NOTES` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`RIGHTGROUP` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CREATETYPE` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`DISPLAYNO` int DEFAULT NULL,
`SYSTEMID` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ISDEFORG` tinyint DEFAULT '0',
`STARTDATE` datetime DEFAULT NULL,
`ENDDATE` datetime DEFAULT NULL,
PRIMARY KEY (`AUTHID`)
);
DROP TABLE IF EXISTS `t_ucp_orgainfo`;
Warnings:
Note	1051	Unknown table 'test.t_ucp_orgainfo'
CREATE TABLE `t_ucp_orgainfo` (
`ORGAID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`ORGANAME` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ORGATYPEID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ORGASTATE` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CITYFLAG` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ORGACODE` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`SUPERORGACODE` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ORGADESC` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`PTEAMID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CCFLAG` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`AREACODE` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`MONITORID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`SUPERVISORIDS` varchar(1000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ORDERNUM` int DEFAULT NULL,
`HOSTEDCCID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT '001',
`UPDATETIME` datetime DEFAULT CURRENT_TIMESTAMP,
`BELONGORGA` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ORGALEVEL` tinyint DEFAULT NULL,
`CREATEDATE` datetime DEFAULT NULL,
`BEGINDATE` datetime DEFAULT NULL,
`ENDDATE` datetime DEFAULT NULL,
`STATUSDATE` datetime DEFAULT NULL,
`ISCOUNTY` tinyint DEFAULT NULL,
`ISINNER` tinyint DEFAULT '1',
`BOSSORGAID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`BOSSSUPERORGAID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`MAXLOGINNUM` int DEFAULT NULL,
`PARENTID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`OPENPHONE` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ADDRESS` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`POSTALCODE` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CONTACTSTAFFNO` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CONTACTTELNO` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`FAXNO` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`EMAIL` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`OWNERTYPE` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`USERCOUNT` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CANTONTYPE` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`VALIDATEMODE` tinyint DEFAULT '0',
`AGENTTYPEID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`STARLEVEL` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`DISTTYPEID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ISCHANNELAUTHFILTER` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT 'N',
`CHANNELTYPEID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`DEPARTCODE` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ISPROVCHAIN` tinyint DEFAULT NULL,
`CHAINNAME` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`REGION` int DEFAULT NULL,
`DEALER` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ISTERMINALFEEINCOME` tinyint DEFAULT '1',
`AGENTSTYLE` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`AGENTTYPE` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`REALNAMECODE` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`LSCHANNELID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ISECLCBUSINESS` tinyint DEFAULT NULL,
`ISSTATMOBSELL` varchar(5) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CMIOTFLAG` tinyint DEFAULT NULL,
`GRPCUSTTYPE` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CONTACTPARTYMEMBERNAME` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CONTACTPARTYMEMBERPHONE` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ORGSUBTYPE` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
KEY `IX_UCP_ORGAINFO_PARENTID` (`PARENTID`));
DROP TABLE IF EXISTS `t_ucp_putroleuser`;
Warnings:
Note	1051	Unknown table 'test.t_ucp_putroleuser'
CREATE TABLE `t_ucp_putroleuser` (
`STAFFID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`ROLEID` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`CONDITIONSTR` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`HOSTEDCCID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
PRIMARY KEY (`ROLEID`,`STAFFID`));
DROP TABLE IF EXISTS `t_ucp_role`;
Warnings:
Note	1051	Unknown table 'test.t_ucp_role'
CREATE TABLE `t_ucp_role` (
`ROLEID` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`ROLECODE` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`SUPERCODE` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`ROLENAME` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`DESCRIPTION` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CTIFLAG` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`CTIROLEID` varchar(3) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CCID` bigint DEFAULT NULL,
`VDNID` bigint DEFAULT NULL,
`HOSTEDCCID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ISPUBLIC` tinyint DEFAULT '1',
`CREATOR` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CREATEDATE` datetime DEFAULT NULL,
`CREATEORG` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`STATUS` tinyint DEFAULT NULL,
`STATUSDATE` datetime DEFAULT NULL,
`REGION` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ROLETYPE` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`DISPLAYNO` int DEFAULT '99999',
`WORKSHOPID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ISMODIFYCONTROL` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT '0',
`NOTES` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`REQUIREOP` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`REQUIREORG` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`MANAGEOP` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`MANAGEORG` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
PRIMARY KEY (`ROLEID`));
DROP TABLE IF EXISTS `t_ucp_roleputauth`;
Warnings:
Note	1051	Unknown table 'test.t_ucp_roleputauth'
CREATE TABLE `t_ucp_roleputauth` (
`ROLEID` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`MODULEID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`AUTHID` varchar(80) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`CONDITIONSTR` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`HOSTEDCCID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
PRIMARY KEY (`ROLEID`,`MODULEID`,`AUTHID`));
DROP TABLE IF EXISTS `t_ucp_staffbasicinfo`;
Warnings:
Note	1051	Unknown table 'test.t_ucp_staffbasicinfo'
CREATE TABLE `t_ucp_staffbasicinfo` (
`STAFFID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`STAFFNAME` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`STAFFSTATE` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`STAFFIDSTATUS` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`DLEVELID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`DLMODULUS` decimal(4,2) DEFAULT NULL,
`SECONDPOST` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`DUTYID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`SECONDDUTY` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`PTEAMID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ORGAID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`POSTID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`STAFFACCOUNT` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`DISABLEBEGINDATE` datetime DEFAULT NULL,
`DISABLEENDDATE` datetime DEFAULT NULL,
`HOSTEDCCID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`PERSONALCFGID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`UPDATETIME` datetime DEFAULT CURRENT_TIMESTAMP,
`BATCHNO` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`STAFFTYPE` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ISMANAGER` tinyint DEFAULT NULL,
`HRSTATUS` tinyint DEFAULT NULL,
`CREATEDATE` datetime DEFAULT NULL,
`STATUSDATE` datetime DEFAULT NULL,
`REMARK` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`REGION` int DEFAULT NULL,
`BEGINDATE` datetime DEFAULT NULL,
`ENDDATE` datetime DEFAULT NULL,
`RELESTAFFID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`WORKEFFICIENCY` int DEFAULT NULL,
`TELNO` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`LOGINTYPE` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`WORKTYPE` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`AREAID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`EMPLOYEETYPE` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`STAFFNUMBER` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`STAFFIDUSE` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ISADMIN` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`PETNAME` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`ISMODIFYCONTROL` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT '0',
`RESPCITYID` varchar(40) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`NOTMODSTATUS` varchar(8) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CURRENTORGAID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CURRENTREGION` int DEFAULT NULL,
`SALESCENE` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`CHANNELTYPE` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`LOGINCHKPHOTO` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT '0',
`UPLOADPHOTO` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT '0',
`USERNAME` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
PRIMARY KEY (`STAFFID`));
DROP TABLE IF EXISTS `t_ucp_staffrole`;
Warnings:
Note	1051	Unknown table 'test.t_ucp_staffrole'
CREATE TABLE `t_ucp_staffrole` (
`ROLEID` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`STAFFID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`CONDITIONSTR` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`HOSTEDCCID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`STATUS` tinyint DEFAULT '1',
`STATUSDATE` datetime DEFAULT CURRENT_TIMESTAMP,
`CREATEDATE` datetime DEFAULT CURRENT_TIMESTAMP,
`ORGAID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`BEGINDATE` datetime DEFAULT CURRENT_TIMESTAMP,
`ENDDATE` datetime DEFAULT CURRENT_TIMESTAMP,
`ROAMSTATIONID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT '0',
`NOTES` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
KEY `IX_UCP_STAFFROLE_STAFF` (`STAFFID`));
DROP TABLE IF EXISTS `t_ucp_putauth`;
Warnings:
Note	1051	Unknown table 'test.t_ucp_putauth'
CREATE TABLE `t_ucp_putauth` (
`STAFFID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`MODULEID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`AUTHID` varchar(80) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
`CONDITIONSTR` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`HOSTEDCCID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
`BEGINDATE` datetime DEFAULT CURRENT_TIMESTAMP,
`ENDDATE` datetime DEFAULT CURRENT_TIMESTAMP,
PRIMARY KEY (`STAFFID`,`MODULEID`,`AUTHID`));
set sql_mode=oracle;
select * from (select distinct a.authid, a.authcode, a.supercode, a.authname, a.menuflag, a.description, a.moduleid, a.region, a.creator, a.createorg, a.ispublic, a.createdate, a.status, a.statusdate, a.createtype, a.rightgroup, a.displayno, a.systemid from t_ucp_authelement a connect by prior a.supercode = a.authcode start with exists (select authid from ( select b.authid from t_ucp_putauth b where b.staffid = 1 union all select c.authid from t_ucp_roleputauth c, t_ucp_staffrole d where c.roleid = d.roleid and d.staffid = 1 ) where authid = a.authid )) where 1 = 1 and supercode = 2 and status = 1 order by displayno, supercode, authcode;
authid	authcode	supercode	authname	menuflag	description	moduleid	region	creator	createorg	ispublic	createdate	status	statusdate	createtype	rightgroup	displayno	systemid
select * from (select distinct a.authid, a.authcode, a.supercode, a.authname, a.menuflag, a.description, a.moduleid, a.region, a.creator, a.createorg, a.ispublic, a.createdate, a.status, a.statusdate, a.createtype, a.rightgroup, a.displayno, a.systemid from t_ucp_authelement a connect by prior a.supercode = a.authcode start with exists (select authid from ( select b.authid from t_ucp_putauth b where b.staffid = 1 union all select c.authid from t_ucp_roleputauth c, t_ucp_staffrole d where c.roleid = d.roleid and d.staffid = 1 ) where authid = a.authid )) where 1 = 1 and supercode = 2 order by displayno, supercode, authcode;
authid	authcode	supercode	authname	menuflag	description	moduleid	region	creator	createorg	ispublic	createdate	status	statusdate	createtype	rightgroup	displayno	systemid
select * from (select distinct a.ctiroleid, a.rolename, a.rolecode, a.description, a.ccid, a.roleid, a.supercode, a.vdnid, a.ctiflag, a.roletype, a.displayno, a.status from t_ucp_role a connect by prior a.supercode = a.rolecode start with exists (select b.roleid from t_ucp_putroleuser b where a.roleid = b.roleid and b.staffid = 1)) where 1 = 1 and status = 1 and supercode = 2 order by displayno, rolecode;
ctiroleid	rolename	rolecode	description	ccid	roleid	supercode	vdnid	ctiflag	roletype	displayno	status
select * from (select distinct a.ctiroleid, a.rolename, a.rolecode, a.description, a.ccid, a.roleid, a.supercode, a.vdnid, a.ctiflag, a.roletype, a.workshopid, a.displayno from t_ucp_role a connect by prior a.supercode = a.rolecode start with exists (select b.roleid from t_ucp_putroleuser b where a.roleid = b.roleid and b.staffid = 1 )) where 1 = 1 and supercode = 2 order by displayno, rolecode;
ctiroleid	rolename	rolecode	description	ccid	roleid	supercode	vdnid	ctiflag	roletype	workshopid	displayno
select * from (select distinct a.ctiroleid, a.rolename, a.rolecode, a.description, a.ccid, a.roleid, a.supercode, a.vdnid, a.ctiflag, a.roletype, a.workshopid, a.displayno from t_ucp_role a connect by prior a.supercode = a.rolecode start with exists (select b.roleid from t_ucp_putroleuser b where a.roleid = b.roleid and b.staffid = 1 )) where 1 = 1 order by displayno, rolecode;
ctiroleid	rolename	rolecode	description	ccid	roleid	supercode	vdnid	ctiflag	roletype	workshopid	displayno
select authid, authcode, supercode, authname, menuflag, description, moduleid, region, creator, createorg, ispublic, createdate, status, statusdate, createtype, rightgroup, systemid from t_ucp_authelement start with authid = 11 connect by prior supercode = authcode;
authid	authcode	supercode	authname	menuflag	description	moduleid	region	creator	createorg	ispublic	createdate	status	statusdate	createtype	rightgroup	systemid
select ctiroleid, rolename, rolecode, description, ccid, roleid, supercode, vdnid, ctiflag from t_ucp_role start with roleid = 1 connect by prior supercode = rolecode;
ctiroleid	rolename	rolecode	description	ccid	roleid	supercode	vdnid	ctiflag
select ctiroleid, rolename, rolecode, description, ccid, roleid, supercode, vdnid, ctiflag from t_ucp_role start with roleid = 1 connect by prior supercode = rolecode;
ctiroleid	rolename	rolecode	description	ccid	roleid	supercode	vdnid	ctiflag
select distinct a.orgacode from t_ucp_orgainfo a connect by prior a.superorgacode = a.orgacode start with a.orgacode = 1;
orgacode
select distinct a.orgaid from t_ucp_orgainfo a connect by prior a.parentid = a.orgaid start with a.orgaid = 1;
orgaid
select distinct t1.staffid, t1.staffname, t1.staffstate, t1.staffidstatus, t1.orgaid, t1.dlevelid, t1.dlmodulus, t1.secondpost, t1.dutyid, t1.secondduty, t1.postid, t1.pteamid, t1.hostedccid, t1.staffaccount, t1.disableenddate, t1.disablebegindate, t1.personalcfgid, t1.batchno, t1.workefficiency, t1.region, t1.stafftype, t1.ismanager, t1.hrstatus, t1.createdate, t1.begindate, t1.enddate, t1.statusdate, t1.remark, t1.relestaffid, t1.telno, t1.logintype, t1.worktype, t1.employeetype, t1.areaid from t_ucp_staffbasicinfo t1, t_ucp_staffrole t2 where t1.orgaid in (select orgaid from (select level aaa, a.orgaid from t_ucp_orgainfo a start with orgaid = (select orgaid from t_ucp_staffbasicinfo where staffid = 1 ) connect by prior parentid = orgaid) t where t.aaa <= 1 ) and t1.staffstate = '1' and t1.staffidstatus = '01' and t2.staffid = t1.staffid and t2.roleid = 1 order by t1.staffid asc;
staffid	staffname	staffstate	staffidstatus	orgaid	dlevelid	dlmodulus	secondpost	dutyid	secondduty	postid	pteamid	hostedccid	staffaccount	disableenddate	disablebegindate	personalcfgid	batchno	workefficiency	region	stafftype	ismanager	hrstatus	createdate	begindate	enddate	statusdate	remark	relestaffid	telno	logintype	worktype	employeetype	areaid
select distinct t1.staffid, t1.staffname, t1.staffstate, t1.staffidstatus, t1.orgaid, t1.dlevelid, t1.dlmodulus, t1.secondpost, t1.dutyid, t1.secondduty, t1.postid, t1.pteamid, t1.hostedccid, t1.staffaccount, t1.disableenddate, t1.disablebegindate, t1.personalcfgid, t1.batchno, t1.workefficiency, t1.region, t1.stafftype, t1.ismanager, t1.hrstatus, t1.createdate, t1.begindate, t1.enddate, t1.statusdate, t1.remark, t1.relestaffid, t1.telno, t1.logintype, t1.worktype, t1.employeetype, t1.areaid from t_ucp_staffbasicinfo t1, t_ucp_staffrole t2 where t1.orgaid in (select orgaid from (select level aaa, a.orgaid from t_ucp_orgainfo a start with orgaid = (select orgaid from t_ucp_staffbasicinfo where staffid = 1 ) connect by prior parentid = orgaid) t where t.aaa <= 1 ) and t1.staffstate = '1' and t1.staffidstatus = '01' and t2.staffid = t1.staffid and t2.roleid like 'monitorconfirm%';
staffid	staffname	staffstate	staffidstatus	orgaid	dlevelid	dlmodulus	secondpost	dutyid	secondduty	postid	pteamid	hostedccid	staffaccount	disableenddate	disablebegindate	personalcfgid	batchno	workefficiency	region	stafftype	ismanager	hrstatus	createdate	begindate	enddate	statusdate	remark	relestaffid	telno	logintype	worktype	employeetype	areaid
select orgacode, orgadesc, organame, orgatypeid, orgastate, cityflag, pteamid, orgaid, superorgacode, ccflag, areacode, monitorid, maxloginnum, supervisorids, ordernum, belongorga, orgalevel, createdate, begindate, enddate, statusdate, isinner, parentid, openphone, address, postalcode, contactstaffno, contacttelno, faxno, email, ownertype, validatemode, cantontype from t_ucp_orgainfo t start with t.orgaid = 1 connect by prior t.parentid = t.orgaid order by t.orgacode;
orgacode	orgadesc	organame	orgatypeid	orgastate	cityflag	pteamid	orgaid	superorgacode	ccflag	areacode	monitorid	maxloginnum	supervisorids	ordernum	belongorga	orgalevel	createdate	begindate	enddate	statusdate	isinner	parentid	openphone	address	postalcode	contactstaffno	contacttelno	faxno	email	ownertype	validatemode	cantontype
select orgacode, orgadesc, organame, orgatypeid, orgastate, cityflag, pteamid, orgaid, superorgacode, ccflag, areacode, monitorid, maxloginnum, supervisorids, ordernum, belongorga, orgalevel, createdate, begindate, enddate, statusdate, isinner, parentid, openphone, address, postalcode, contactstaffno, contacttelno, faxno, email, ownertype, validatemode, cantontype from t_ucp_orgainfo t start with t.orgaid = 1 connect by prior t.parentid = t.orgaid order by t.orgacode;
orgacode	orgadesc	organame	orgatypeid	orgastate	cityflag	pteamid	orgaid	superorgacode	ccflag	areacode	monitorid	maxloginnum	supervisorids	ordernum	belongorga	orgalevel	createdate	begindate	enddate	statusdate	isinner	parentid	openphone	address	postalcode	contactstaffno	contacttelno	faxno	email	ownertype	validatemode	cantontype
select t.roleid, b.rolename, t.staffid from t_ucp_staffrole t, t_ucp_role b where t.roleid in (select t.roleid from t_ucp_role t start with t.rolename like '_报表话务员类型%' connect by prior t.rolecode = t.supercode) and t.roleid = b.roleid and translate(t.staffid, 'a0123456789', 'a') is null;
roleid	rolename	staffid
drop table t_ucp_authelement,t_ucp_orgainfo,t_ucp_putroleuser,t_ucp_role,t_ucp_roleputauth,t_ucp_staffbasicinfo,t_ucp_staffrole,t_ucp_putauth;
create table tt1
(
id varchar(64),
pid varchar(64)
);
INSERT INTO tt1 VALUES('1',  NULL);
INSERT INTO tt1 VALUES('2',  '1');
INSERT INTO tt1 VALUES('3',  '1');
INSERT INTO tt1 VALUES('4',  '3');
select * from tt1 aa connect by aa.id = prior aa.pid;
id	pid
1	NULL
2	1
1	NULL
3	1
1	NULL
4	3
3	1
1	NULL
drop table tt1;
select level from dual connect by level < 1;
level 
1
select level from dual connect by level < 2;
level 
1
select level from dual connect by level < 3;
level 
1
2
set timestamp=1;
select now() from dual connect by level < 3;
now()
1970-01-01 03:00:01
1970-01-01 03:00:01
select 1 from dual connect by level < 3;
1
1
1
set sql_mode=oracle;
set shrink_sql_mode='STRICT_TRANS_TABLES,STRICT_ALL_TABLES';
DROP TABLE IF EXISTS tbl_test;
Warnings:
Note	1051	Unknown table 'test.tbl_test'
CREATE TABLE tbl_test
(
ID int,
NAME VARCHAR2(100),
PID NUMBER DEFAULT 0
) partition by hash(id) partitions 15 ;
INSERT INTO tbl_test(ID,NAME,PID) VALUES(1,'10','0');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(2,'11','1');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(3,'20','0');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(4,'12','1');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(5,'121','2');
DROP TABLE IF EXISTS emp;
Warnings:
Note	1051	Unknown table 'test.emp'
create table  emp
(	 empno  int,
ename  varchar2(10),
job  varchar2(9),
mgr  number(4,0),
hiredate  date,
sal  number(7,2),
comm  number(7,2),
deptno  number(2,0)
)  partition by hash(empno) partitions 15 ;
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7369,'smith','clerk',7902,'2017-12-08',800,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7499,'allen','salesman',7698,'2020-02-08',1600,300,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7521,'ward','salesman',7698,'2022-02-08',1250,500,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7566,'jones','manager',7839,'2002-10-01',2975,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7654,'martin','salesman',7698,'2001-02-09',1250,1400,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7698,'blake','manager',7839,'2023-03-08',2850,null,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7782,'clark','manager',7839,'2021-01-18',2450,null,10);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7788,'SCOTT','analyst',7566,'2019-06-07',3000,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7839,'KING','president',null,'2019-07-07',5000,null,10);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7844,'turner','salesman',7698,'2021-04-17',1500,0,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7876,'adams','clerk',7788,'2022-01-01',1100,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7900,'james','clerk',7698,'2018-01-08',950,null,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7902,'ford','analyst',7566,'2017-02-08',3000,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7934,'miller','clerk',7782,'2016-02-08',1300,null,10);
DROP TABLE IF EXISTS empmessage;
Warnings:
Note	1051	Unknown table 'test.empmessage'
create table empmessage(
empno number,
weight varchar(100)
);
insert into empmessage values(7369,'70kg');
insert into empmessage values(7499,'74kg');
insert into empmessage values(7521,'73kg');
insert into empmessage values(7566,'80kg');
insert into empmessage values(7654,'90kg');
insert into empmessage values(7698,'81kg');
insert into empmessage values(7782,'83kg');
insert into empmessage values(7788,'84kg');
insert into empmessage values(7839,'88kg');
select * from tbl_test  connect by prior id = pid;
ID	NAME	PID
1	10	0
2	11	1
5	121	2
4	12	1
2	11	1
5	121	2
3	20	0
4	12	1
5	121	2
select * from tbl_test  connect by pid  =  prior id;
ID	NAME	PID
1	10	0
2	11	1
5	121	2
4	12	1
2	11	1
5	121	2
3	20	0
4	12	1
5	121	2
DROP TABLE IF EXISTS t1,t2,t3,t4;
Warnings:
Note	1051	Unknown table 'test.t1'
Note	1051	Unknown table 'test.t2'
Note	1051	Unknown table 'test.t3'
Note	1051	Unknown table 'test.t4'
DROP TABLE IF EXISTS emp,empmessage,tbl_test;
CREATE TABLE student (
id       INT,
name  VARCHAR(10),
grade INT
);
INSERT INTO student VALUES(1, 'John', -1);
INSERT INTO student VALUES(2, 'Paul', 1);
INSERT INTO student VALUES(3, 'Nancy', 1);
INSERT INTO student VALUES(4, 'Sarah', 2);
select id,name,grade,prior name from student;
ERROR HY000: prior specified pseudocolumn or operator not allowed :without connect by
select id,name,grade,prior name from student connect by prior id = grade;
id	name	grade	prior name 
1	John	-1	NULL
2	Paul	1	John
4	Sarah	2	Paul
3	Nancy	1	John
2	Paul	1	NULL
4	Sarah	2	Paul
3	Nancy	1	NULL
4	Sarah	2	NULL
select id,name,grade,prior level from student connect by prior id = grade;
ERROR HY000: prior specified pseudocolumn or operator not allowed :level
select *,prior name from student start with  prior name is not null connect by id < 1;
ERROR HY000: prior specified pseudocolumn or operator not allowed :field list
select id,prior max(id) from student  connect by prior id = grade;
ERROR HY000: prior specified pseudocolumn or operator not allowed :max
select id,prior max(id) from student  connect by prior id = grade;
ERROR HY000: prior specified pseudocolumn or operator not allowed :max
select id,name,grade,prior name from student where prior name is not  null  connect by prior id = grade;
id	name	grade	prior name 
2	Paul	1	John
4	Sarah	2	Paul
3	Nancy	1	John
4	Sarah	2	Paul
select id from student   connect by prior id = grade group by id,prior grade;
id
1
2
2
3
3
4
4
select id from student connect by prior id = grade order by id,prior grade;
id
1
2
2
3
3
4
4
4
select id , lag(id, 1)over() from student connect by prior id = grade;
id	lag(id, 1)over()
1	NULL
2	1
4	2
3	4
2	3
4	2
3	4
4	3
select id , lag(id, 1)over() from student connect by prior id = grade group by id ;
id	lag(id, 1)over()
1	NULL
2	1
3	2
4	3
select id ,prior grade from student connect by prior id = grade ;
id	prior grade 
1	NULL
2	-1
4	1
3	-1
2	NULL
4	1
3	NULL
4	NULL
select id ,(prior grade)+1 from student connect by prior id = grade ;
id	(prior grade)+1
1	NULL
2	0
4	2
3	0
2	NULL
4	2
3	NULL
4	NULL
explain format=tree
select id from student connect by prior id = grade group by id,prior grade;
EXPLAIN
-> Group (no aggregates)
    -> Sort: student.id, prior student.grade
        -> Stream results  (cost=*** rows=***)
            -> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior student.id) (reverse)  (cost=*** rows=***)
                -> Table scan on student  (cost=*** rows=***)

select id,name,grade,connect_by_root name from student;
ERROR HY000: connect_by_root specified pseudocolumn or operator not allowed :without connect by
select id,connect_by_root name from student connect by prior id = grade;
id	connect_by_root name 
1	John
2	John
4	John
3	John
2	Paul
4	Paul
3	Nancy
4	Sarah
select id,connect_by_root level from student connect by prior id = grade;
ERROR HY000: connect_by_root specified pseudocolumn or operator not allowed :level
select id,connect_by_root name  from student start with connect_by_root id connect by prior id = grade;
ERROR HY000: connect_by_root specified pseudocolumn or operator not allowed :field list
select id  from student where connect_by_root name is not null connect by prior id = grade;
id
1
2
4
3
2
4
3
4
select id  from student connect by prior id = grade group by id, connect_by_root name;
id
1
2
2
3
3
4
4
4
select id  from student connect by prior id = grade order by connect_by_root grade ;
id
1
2
4
3
2
4
3
4
select id,name,grade,SYS_CONNECT_BY_PATH(name,'->') from student;
ERROR HY000: sys_connect_by_path specified pseudocolumn or operator not allowed :without connect by
select id,SYS_CONNECT_BY_PATH(name,'->') from student connect by id < 1;
id	SYS_CONNECT_BY_PATH(name,'->')
1	->John
2	->Paul
3	->Nancy
4	->Sarah
select id,concat(SYS_CONNECT_BY_PATH(name,'->'), ' end_str') from student connect by prior id = grade;
id	concat(SYS_CONNECT_BY_PATH(name,'->'), ' end_str')
1	->John end_str
2	->John->Paul end_str
4	->John->Paul->Sarah end_str
3	->John->Nancy end_str
2	->Paul end_str
4	->Paul->Sarah end_str
3	->Nancy end_str
4	->Sarah end_str
select id,SYS_CONNECT_BY_PATH(level,'->') from student connect by prior id = grade;
id	SYS_CONNECT_BY_PATH(level,'->')
1	->1
2	->1->2
4	->1->2->3
3	->1->2
2	->1
4	->1->2
3	->1
4	->1
select id,name,grade from student where SYS_CONNECT_BY_PATH(name,'->') is not null connect by id < 1;
ERROR HY000: sys_connect_by_path specified pseudocolumn or operator not allowed :field list
select id from student  connect by id < 1 group by SYS_CONNECT_BY_PATH(name,'->');
ERROR HY000: sys_connect_by_path specified pseudocolumn or operator not allowed :field list
select id from student  connect by id < 1 order by SYS_CONNECT_BY_PATH(name,'->');
ERROR HY000: sys_connect_by_path specified pseudocolumn or operator not allowed :global ORDER clause
select *,level from student;
ERROR 42S22: Unknown column 'level' in 'field list'
select id,name,grade,level from student connect by id < 1;
id	name	grade	level 
1	John	-1	1
2	Paul	1	1
3	Nancy	1	1
4	Sarah	2	1
select id,name,grade from student start with level = 0  connect by id < 1;
id	name	grade
select id,name,grade from student where level <> 0  connect by id < 1;
id	name	grade
1	John	-1
2	Paul	1
3	Nancy	1
4	Sarah	2
select level from student connect by id < 1 group by level ;
level 
1
select id from student  connect by id < 1 group by id,level having level <> 1 ;
ERROR 42S22: Unknown column 'level' in 'having clause'
select level from student  connect by id < 1  order  by level;
level 
1
1
1
1
select *,connect_by_isleaf from student;
ERROR HY000: connect_by_isleaf specified pseudocolumn or operator not allowed :without connect by
select *,connect_by_isleaf from student connect by level < 1;
id	name	grade	connect_by_isleaf 
1	John	-1	1
2	Paul	1	1
3	Nancy	1	1
4	Sarah	2	1
select id,name,grade,connect_by_isleaf from student connect by nocycle level < 1;
id	name	grade	connect_by_isleaf 
1	John	-1	1
2	Paul	1	1
3	Nancy	1	1
4	Sarah	2	1
select id,name,grade from student start with connect_by_isleaf = 0 connect by nocycle level < 1;
ERROR HY000: connect_by_isleaf specified pseudocolumn or operator not allowed :field list
select id,name,grade from student where connect_by_isleaf = 1 connect by nocycle level < 1;
id	name	grade
1	John	-1
2	Paul	1
3	Nancy	1
4	Sarah	2
select id,name,grade from student where connect_by_isleaf = 1 connect by nocycle connect_by_isleaf < 1;
ERROR HY000: connect_by_isleaf specified pseudocolumn or operator not allowed :connect by
select id from student connect by nocycle level < 1 group by id, connect_by_isleaf;
id
1
2
3
4
select id from student connect by nocycle level < 1 group by id, connect_by_isleaf having connect_by_isleaf <> 1;
id
select id,connect_by_isleaf from student connect by nocycle level < 1 order by connect_by_isleaf;
id	connect_by_isleaf 
1	1
2	1
3	1
4	1
select id,name,grade,connect_by_isleaf from student connect by nocycle prior id = (grade +1);
id	name	grade	connect_by_isleaf 
1	John	-1	1
2	Paul	1	0
3	Nancy	1	0
4	Sarah	2	1
3	Nancy	1	0
4	Sarah	2	1
4	Sarah	2	1
select *,connect_by_iscycle from student;
ERROR HY000: connect_by_iscycle specified pseudocolumn or operator not allowed :without connect by
select *,connect_by_iscycle from student connect by level < 1;
ERROR HY000: connect_by_iscycle specified pseudocolumn or operator not allowed : without nocycle
select id,name,grade,connect_by_iscycle from student connect by nocycle level < 1;
id	name	grade	connect_by_iscycle 
1	John	-1	0
2	Paul	1	0
3	Nancy	1	0
4	Sarah	2	0
select * from student start with connect_by_iscycle = 0 connect by nocycle level < 1;
ERROR HY000: connect_by_iscycle specified pseudocolumn or operator not allowed :field list
select * from student  connect by nocycle connect_by_iscycle  <> 0;
ERROR HY000: connect_by_iscycle specified pseudocolumn or operator not allowed :connect by
select id,name,grade from student where connect_by_iscycle = 0 connect by nocycle level < 1;
id	name	grade
1	John	-1
2	Paul	1
3	Nancy	1
4	Sarah	2
select id,name,grade from student where connect_by_iscycle = 1 connect by nocycle level < 1;
id	name	grade
select id from student connect by nocycle level < 1 group by id, connect_by_iscycle;
id
1
2
3
4
select id from student connect by nocycle level < 1 group by id, connect_by_iscycle having connect_by_iscycle <> 1;
id
1
2
3
4
select id,connect_by_iscycle from student connect by nocycle level < 1 order by connect_by_iscycle;
id	connect_by_iscycle 
1	0
2	0
3	0
4	0
select id,name,grade,connect_by_iscycle from student connect by nocycle prior id = (grade +1);
id	name	grade	connect_by_iscycle 
1	John	-1	0
2	Paul	1	1
3	Nancy	1	0
4	Sarah	2	0
3	Nancy	1	0
4	Sarah	2	0
4	Sarah	2	0
select 1 ,'test' from student connect by prior id = (grade +1);
ERROR HY000: connect by loop in user data
select 1 ,'test' from student connect by nocycle prior id = (grade +1);
1	test
1	test
1	test
1	test
1	test
1	test
1	test
1	test
select 1 ,'test' from student connect by nocycle id < 3;
ERROR HY000: Recursive query aborted after 1000 iterations. Try increasing @@cte_max_recursion_depth to a larger value.
select id,grade,name,level from student connect by nocycle prior id = (grade +1);
id	grade	name	level 
1	-1	John	1
2	1	Paul	1
3	1	Nancy	2
4	2	Sarah	3
3	1	Nancy	1
4	2	Sarah	2
4	2	Sarah	1
set timestamp=1;
select id,grade,now() from student connect by nocycle prior id = (grade +1);
id	grade	now()
1	-1	1970-01-01 03:00:01
2	1	1970-01-01 03:00:01
3	1	1970-01-01 03:00:01
4	2	1970-01-01 03:00:01
3	1	1970-01-01 03:00:01
4	2	1970-01-01 03:00:01
4	2	1970-01-01 03:00:01
select max(id) from student connect by prior id = grade group by id;
max(id)
1
2
3
4
select id,max(id) from student connect by prior id = grade group by id;
id	max(id)
1	1
2	2
3	3
4	4
select max(id),LISTAGG(name, '->') from student connect by prior id = grade;
max(id)	LISTAGG(name, '->')
4	John->Paul->Sarah->Nancy->Paul->Sarah->Nancy->Sarah
explain format=tree select id,max(id) from student connect by prior id = grade group by id;
EXPLAIN
-> Group aggregate: max(student.id)
    -> Sort: student.id
        -> Stream results  (cost=*** rows=***)
            -> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior student.id) (reverse)  (cost=*** rows=***)
                -> Table scan on student  (cost=*** rows=***)

select id,LISTAGG(name, '->') from student connect by NOCYCLE prior id = (grade +1) group by id;
id	LISTAGG(name, '->')
1	John
2	Paul
3	Nancy->Nancy
4	Sarah->Sarah->Sarah
select max(id),LISTAGG(level, '->') from student connect by prior id = grade;
max(id)	LISTAGG(level, '->')
4	1->2->3->2->1->2->1->1
explain format=tree select max(id),LISTAGG(level, '->') from student connect by prior id = grade;
EXPLAIN
-> Aggregate: max(student.id), listagg(tmp_field , '->')  (cost=*** rows=***)
    -> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior student.id) (reverse)  (cost=*** rows=***)
        -> Table scan on student  (cost=*** rows=***)

select max(id),LISTAGG(level, '->') from student connect by prior id = grade group by id;
max(id)	LISTAGG(level, '->')
1	1
2	2->1
3	2->1
4	3->2->1
explain format=tree select max(id),LISTAGG(level, '->') from student connect by prior id = grade group by id;
EXPLAIN
-> Group aggregate: max(student.id), listagg(tmp_field , '->')
    -> Sort: student.id
        -> Stream results  (cost=*** rows=***)
            -> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior student.id) (reverse)  (cost=*** rows=***)
                -> Table scan on student  (cost=*** rows=***)

select * from (select id,grade from student connect by prior id = grade) s2 where id > 3;
id	grade
4	2
4	2
4	2
explain format=tree select * from (select id,grade from student connect by prior id = grade) s2 where id > 3;
EXPLAIN
-> Filter: (s2.id > 3)  (cost=*** rows=***)
    -> Table scan on s2  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior student.id) (reverse)  (cost=*** rows=***)
                -> Table scan on student  (cost=*** rows=***)

select  * from (select * from student connect by prior id = grade) a where id = 2;
id	name	grade
2	Paul	1
2	Paul	1
select  * from (select * from student where id > 1) a  connect by prior id = grade;
id	name	grade
2	Paul	1
4	Sarah	2
3	Nancy	1
4	Sarah	2
select * from (select * from (select id, grade from student) t connect by prior id = grade) t2 where id =2;
id	grade
2	1
2	1
explain format=tree select  * from (select * from student connect by prior id = grade) a where id = 2;
EXPLAIN
-> Index lookup on a using <auto_key0> (id=2)  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior student.id) (reverse)  (cost=*** rows=***)
            -> Table scan on student  (cost=*** rows=***)

explain format=tree select  * from (select * from student where id > 1) a  connect by prior id = grade;
EXPLAIN
-> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior student.id) (reverse)  (cost=*** rows=***)
    -> Filter: (student.id > 1)  (cost=*** rows=***)
        -> Table scan on student  (cost=*** rows=***)

explain format=tree select * from (select * from (select id, grade from student) t connect by prior id = grade) t2 where id =2;
EXPLAIN
-> Index lookup on t2 using <auto_key0> (id=2)  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior student.id) (reverse)  (cost=*** rows=***)
            -> Table scan on student  (cost=*** rows=***)

drop table student;
CREATE TABLE student (
id    INT primary key,
name  VARCHAR(10),
grade INT
);
INSERT INTO student VALUES(1, 'John', -1);
INSERT INTO student VALUES(2, 'Paul', 1);
INSERT INTO student VALUES(3, 'Nancy', 1);
INSERT INTO student VALUES(4, 'Sarah', 2);
select id,max(id) from student connect by prior id = grade group by id;
id	max(id)
1	1
2	2
3	3
4	4
create table t2(grade int,name varchar2(200));
insert into t2 values(1, 'test1');
insert into t2 values(2, 'test2');
insert into t2 values(3, 'test3');
insert into t2 values(4, 'test4');
create table s1(id int,grade int);
insert into s1 values(1, -1);
insert into s1 values(2, 1);
insert into s1 values(3, 1);
insert into s1 values(4, 2);
select s1.id , s1.grade, t2.name  from s1,t2 where s1.id = t2.grade connect by prior s1.id = s1.grade;
id	grade	name
1	-1	test1
2	1	test2
4	2	test4
3	1	test3
2	1	test2
4	2	test4
3	1	test3
4	2	test4
select s1.id , s1.grade, t2.name  from s1 join t2 on s1.id = t2.grade connect by prior s1.id = s1.grade;
id	grade	name
1	-1	test1
2	1	test2
4	2	test4
3	1	test3
2	1	test2
4	2	test4
3	1	test3
4	2	test4
explain format=tree select s1.id , s1.grade, t2.name  from s1,t2 where s1.id = t2.grade connect by prior s1.id = s1.grade;
EXPLAIN
-> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior s1.id) (reverse)  (cost=*** rows=***)
    -> Inner hash join (t2.grade = s1.id)  (cost=*** rows=***)
        -> Table scan on t2  (cost=*** rows=***)
        -> Hash
            -> Table scan on s1  (cost=*** rows=***)

select s1.id , s1.grade, t2.name  from s1 join t2 on s1.id = t2.grade and s1.id > 3  connect by prior s1.id = s1.grade;
id	grade	name
4	2	test4
explain format=tree select s1.id , s1.grade, t2.name  from s1 join t2 on s1.id = t2.grade and s1.id > 3  connect by prior s1.id = s1.grade;
EXPLAIN
-> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior s1.id) (reverse)  (cost=*** rows=***)
    -> Inner hash join (t2.grade = s1.id)  (cost=*** rows=***)
        -> Table scan on t2  (cost=*** rows=***)
        -> Hash
            -> Filter: (s1.id > 3)  (cost=*** rows=***)
                -> Table scan on s1  (cost=*** rows=***)

create index idx1 on s1(id);
select s1.id , s1.grade, t2.name  from s1,t2 where s1.id = t2.grade connect by prior s1.id = s1.grade;
id	grade	name
1	-1	test1
2	1	test2
4	2	test4
3	1	test3
2	1	test2
4	2	test4
3	1	test3
4	2	test4
explain format=tree select s1.id , s1.grade, t2.name  from s1,t2 where s1.id = t2.grade connect by prior s1.id = s1.grade;
EXPLAIN
-> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior s1.id) (reverse)  (cost=*** rows=***)
    -> Nested loop inner join  (cost=*** rows=***)
        -> Filter: (t2.grade is not null)  (cost=*** rows=***)
            -> Table scan on t2  (cost=*** rows=***)
        -> Index lookup on s1 using idx1 (id=t2.grade)  (cost=*** rows=***)

explain format=tree select s1.id , s1.grade, t2.name  from s1 join t2 on s1.id = t2.grade connect by prior s1.id = s1.grade;
EXPLAIN
-> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior s1.id) (reverse)  (cost=*** rows=***)
    -> Nested loop inner join  (cost=*** rows=***)
        -> Filter: (t2.grade is not null)  (cost=*** rows=***)
            -> Table scan on t2  (cost=*** rows=***)
        -> Index lookup on s1 using idx1 (id=t2.grade)  (cost=*** rows=***)

select s1.id , s1.grade, t2.name  from s1,t2 where s1.id = t2.grade and s1.id > 3  connect by prior s1.id = s1.grade;
id	grade	name
4	2	test4
4	2	test4
4	2	test4
explain format=tree select s1.id , s1.grade, t2.name  from s1,t2 where s1.id = t2.grade and s1.id > 3  connect by prior s1.id = s1.grade;
EXPLAIN
-> Filter: (s1.id > 3)  (cost=*** rows=***)
    -> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior s1.id) (reverse)  (cost=*** rows=***)
        -> Nested loop inner join  (cost=*** rows=***)
            -> Filter: (t2.grade is not null)  (cost=*** rows=***)
                -> Table scan on t2  (cost=*** rows=***)
            -> Index lookup on s1 using idx1 (id=t2.grade)  (cost=*** rows=***)

select s1.id , s1.grade, t2.name  from s1 join t2 on s1.id = t2.grade and s1.id > 3  connect by prior s1.id = s1.grade;
id	grade	name
4	2	test4
explain format=tree select s1.id , s1.grade, t2.name  from s1 join t2 on s1.id = t2.grade and s1.id > 3  connect by prior s1.id = s1.grade;
EXPLAIN
-> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior s1.id) (reverse)  (cost=*** rows=***)
    -> Inner hash join (t2.grade = s1.id)  (cost=*** rows=***)
        -> Table scan on t2  (cost=*** rows=***)
        -> Hash
            -> Index range scan on s1 using idx1 over (3 < id), with index condition: (s1.id > 3)  (cost=*** rows=***)

SELECT *, connect_by_isleaf , connect_by_iscycle ,level   FROM  student CONNECT BY nocycle 1=1;
ERROR HY000: connect by loop in user data
explain format=tree select * from (select * from s1 connect by prior id = grade) s1;
EXPLAIN
-> Table scan on s1  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior s1.id) (reverse)  (cost=*** rows=***)
            -> Table scan on s1  (cost=*** rows=***)

select id  from student connect by prior id = grade group by id ;
id
1
2
3
4
explain format=tree select id  from student connect by prior id = grade group by id ;
EXPLAIN
-> Group (no aggregates)
    -> Sort: student.id
        -> Stream results  (cost=*** rows=***)
            -> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior student.id) (reverse)  (cost=*** rows=***)
                -> Table scan on student  (cost=*** rows=***)

select  * from (select * from student connect by prior id = grade) a where id = 2;
id	name	grade
2	Paul	1
2	Paul	1
select  * from (select * from student where id > 1) a  connect by prior id = grade;
id	name	grade
2	Paul	1
4	Sarah	2
3	Nancy	1
4	Sarah	2
select * from (select * from (select id, grade from student) t connect by prior id = grade) t2 where id =2;
id	grade
2	1
2	1
explain format=tree select  * from (select * from student connect by prior id = grade) a where id = 2;
EXPLAIN
-> Index lookup on a using <auto_key0> (id=2)  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior student.id) (reverse)  (cost=*** rows=***)
            -> Table scan on student  (cost=*** rows=***)

explain format=tree select  * from (select * from student where id > 1) a  connect by prior id = grade;
EXPLAIN
-> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior student.id) (reverse)  (cost=*** rows=***)
    -> Filter: (student.id > 1)  (cost=*** rows=***)
        -> Index range scan on student using PRIMARY over (1 < id)  (cost=*** rows=***)

explain format=tree select * from (select * from (select id, grade from student) t connect by prior id = grade) t2 where id =2;
EXPLAIN
-> Index lookup on t2 using <auto_key0> (id=2)  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (grade=prior student.id) (reverse)  (cost=*** rows=***)
            -> Table scan on student  (cost=*** rows=***)

drop table student,t2,s1;
CREATE TABLE tb_ct2
AS
SELECT 'a' AS rn, '1,2,3' AS i_name
FROM dual
UNION ALL
SELECT 'b', '4,5,6'
FROM dual;
SELECT rn, i_name
FROM   tb_ct2
CONNECT BY   PRIOR rand() IS NOT NULL AND   PRIOR rn = rn AND  LEVEL <= 3;
rn	i_name
a	1,2,3
a	1,2,3
a	1,2,3
b	4,5,6
b	4,5,6
b	4,5,6
drop  table tb_ct2;
create table t1 (id int , pid int);
insert into t1 values (1,0);
insert into t1 values (2,1);
insert into t1 values (3,1);
insert into t1 values (4,2);
insert into t1 values (5,2);
insert into t1 values (6,5);
insert into t1 values (7,5);
insert into t1 values (1,2);
select *, sys_connect_by_path(id, '->') from t1 connect by nocycle pid = prior id start with id = 2;
id	pid	sys_connect_by_path(id, '->')
2	1	->2
4	2	->2->4
5	2	->2->5
6	5	->2->5->6
7	5	->2->5->7
1	2	->2->1
3	1	->2->1->3
explain format=tree select * from t1 where level < 2 connect by nocycle pid = prior id start with id = 2;
EXPLAIN
-> Filter: (level < 2)  (cost=*** rows=***)
    -> connect by scan:(nocycle)Index lookup on <connect_by_cache> using <auto_key1> (pid=prior t1.id) (reverse) start with: (t1.id = 2)  (cost=*** rows=***)
        -> Table scan on t1  (cost=*** rows=***)

explain format=tree select * from t1 where connect_by_iscycle < 2 connect by nocycle pid = prior id start with id = 2;
EXPLAIN
-> Filter: (connect_by_iscycle < 2)  (cost=*** rows=***)
    -> connect by scan:(nocycle)Index lookup on <connect_by_cache> using <auto_key1> (pid=prior t1.id) (reverse) start with: (t1.id = 2)  (cost=*** rows=***)
        -> Table scan on t1  (cost=*** rows=***)

explain format=tree select * from t1 where connect_by_isleaf != 0 connect by nocycle pid = prior id start with id = 2;
EXPLAIN
-> Filter: (connect_by_isleaf <> 0)  (cost=*** rows=***)
    -> connect by scan:(nocycle)Index lookup on <connect_by_cache> using <auto_key1> (pid=prior t1.id) (reverse) start with: (t1.id = 2)  (cost=*** rows=***)
        -> Table scan on t1  (cost=*** rows=***)

explain format=tree select * from t1 where level < id connect by nocycle pid = prior id start with id = 2;
EXPLAIN
-> Filter: (level < t1.id)  (cost=*** rows=***)
    -> connect by scan:(nocycle)Index lookup on <connect_by_cache> using <auto_key1> (pid=prior t1.id) (reverse) start with: (t1.id = 2)  (cost=*** rows=***)
        -> Table scan on t1  (cost=*** rows=***)

drop table t1;
create table t1(c1 int primary key,c2 int);
insert into t1 values(1,1);
insert into t1 values(2,2);
insert into t1 values(3,3);
insert into t1 values(4,4);
create table t2(c1 int primary key,c2 int);
insert into t2 values(1,1);
insert into t2 values(2,2);
select *
from t1, t2
where (t1.c1=1 or  t2.c1=2)  and t2.c2 >1
connect by nocycle prior t1.c1= t2.c1;
c1	c2	c1	c2
1	1	2	2
3	3	2	2
4	4	2	2
3	3	2	2
4	4	2	2
2	2	2	2
1	1	2	2
3	3	2	2
4	4	2	2
1	1	2	2
3	3	2	2
4	4	2	2
3	3	2	2
4	4	2	2
select *  from t1, t2    connect by nocycle prior t1.c1= t2.c1;
c1	c2	c1	c2
1	1	2	2
2	2	1	1
3	3	2	2
4	4	2	2
3	3	1	1
4	4	1	1
1	1	1	1
2	2	1	1
3	3	2	2
4	4	2	2
3	3	1	1
4	4	1	1
2	2	2	2
1	1	2	2
3	3	1	1
4	4	1	1
3	3	2	2
4	4	2	2
2	2	1	1
1	1	2	2
3	3	1	1
4	4	1	1
3	3	2	2
4	4	2	2
3	3	2	2
3	3	1	1
4	4	2	2
4	4	1	1
select *  from t1, t2   where t1.c1=1  or t2.c2 >1  connect by nocycle prior t1.c1= t2.c1;
c1	c2	c1	c2
1	1	2	2
3	3	2	2
4	4	2	2
1	1	1	1
3	3	2	2
4	4	2	2
2	2	2	2
1	1	2	2
3	3	2	2
4	4	2	2
1	1	2	2
3	3	2	2
4	4	2	2
3	3	2	2
4	4	2	2
drop table t1;
drop table t2;
select rownum from dual connect by rownum <= 10;
rownum
1
2
3
4
5
6
7
8
9
10
CREATE TABLE ne_cmd_schema (
SCHEMA_ID decimal(65,0) NOT NULL,
ELEMENT_ID decimal(65,0) NOT NULL,
PARENT_ELEMENT_ID decimal(65,0) NOT NULL,
ELEMENT_NAME varchar(50) COLLATE utf8mb4_bin NOT NULL,
ELEMENT_CONSTR varchar(10) COLLATE utf8mb4_bin DEFAULT NULL,
TYPE varchar(10) COLLATE utf8mb4_bin DEFAULT NULL,
DATA_TYPE varchar(100) COLLATE utf8mb4_bin DEFAULT NULL ,
DATA_FORMAT varchar(100) COLLATE utf8mb4_bin DEFAULT NULL,
DATA_SOURCE_TYPE varchar(100) COLLATE utf8mb4_bin DEFAULT NULL,
PATH text COLLATE utf8mb4_bin ,
MAPPING_KEY varchar(50) COLLATE utf8mb4_bin DEFAULT NULL ,
IS_MAPPING decimal(65,0) DEFAULT NULL ,
IS_PRIMARY_KEY decimal(65,0) DEFAULT NULL ,
NE_CMD_TEMPLATE_ID decimal(65,0) NOT NULL,
ELEMENT_DESC varchar(100) COLLATE utf8mb4_bin DEFAULT NULL,
DATA_SOURCE varchar(100) COLLATE utf8mb4_bin DEFAULT NULL,
VARIABLE_NAME varchar(50) COLLATE utf8mb4_bin DEFAULT NULL ,
VALUE_NAME varchar(30) COLLATE utf8mb4_bin DEFAULT NULL ,
IS_ENCRYPT varchar(10) COLLATE utf8mb4_bin DEFAULT NULL ,
PRIMARY KEY (SCHEMA_ID)
);
select schema_id,
element_id,
parent_element_id,
element_name,
element_constr,
type,
data_type,
data_format,
data_source_type,
path,
mapping_key,
is_mapping,
is_primary_key,
ne_cmd_template_id,
element_desc,
data_source,
value_name,
is_encrypt,
variable_name
from (select schema_id,
element_id,
parent_element_id,
element_name,
element_constr,
type,
data_type,
data_format,
data_source_type,
path,
mapping_key,
is_mapping,
is_primary_key,
ne_cmd_template_id,
element_desc,
data_source,
value_name,
is_encrypt,
variable_name
from ne_cmd_schema a
where a.NE_CMD_TEMPLATE_ID = '1' ) b CONNECT BY PRIOR b.element_id = b.parent_element_id
START WITH b.parent_element_id = '0';
schema_id	element_id	parent_element_id	element_name	element_constr	type	data_type	data_format	data_source_type	path	mapping_key	is_mapping	is_primary_key	ne_cmd_template_id	element_desc	data_source	value_name	is_encrypt	variable_name
drop table ne_cmd_schema;
select 2 a from dual connect by level <=3;
a
2
2
2
explain select 2 a from dual connect by level <=3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
Warnings:
Note	1003	/* select#1 */ select 2 AS "a" connect by (level <= 3)
explain format=json select 2 a from dual connect by level <=3;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "message": "No tables used"
  }
}
Warnings:
Note	1003	/* select#1 */ select 2 AS "a" connect by (level <= 3)
select a from  (select 2 a from dual connect by level <=3) t1 ;
a
2
2
2
explain select a from  (select 2 a from dual connect by level <=3) t1 ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
2	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
Warnings:
Note	1003	/* select#1 */ select "t1"."a" AS "a" from (/* select#2 */ select 2 AS "a" connect by (level <= 3)) "t1"
explain format=tree select a from  (select 2 a from dual connect by level <=3) t1 ;
EXPLAIN
-> Table scan on t1  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> connect by scan:(level <= 3)  (cost=*** rows=***)
            -> Rows fetched before execution  (cost=*** rows=***)

explain format=json select a from  (select 2 a from dual connect by level <=3) t1 ;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost_info": {
      "query_cost": "2.61"
    },
    "table": {
      "table_name": "t1",
      "access_type": "ALL",
      "rows_examined_per_scan": 1,
      "rows_produced_per_join": 1,
      "filtered": "100.00",
      "cost_info": {
        "read_cost": "2.51",
        "eval_cost": "0.10",
        "prefix_cost": "2.61",
        "data_read_per_join": "16"
      },
      "used_columns": [
        "a"
      ],
      "materialized_from_subquery": {
        "using_temporary_table": true,
        "dependent": false,
        "cacheable": true,
        "query_block": {
          "select_id": 2,
          "message": "No tables used"
        }
      }
    }
  }
}
Warnings:
Note	1003	/* select#1 */ select "t1"."a" AS "a" from (/* select#2 */ select 2 AS "a" connect by (level <= 3)) "t1"
select sum(a) over() from  (select 2 a from dual connect by level <=3) t1 ;
sum(a) over()
6
6
6
explain select sum(a) over() from  (select 2 a from dual connect by level <=3) t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
2	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
Warnings:
Note	3598	To get information about window functions use EXPLAIN FORMAT=JSON
Note	1003	/* select#1 */ select sum("a") OVER ()  AS "sum(a) over()" from (/* select#2 */ select 2 AS "a" connect by (level <= 3)) "t1"
explain format=tree select sum(a) over() from  (select 2 a from dual connect by level <=3) t1;
EXPLAIN
-> Window aggregate with buffering: sum(a) OVER () 
    -> Table scan on t1  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> connect by scan:(level <= 3)  (cost=*** rows=***)
                -> Rows fetched before execution  (cost=*** rows=***)

explain format=json select sum(a) over() from  (select 2 a from dual connect by level <=3) t1;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost_info": {
      "query_cost": "2.61"
    },
    "windowing": {
      "windows": [
        {
          "name": "<unnamed window>",
          "frame_buffer": {
            "using_temporary_table": true,
            "optimized_frame_evaluation": true
          },
          "functions": [
            "sum"
          ]
        }
      ],
      "table": {
        "table_name": "t1",
        "access_type": "ALL",
        "rows_examined_per_scan": 1,
        "rows_produced_per_join": 1,
        "filtered": "100.00",
        "cost_info": {
          "read_cost": "2.51",
          "eval_cost": "0.10",
          "prefix_cost": "2.61",
          "data_read_per_join": "16"
        },
        "used_columns": [
          "a"
        ],
        "materialized_from_subquery": {
          "using_temporary_table": true,
          "dependent": false,
          "cacheable": true,
          "query_block": {
            "select_id": 2,
            "message": "No tables used"
          }
        }
      }
    }
  }
}
Warnings:
Note	1003	/* select#1 */ select sum("a") OVER ()  AS "sum(a) over()" from (/* select#2 */ select 2 AS "a" connect by (level <= 3)) "t1"
select ratio_to_report(6) over() from dual connect by level<=5;
ratio_to_report(6) over()
0.2
0.2
0.2
0.2
0.2
explain select ratio_to_report(6) over() from dual connect by level<=5;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
Warnings:
Note	1003	/* select#1 */ select ratio_to_report(6) OVER ()  AS "ratio_to_report(6) over()" connect by (level <= 5)
explain format=tree select ratio_to_report(6) over() from dual connect by level<=5;
EXPLAIN
-> Window aggregate with buffering: ratio_to_report(6) OVER () 
    -> connect by scan:(level <= 5)  (cost=*** rows=***)
        -> Rows fetched before execution  (cost=*** rows=***)

explain format=json select ratio_to_report(6) over() from dual connect by level<=5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "message": "No tables used"
  }
}
Warnings:
Note	1003	/* select#1 */ select ratio_to_report(6) OVER ()  AS "ratio_to_report(6) over()" connect by (level <= 5)
CREATE TABLE tbl_test
(
ID int,
NAME VARCHAR2(100),
PID NUMBER DEFAULT 0
) partition by hash(id) partitions 15 ;
INSERT INTO tbl_test(ID,NAME,PID) VALUES(1,'10','0');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(2,'11','1');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(3,'20','0');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(4,'12','1');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(5,'121','2');
select id from tbl_test  connect by  not exists (select id from tbl_test ) start with id=5;
id
5
explain format=tree  select id from tbl_test  connect by  not exists (select id from tbl_test ) start with id=5;
EXPLAIN
-> Filter: (tbl_test.ID = 5)  (cost=*** rows=***)
    -> Table scan on tbl_test  (cost=*** rows=***)

select id from tbl_test  connect by  1=2  start with id=5;
id
5
explain format=tree  select id from tbl_test  connect by  1=2  start with id=5;
EXPLAIN
-> Filter: (tbl_test.ID = 5)  (cost=*** rows=***)
    -> Table scan on tbl_test  (cost=*** rows=***)

select id from tbl_test where pid > 0 start with id<5 connect by 1=2;
id
2
4
explain format=tree select id from tbl_test where pid > 0 start with id<5 connect by 1=2;
EXPLAIN
-> Filter: ((tbl_test.PID > 0) and (tbl_test.ID < 5))  (cost=*** rows=***)
    -> Table scan on tbl_test  (cost=*** rows=***)

DROP TABLE IF EXISTS tbl_test;
set sql_mode=oracle;
set timestamp = 1;
select sysdate - (to_number(to_char(sysdate - 1, 'd')) - 1) - (rownum - 1) * 7 as startDate,
sysdate + (7 - to_number(to_char(sysdate - 1, 'd'))) - (rownum - 1) * 7 as endDate,
to_number(to_char(sysdate, 'iw')) - rownum + 1 as weekIndex,level,rownum
from dual
connect by level<= 12;
startDate	endDate	weekIndex	level	rownum
1969-12-29 03:00:01.000000	1970-01-04 03:00:01.000000	1	1	1
1969-12-22 03:00:01.000000	1969-12-28 03:00:01.000000	0	2	2
1969-12-15 03:00:01.000000	1969-12-21 03:00:01.000000	-1	3	3
1969-12-08 03:00:01.000000	1969-12-14 03:00:01.000000	-2	4	4
1969-12-01 03:00:01.000000	1969-12-07 03:00:01.000000	-3	5	5
1969-11-24 03:00:01.000000	1969-11-30 03:00:01.000000	-4	6	6
1969-11-17 03:00:01.000000	1969-11-23 03:00:01.000000	-5	7	7
1969-11-10 03:00:01.000000	1969-11-16 03:00:01.000000	-6	8	8
1969-11-03 03:00:01.000000	1969-11-09 03:00:01.000000	-7	9	9
1969-10-27 03:00:01.000000	1969-11-02 03:00:01.000000	-8	10	10
1969-10-20 03:00:01.000000	1969-10-26 03:00:01.000000	-9	11	11
1969-10-13 03:00:01.000000	1969-10-19 03:00:01.000000	-10	12	12
create table plan1 (
id int PRIMARY key,
name varchar(255)
);
create table plandetail(
id int PRIMARY key,
name varchar(255),
state int,
planId int
);
insert into plan1 values(1,'计划一');
insert into plan1 values(2,'计划二');
insert into plan1 values(3,'计划三');
insert into plandetail values(1,'明细一',0,1);
insert into plandetail values(2,'明细2',1,1);
insert into plandetail values(3,'明细3',1,1);
insert into plandetail values(4,'明细一',0,2);
insert into plandetail values(5,'明细2',0,2);
insert into plandetail values(6,'明细3',1,2);
insert into plandetail values(7,'明细一',1,3);
insert into plandetail values(8,'明细2',1,3);
insert into plandetail values(9,'明细3',1,3);
select t1.name ,LISTAGG(t2.name,',')  WITHIN GROUP (order by t2.planid asc) from plan1 t1
LEFT JOIN plandetail t2 on t1.id = t2.planid
CONNECT BY nocycle prior t1.id = t2.planid  GROUP BY t1.name ;
name	LISTAGG(t2.name,',')  WITHIN GROUP (order by t2.planid asc)
计划一	明细一,明细2,明细3
计划三	明细一,明细2,明细3
计划二	明细一,明细2,明细3
select *
from plan1 t1
LEFT JOIN plandetail t2 on t1.id = t2.planid
CONNECT BY nocycle prior t1.id = t2.planid;
id	name	id	name	state	planId
1	计划一	3	明细3	1	1
1	计划一	2	明细2	1	1
1	计划一	1	明细一	0	1
2	计划二	6	明细3	1	2
2	计划二	5	明细2	0	2
2	计划二	4	明细一	0	2
3	计划三	9	明细3	1	3
3	计划三	8	明细2	1	3
3	计划三	7	明细一	1	3
drop table plan1;
drop table plandetail;
CREATE TABLE tbl_test
(
ID int,
NAME VARCHAR2(100),
PID int DEFAULT 0
);
INSERT INTO tbl_test(ID,NAME,PID) VALUES(1,'10','0');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(2,'11','1');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(3,'20','0');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(4,'12','1');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(5,'121','2');
select id from tbl_test start with id=5 connect by prior pid = id and prior id= pid;
id
5
select id from tbl_test connect by prior pid = id and prior id= pid;
id
1
2
3
4
5
select id,pid from tbl_test connect by prior pid = id and prior id= pid;
id	pid
1	0
2	1
3	0
4	1
5	2
explain format=tree select id,pid from tbl_test connect by prior pid = id and prior id= pid;
EXPLAIN
-> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (id=prior tbl_test.PID, pid=prior tbl_test.ID) (reverse)  (cost=*** rows=***)
    -> Table scan on tbl_test  (cost=*** rows=***)

explain format=tree select pid,id from tbl_test connect by prior pid = id and prior id= pid;
EXPLAIN
-> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (pid=prior tbl_test.ID, id=prior tbl_test.PID) (reverse)  (cost=*** rows=***)
    -> Table scan on tbl_test  (cost=*** rows=***)

drop table tbl_test;
create table t1(c1 int, c2 varchar2(10)) ;
create table t2(c1 int, c2 varchar2(10)) ;
insert into t1 values(1, 'abc');
insert into t1 values(2, 'cde');
insert into t1 values(4, 'egf');
insert into t1 values(5, 'xyz');
insert into t1 values(6, 'aaa');
insert into t1 values(7, 'bbb');
insert into t1 values(8, 'ccc');
insert into t1 values(9, 'ddd');
insert into t1 values(10, 'eee');
insert into t1 values(11, 'fff');
insert into t1 values(23, null);
insert into t1 values(null, null);
insert into t1 values(null, 'xinei');
insert into t1 values(24, '');
insert into t2 values(1, 'fgh');
insert into t2 values(3, 'ijk');
insert into t2 values(3, 'ijk');
insert into t2 values(4, 'lmn');
insert into t2 values(5, 'opq');
insert into t2 values(7, 'rst');
insert into t2 values(9, 'uvw');
insert into t2 values(11, 'xyz');
insert into t2 values(null, 'xinei');
insert into t2 values(null, null);
insert into t2 values(23, '');
insert into t2 values(23, null);
insert into t2 values(24, '');
insert into t2 values(25, '');
select t1.c1,t2.c1+1 from t1,t2 where t1.c1=t2.c1(+) and t2.c2 is not null start with t1.c1(+) connect by prior t1.c1 = t2.c1+1 order by t1.c1;
ERROR HY000: An expression of non-boolean type specified to a check constraint 'start with'.
select t1.c1,t2.c1+1 from t1,t2 where t1.c1=t2.c1(+) and t2.c2 is not null start with t1.c1 connect by prior t1.c1(+) = t2.c1+1 order by t1.c1;
ERROR HY000: An expression of non-boolean type specified to a check constraint 'start with'.
select t1.c1,t2.c1+1 from t1,t2 where t1.c1=t2.c1(+) and t2.c2 is not null start with t1.c1(+)=5 connect by prior t1.c1 = t2.c1+1 order by t1.c1;
c1	t2.c1+1
4	5
5	6
select t1.c1,t2.c1+1 from t1,t2 where t1.c1=t2.c1(+) and t2.c2 is not null connect by prior t1.c1(+) = t2.c1(+)+1 order by t1.c1;
ERROR HY000: OuterJoin: outer join operator (+) not allowed in operand of connect by
DROP TABLE t1;
DROP TABLE t2;
drop table if exists student;
Warnings:
Note	1051	Unknown table 'test.student'
CREATE TABLE student (
id       raw,
name  VARCHAR(10),
grade raw
);
INSERT INTO student VALUES('1', 'John', NULL);
INSERT INTO student VALUES('2', 'Paul', '1');
INSERT INTO student VALUES('3', 'Nancy', '1');
INSERT INTO student VALUES('4', 'Sarah', '3');
select level from student connect by prior id = grade;
level 
1
2
2
3
1
1
2
1
drop table student;
select level,rownum from dual connect by level < 4;
level	rownum
1	1
2	2
3	3
select sys_connect_by_path(rownum, '->') from dual connect by level < 4;
sys_connect_by_path(rownum, '->')
->1
->1->2
->1->2->3
select 1 from dual connect by prior sysdate=sysdate ;
ERROR HY000: connect by loop in user data
select sys_connect_by_path('abc', '->') from dual connect by level < 4;
sys_connect_by_path('abc', '->')
->abc
->abc->abc
->abc->abc->abc
CREATE TABLE student (
id       INT,
name  VARCHAR(10),
grade INT
);
INSERT INTO student VALUES(1, 'John', -1);
INSERT INTO student VALUES(2, 'Paul', 1);
INSERT INTO student VALUES(3, 'Nancy', 1);
INSERT INTO student VALUES(4, 'Sarah', 2);
select id,name,grade ,level , rownum , sys_connect_by_path(rownum,'->')
from student connect by nocycle prior id = grade and rownum < 4;
id	name	grade	level 	rownum	sys_connect_by_path(rownum,'->')
1	John	-1	1	1	->1
2	Paul	1	2	2	->1->2
4	Sarah	2	3	3	->1->2->3
2	Paul	1	1	4	->4
3	Nancy	1	1	5	->5
4	Sarah	2	1	6	->6
select rownum *id +1 ,id, name from student connect by nocycle prior id = grade;
rownum *id +1	id	name
2	1	John
5	2	Paul
13	4	Sarah
13	3	Nancy
11	2	Paul
25	4	Sarah
22	3	Nancy
33	4	Sarah
select rownum *id +1 ,id, name from student start with rownum < 3 connect by nocycle prior id = grade;
rownum *id +1	id	name
2	1	John
5	2	Paul
13	4	Sarah
13	3	Nancy
11	2	Paul
25	4	Sarah
drop table student;
set timestamp =1;
SELECT sysdate - (to_number(to_char(sysdate - 1, 'd')) - 1) - (rownum - 1) * 7 AS startDate , sysdate + (7 - to_number(to_char(sysdate - 1, 'd'))) - (rownum - 1) * 7 AS endDate , level FROM dual CONNECT BY level <= 5;
startDate	endDate	level 
1969-12-29 03:00:01.000000	1970-01-04 03:00:01.000000	1
1969-12-22 03:00:01.000000	1969-12-28 03:00:01.000000	2
1969-12-15 03:00:01.000000	1969-12-21 03:00:01.000000	3
1969-12-08 03:00:01.000000	1969-12-14 03:00:01.000000	4
1969-12-01 03:00:01.000000	1969-12-07 03:00:01.000000	5
select level from dual where level=2 connect by level<=10;
level 
2
select level from dual where level=2 or level=1 connect by level<=10;
level 
1
2
select level from dual where (level=2 or level=1) or (level=8) connect by level<=10;
level 
1
2
8
select level,rownum from dual where rownum < 3 and level=2 connect by level<=10;
level	rownum
2	1
set sql_mode=default;
CREATE TABLE student (
id       INT,
name  VARCHAR(10),
grade INT
);
INSERT INTO student VALUES(1, 'John', 0);
INSERT INTO student VALUES(2, 'Paul', 1);
INSERT INTO student VALUES(3, 'Nancy', 1);
INSERT INTO student VALUES(4, 'Sarah', 3);
create function f1(id int)
returns int
NOT DETERMINISTIC
return id+id;
//
select CONNECT_BY_ROOT f1(id), level, id,name,grade from student connect by prior id=grade;
CONNECT_BY_ROOT f1(id)	level	id	name	grade
2	1	1	John	0
2	2	2	Paul	1
2	2	3	Nancy	1
2	3	4	Sarah	3
4	1	2	Paul	1
6	1	3	Nancy	1
6	2	4	Sarah	3
8	1	4	Sarah	3
select CONNECT_BY_ROOT f1(id),level, id,name,grade from student connect by nocycle prior id = (grade+1);
CONNECT_BY_ROOT f1(id)	level	id	name	grade
2	1	1	John	0
4	1	2	Paul	1
4	2	3	Nancy	1
6	1	3	Nancy	1
8	1	4	Sarah	3
drop function f1;
drop table student;
create table  emp  
(	 empno  int, 
ename  varchar2(10), 
job  varchar2(9), 
mgr  number(4,0), 
hiredate  date, 
sal  number(7,2), 
comm  number(7,2), 
deptno  number(2,0)
);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7369,'smith','clerk',7902,'2017-12-08',800,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7499,'allen','salesman',7698,'2020-02-08',1600,300,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7521,'ward','salesman',7698,'2022-02-08',1250,500,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7566,'jones','manager',7839,'2002-10-01',2975,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7654,'martin','salesman',7698,'2001-02-09',1250,1400,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7698,'blake','manager',7839,'2023-03-08',2850,null,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7782,'clark','manager',7839,'2021-01-18',2450,null,10);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7788,'SCOTT','analyst',7566,'2019-06-07',3000,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7839,'KING','president',null,'2019-07-07',5000,null,10);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7844,'turner','salesman',7698,'2021-04-17',1500,0,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7876,'adams','clerk',7788,'2022-01-01',1100,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7900,'james','clerk',7698,'2018-01-08',950,null,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7902,'ford','analyst',7566,'2017-02-08',3000,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7934,'miller','clerk',7782,'2016-02-08',1300,null,10);
create table t1(
id number,
fname varchar(100),
gfname varchar(100),
fid varchar(100),
gfid varchar(100),
mname varchar(100),
gmname varchar(100),
mid varchar(100),
gmid varchar(100)
);
insert into t1 values (1,'0011','0000','001100','000000','a11','b11','a1100','b1100');
insert into t1 values (2,'0012','0011','001101','000001','a12','a11','a1200','a1100');
insert into t1 values (3,'0013','0011','001102','000002','a13','a11','a1300','a1100');
insert into t1 values (4,'0014','0011','001103','000003','a14','a11','a1400','a1100');
select CONNECT_BY_ROOT sysdate, CONNECT_BY_ISLEAF,deptno,empno,ename,mgr from emp,t1 connect by prior empno=mgr start with empno=7698;
CONNECT_BY_ROOT sysdate	CONNECT_BY_ISLEAF	deptno	empno	ename	mgr
#	0	30	7698	blake	7839
#	1	30	7499	allen	7698
#	1	30	7499	allen	7698
#	1	30	7499	allen	7698
#	1	30	7499	allen	7698
#	1	30	7521	ward	7698
#	1	30	7521	ward	7698
#	1	30	7521	ward	7698
#	1	30	7521	ward	7698
#	1	30	7654	martin	7698
#	1	30	7654	martin	7698
#	1	30	7654	martin	7698
#	1	30	7654	martin	7698
#	1	30	7844	turner	7698
#	1	30	7844	turner	7698
#	1	30	7844	turner	7698
#	1	30	7844	turner	7698
#	1	30	7900	james	7698
#	1	30	7900	james	7698
#	1	30	7900	james	7698
#	1	30	7900	james	7698
#	0	30	7698	blake	7839
#	1	30	7499	allen	7698
#	1	30	7499	allen	7698
#	1	30	7499	allen	7698
#	1	30	7499	allen	7698
#	1	30	7521	ward	7698
#	1	30	7521	ward	7698
#	1	30	7521	ward	7698
#	1	30	7521	ward	7698
#	1	30	7654	martin	7698
#	1	30	7654	martin	7698
#	1	30	7654	martin	7698
#	1	30	7654	martin	7698
#	1	30	7844	turner	7698
#	1	30	7844	turner	7698
#	1	30	7844	turner	7698
#	1	30	7844	turner	7698
#	1	30	7900	james	7698
#	1	30	7900	james	7698
#	1	30	7900	james	7698
#	1	30	7900	james	7698
#	0	30	7698	blake	7839
#	1	30	7499	allen	7698
#	1	30	7499	allen	7698
#	1	30	7499	allen	7698
#	1	30	7499	allen	7698
#	1	30	7521	ward	7698
#	1	30	7521	ward	7698
#	1	30	7521	ward	7698
#	1	30	7521	ward	7698
#	1	30	7654	martin	7698
#	1	30	7654	martin	7698
#	1	30	7654	martin	7698
#	1	30	7654	martin	7698
#	1	30	7844	turner	7698
#	1	30	7844	turner	7698
#	1	30	7844	turner	7698
#	1	30	7844	turner	7698
#	1	30	7900	james	7698
#	1	30	7900	james	7698
#	1	30	7900	james	7698
#	1	30	7900	james	7698
#	0	30	7698	blake	7839
#	1	30	7499	allen	7698
#	1	30	7499	allen	7698
#	1	30	7499	allen	7698
#	1	30	7499	allen	7698
#	1	30	7521	ward	7698
#	1	30	7521	ward	7698
#	1	30	7521	ward	7698
#	1	30	7521	ward	7698
#	1	30	7654	martin	7698
#	1	30	7654	martin	7698
#	1	30	7654	martin	7698
#	1	30	7654	martin	7698
#	1	30	7844	turner	7698
#	1	30	7844	turner	7698
#	1	30	7844	turner	7698
#	1	30	7844	turner	7698
#	1	30	7900	james	7698
#	1	30	7900	james	7698
#	1	30	7900	james	7698
#	1	30	7900	james	7698
drop table t1;
drop table emp;
select 1 from (select 1 from dual) connect by level < 3;
1
1
1
select (select 1 from dual connect by level < 3) from dual;
ERROR 21000: Subquery returns more than 1 row
set sql_mode=default;
select 1 from dual CONNECT BY  prior sysdate= sysdate;
ERROR HY000: connect by loop in user data
CREATE TABLE student (
id       INT primary key,
name  VARCHAR(10),
grade INT
);
INSERT INTO student VALUES(1, 'John', 0);
INSERT INTO student VALUES(2, 'Paul', 1);
INSERT INTO student VALUES(3, 'Nancy', 1);
INSERT INTO student VALUES(4, 'Sarah', 3);
select * from student where id is not null connect by prior id = grade;
id	name	grade
1	John	0
2	Paul	1
3	Nancy	1
4	Sarah	3
2	Paul	1
3	Nancy	1
4	Sarah	3
4	Sarah	3
select avg(id), first_value(grade) over() from student connect by level < 3 group by id,grade;
avg(id)	first_value(grade) over()
1.0000	0
2.0000	0
3.0000	0
4.0000	0
drop table student;
set sql_mode=oracle;
CREATE TABLE t1 (s1 INT, s2 varchar(100),s3 timestamp(3), student_id int, KEY s_id (student_id),PRIMARY KEY (s1));
INSERT INTO t1 VALUES (1,'aa','2021-01-19 03:14:07.123',1);
INSERT INTO t1 VALUES (2,null,'2022-01-19 03:14:07.123',2);
CREATE or replace FUNCTION f1(a INT) RETURN INT
AS BEGIN
RETURN a;
END //
SELECT f1(a=>( select s1+s1 connect by level<1)) as col_f1 from t1;
col_f1
2
4
SELECT f1((select s1+s1 connect by level<1)) as col_f1 from t1;
col_f1
2
4
set sql_mode=default;
drop function f1;
drop table t1;
CREATE TABLE c1(id int , sid int);
INSERT INTO c1 values( 1, 2);
INSERT INTO c1 values( 2, 3);
INSERT INTO c1 values( 3, 4);
CREATE TABLE c2(id int , sid int);
INSERT INTO c2 values( 1, 2);
INSERT INTO c2 values( 2, 3);
INSERT INTO c2 values( 3, 4);
CREATE TABLE c3(id int , sid int);
INSERT INTO c3 values( 1, 2);
INSERT INTO c3 values( 2, 3);
INSERT INTO c3 values( 3, 4);
CREATE TABLE c4(id int , sid int);
INSERT INTO c4 values( 1, 2);
INSERT INTO c4 values( 2, 3);
INSERT INTO c4 values( 3, 4);
select * from c1 join c2 on (c2.id = c1.id ) where c2.sid = c1.sid  connect by level < 2;
id	sid	id	sid
1	2	1	2
2	3	2	3
3	4	3	4
select * from c1 join c2 on (c2.id <> c1.id)+sysdate or c1.id <> 1 where (c2.id <> c1.id)+sysdate  or c1.id <> 1 connect by level < 2;
id	sid	id	sid
3	4	1	2
2	3	1	2
1	2	1	2
3	4	2	3
2	3	2	3
1	2	2	3
3	4	3	4
2	3	3	4
1	2	3	4
explain format=tree 
select * from c1 join c2 on (c2.id <> c1.id)+sysdate or c1.id <> 1 where (c2.id <> c1.id)+sysdate  or c1.id <> 1 connect by level < 2;
EXPLAIN
-> Filter: ((0 <> ((c2.id <> c1.id) + sysdate())) or (c1.id <> 1))  (cost=*** rows=***)
    -> connect by scan:(level < 2)  (cost=*** rows=***)
        -> Filter: ((0 <> ((c2.id <> c1.id) + sysdate())) or (c1.id <> 1))  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on c2  (cost=*** rows=***)
                -> Hash
                    -> Table scan on c1  (cost=*** rows=***)

explain format=tree 
select * from c1 join c2 on (c2.id <> c1.id) or c1.id <> 1 where (c2.id <> c1.id)+sysdate  or c1.id <> 1 connect by level < 2;
EXPLAIN
-> Filter: ((0 <> ((c2.id <> c1.id) + sysdate())) or (c1.id <> 1))  (cost=*** rows=***)
    -> connect by scan:(level < 2)  (cost=*** rows=***)
        -> Filter: ((c2.id <> c1.id) or (c1.id <> 1))  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on c2  (cost=*** rows=***)
                -> Hash
                    -> Table scan on c1  (cost=*** rows=***)

explain format=tree 
select * from c1 join c2 on (c2.id <> c1.id)+sysdate or c1.id <> 1 where (c2.id <> c1.id)  or c1.id <> 1 connect by level < 2;
EXPLAIN
-> Filter: ((c2.id <> c1.id) or (c1.id <> 1))  (cost=*** rows=***)
    -> connect by scan:(level < 2)  (cost=*** rows=***)
        -> Filter: ((0 <> ((c2.id <> c1.id) + sysdate())) or (c1.id <> 1))  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on c2  (cost=*** rows=***)
                -> Hash
                    -> Table scan on c1  (cost=*** rows=***)

explain format=tree select * from c1 join c2 on (c2.id = c1.id ) where c2.sid = c1.sid connect by level < 2;
EXPLAIN
-> Filter: (c2.sid = c1.sid)  (cost=*** rows=***)
    -> connect by scan:(level < 2)  (cost=*** rows=***)
        -> Inner hash join (c2.id = c1.id)  (cost=*** rows=***)
            -> Table scan on c2  (cost=*** rows=***)
            -> Hash
                -> Table scan on c1  (cost=*** rows=***)

SELECT * FROM c2, c1 INNER JOIN c3 ON (c1.id =c3.id ) WHERE c2.id= c3.id AND c1.sid = c2.sid CONNECT BY LEVEL < 2;
id	sid	id	sid	id	sid
1	2	1	2	1	2
2	3	2	3	2	3
3	4	3	4	3	4
explain format=tree SELECT * FROM c2, c1 INNER JOIN c3 ON (c1.id =c3.id ) WHERE c2.id= c3.id AND c1.sid = c2.sid CONNECT BY LEVEL < 2;
EXPLAIN
-> connect by scan:(level < 2)  (cost=*** rows=***)
    -> Inner hash join (c3.id = c2.id)  (cost=*** rows=***)
        -> Table scan on c3  (cost=*** rows=***)
        -> Hash
            -> Inner hash join (c1.sid = c2.sid), (c1.id = c2.id)  (cost=*** rows=***)
                -> Table scan on c1  (cost=*** rows=***)
                -> Hash
                    -> Table scan on c2  (cost=*** rows=***)

SELECT * FROM c2, c1 INNER JOIN c3 ON (c1.id =c3.id ) WHERE c2.id= c3.id AND c1.sid = c2.sid AND c1.id <> 1 CONNECT BY LEVEL < 2;
id	sid	id	sid	id	sid
2	3	2	3	2	3
3	4	3	4	3	4
explain format=tree
SELECT * FROM c2, c1 INNER JOIN c3 ON (c1.id =c3.id ) WHERE c2.id= c3.id AND c1.sid = c2.sid AND c1.id <> 1 CONNECT BY LEVEL < 2;
EXPLAIN
-> Filter: (c1.id <> 1)  (cost=*** rows=***)
    -> connect by scan:(level < 2)  (cost=*** rows=***)
        -> Inner hash join (c3.id = c2.id)  (cost=*** rows=***)
            -> Table scan on c3  (cost=*** rows=***)
            -> Hash
                -> Inner hash join (c1.sid = c2.sid), (c1.id = c2.id)  (cost=*** rows=***)
                    -> Table scan on c1  (cost=*** rows=***)
                    -> Hash
                        -> Table scan on c2  (cost=*** rows=***)

explain format=tree
select * from  c4,c1 inner join c2 ON  c1.id = c2.id   JOIN c3 ON c1.id = c2.id    where c3.sid = c4.sid    CONNECT BY LEVEL < 2 ;
EXPLAIN
-> connect by scan:(level < 2)  (cost=*** rows=***)
    -> Inner hash join (c2.id = c1.id)  (cost=*** rows=***)
        -> Table scan on c2  (cost=*** rows=***)
        -> Hash
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on c1  (cost=*** rows=***)
                -> Hash
                    -> Inner hash join (c3.sid = c4.sid)  (cost=*** rows=***)
                        -> Table scan on c3  (cost=*** rows=***)
                        -> Hash
                            -> Table scan on c4  (cost=*** rows=***)

explain format=tree
select * from c1 inner join c2 ON  c1.id = c2.id   JOIN c3 ON c1.id = c2.id   where c3.sid = c1.sid    CONNECT BY LEVEL < 2 ;
EXPLAIN
-> Filter: (c3.sid = c1.sid)  (cost=*** rows=***)
    -> connect by scan:(level < 2)  (cost=*** rows=***)
        -> Inner hash join (no condition)  (cost=*** rows=***)
            -> Table scan on c3  (cost=*** rows=***)
            -> Hash
                -> Inner hash join (c2.id = c1.id)  (cost=*** rows=***)
                    -> Table scan on c2  (cost=*** rows=***)
                    -> Hash
                        -> Table scan on c1  (cost=*** rows=***)

explain format=tree
select * from c4,c1 inner join (c2, c3) on c1.id = c2.id  where  c3.sid = c1.sid connect by level < 2 ;
EXPLAIN
-> Filter: (c3.sid = c1.sid)  (cost=*** rows=***)
    -> connect by scan:(level < 2)  (cost=*** rows=***)
        -> Inner hash join (no condition)  (cost=*** rows=***)
            -> Table scan on c3  (cost=*** rows=***)
            -> Hash
                -> Inner hash join (c2.id = c1.id)  (cost=*** rows=***)
                    -> Table scan on c2  (cost=*** rows=***)
                    -> Hash
                        -> Inner hash join (no condition)  (cost=*** rows=***)
                            -> Table scan on c1  (cost=*** rows=***)
                            -> Hash
                                -> Table scan on c4  (cost=*** rows=***)

explain format=tree 
select * from c4,c1 inner join ((select 1 as a,2 as b) cc ,c3,c2)  on c1.id = c2.id  where  
c3.sid = c1.sid and cc.a <> c1.id and c4.id = cc.b  connect by level < 2;
EXPLAIN
-> Filter: ((c3.sid = c1.sid) and ('1' <> c1.id))  (cost=*** rows=***)
    -> connect by scan:(level < 2)  (cost=*** rows=***)
        -> Inner hash join (no condition)  (cost=*** rows=***)
            -> Table scan on c3  (cost=*** rows=***)
            -> Hash
                -> Inner hash join (c2.id = c1.id)  (cost=*** rows=***)
                    -> Table scan on c2  (cost=*** rows=***)
                    -> Hash
                        -> Inner hash join (no condition)  (cost=*** rows=***)
                            -> Table scan on c1  (cost=*** rows=***)
                            -> Hash
                                -> Filter: (c4.id = '2')  (cost=*** rows=***)
                                    -> Table scan on c4  (cost=*** rows=***)

drop table c1;
drop table c2;
drop table c3;
drop table c4;
create table t1(ida int, age int, name varchar(10));
insert into t1 values(1, 2, '');
insert into t1 values(NULL, 2, 'a');
insert into t1 values(3, 2, 'b');
create table t3(ida int, age int, name varchar(10));
insert into t3 values(2, 3, 'a');
insert into t3 values(1, 3, 'aa');
insert into t3 values(5, NULL, '');
select * from t1 where t1.name IN (select name from t3) connect by level<3;
ida	age	name
1	2	
1	2	
NULL	2	a
NULL	2	a
1	2	
NULL	2	a
1	2	
NULL	2	a
select * from t1 where t1.name NOT IN (select name from t3) connect by level<3;
ida	age	name
3	2	b
3	2	b
3	2	b
3	2	b
explain format=tree select * from t1 where t1.name IN (select name from t3) connect by level<3;
EXPLAIN
-> Filter: <in_optimizer>(t1.`name`,<exists>(select #2))  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Table scan on t1  (cost=*** rows=***)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=*** rows=***)
            -> Filter: (<cache>(t1.`name`) = t3.`name`)  (cost=*** rows=***)
                -> Table scan on t3  (cost=*** rows=***)

explain format=tree select * from t1 where t1.name NOT IN (select name from t3) connect by level<3;
EXPLAIN
-> Filter: <in_optimizer>(t1.`name`,<exists>(select #2) is false)  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Table scan on t1  (cost=*** rows=***)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=*** rows=***)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t3.`name`), true)  (cost=*** rows=***)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.`name`) = t3.`name`) or (t3.`name` is null)), true)  (cost=*** rows=***)
                    -> Table scan on t3  (cost=*** rows=***)

select * from t1 aa where EXISTS (select name from t3 b WHERE aa.name=b.name) connect by level<3;
ida	age	name
1	2	
1	2	
NULL	2	a
NULL	2	a
1	2	
NULL	2	a
1	2	
NULL	2	a
explain format=tree select * from t1 aa where EXISTS (select name from t3 b WHERE aa.name=b.name) connect by level<3;
EXPLAIN
-> Filter: exists(select #2)  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Table scan on aa  (cost=*** rows=***)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=*** rows=***)
            -> Filter: (aa.`name` = b.`name`)  (cost=*** rows=***)
                -> Table scan on b  (cost=*** rows=***)

Warnings:
Note	1276	Field or reference 'test.aa.name' of SELECT #2 was resolved in SELECT #1
select * from t1 aa where NOT EXISTS (select name from t3 b WHERE aa.name=b.name) connect by level<3;
ida	age	name
3	2	b
3	2	b
3	2	b
3	2	b
explain format=tree select * from t1 aa where EXISTS (select name from t3 b WHERE aa.name=b.name) connect by level<3;
EXPLAIN
-> Filter: exists(select #2)  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Table scan on aa  (cost=*** rows=***)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=*** rows=***)
            -> Filter: (aa.`name` = b.`name`)  (cost=*** rows=***)
                -> Table scan on b  (cost=*** rows=***)

Warnings:
Note	1276	Field or reference 'test.aa.name' of SELECT #2 was resolved in SELECT #1
drop table t1;
drop table t3;
create table t1(ida int, age int, name varchar(10));
insert into t1 values(1, 2, 'K');
insert into t1 values(5, 2, 'a');
insert into t1 values(3, 2, 'b');
create table t2(ida int, age int, name varchar(10));
insert into t2 values(1, 2, 'K');
insert into t2 values(2, 2, 'a');
insert into t2 values(3, 1, 'b');
create table t3(ida int, age int, name varchar(10));
insert into t3 values(2, 3, 'a');
insert into t3 values(1, 3, 'aa');
insert into t3 values(5, 5, 'K');
SELECT * FROM t1 WHERE EXISTS (SELECT 1 FROM t2 WHERE t2.ida=t1.ida CONNECT BY LEVEL<=3);
ida	age	name
1	2	K
3	2	b
SELECT * FROM t1 WHERE EXISTS (SELECT 1 FROM t2 WHERE 1=t1.ida CONNECT BY LEVEL<=3);
ida	age	name
1	2	K
SELECT * FROM t1 WHERE NOT EXISTS (SELECT 1 FROM t2 WHERE t2.ida=t1.ida CONNECT BY LEVEL<=3);
ida	age	name
5	2	a
SELECT * FROM t1 WHERE EXISTS (SELECT ida FROM t3 WHERE t3.ida = t1.ida CONNECT BY LEVEL <=3) CONNECT BY LEVEL<3;
ida	age	name
1	2	K
1	2	K
5	2	a
5	2	a
1	2	K
5	2	a
1	2	K
5	2	a
SELECT * FROM t1 WHERE NOT EXISTS (SELECT ida FROM t3 WHERE t3.ida = t1.ida CONNECT BY LEVEL <=3) CONNECT BY LEVEL<3;
ida	age	name
3	2	b
3	2	b
3	2	b
3	2	b
SELECT * FROM t1 WHERE ida in (SELECT ida FROM t3 WHERE t3.ida = t1.ida CONNECT BY LEVEL <=3) CONNECT BY LEVEL<3;
ida	age	name
1	2	K
1	2	K
5	2	a
5	2	a
1	2	K
5	2	a
1	2	K
5	2	a
SELECT * FROM t1 WHERE ida NOT in (SELECT ida FROM t3 WHERE t3.ida = t1.ida CONNECT BY LEVEL <=3) CONNECT BY LEVEL<3;
ida	age	name
3	2	b
3	2	b
3	2	b
3	2	b
SELECT ida,level FROM t1 WHERE ida IN (SELECT ida FROM t2 WHERE t2.ida=t1.ida) CONNECT BY LEVEL<3;
ida	level
1	1
1	2
3	2
1	2
3	2
3	1
1	2
3	2
SELECT count(*) FROM t1 WHERE ida IN (SELECT ida FROM t2 WHERE t2.ida=t1.ida) CONNECT BY LEVEL<3;
count(*)
8
explain format=tree 
SELECT * FROM t1 WHERE EXISTS (SELECT 1 FROM t2 WHERE t2.ida=t1.ida CONNECT BY LEVEL<=3);
EXPLAIN
-> Filter: exists(select #2)  (cost=*** rows=***)
    -> Table scan on t1  (cost=*** rows=***)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=*** rows=***)
            -> Filter: (t2.ida = t1.ida)  (cost=*** rows=***)
                -> connect by scan:(level <= 3)  (cost=*** rows=***)
                    -> Table scan on t2  (cost=*** rows=***)

Warnings:
Note	1276	Field or reference 'test.t1.ida' of SELECT #2 was resolved in SELECT #1
explain format=tree 
SELECT * FROM t1 WHERE NOT EXISTS (SELECT 1 FROM t2 WHERE t2.ida=t1.ida CONNECT BY LEVEL<=3);
EXPLAIN
-> Filter: exists(select #2) is false  (cost=*** rows=***)
    -> Table scan on t1  (cost=*** rows=***)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=*** rows=***)
            -> Filter: (t2.ida = t1.ida)  (cost=*** rows=***)
                -> connect by scan:(level <= 3)  (cost=*** rows=***)
                    -> Table scan on t2  (cost=*** rows=***)

Warnings:
Note	1276	Field or reference 'test.t1.ida' of SELECT #2 was resolved in SELECT #1
explain format=tree 
SELECT name FROM t1 WHERE EXISTS (SELECT ida FROM t3 WHERE t3.ida = t1.ida CONNECT BY LEVEL <=3) CONNECT BY LEVEL<3;
EXPLAIN
-> Filter: exists(select #2)  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Table scan on t1  (cost=*** rows=***)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=*** rows=***)
            -> Filter: (t3.ida = t1.ida)  (cost=*** rows=***)
                -> connect by scan:(level <= 3)  (cost=*** rows=***)
                    -> Table scan on t3  (cost=*** rows=***)

Warnings:
Note	1276	Field or reference 'test.t1.ida' of SELECT #2 was resolved in SELECT #1
explain format=tree 
SELECT count(*) FROM t1 WHERE ida IN (SELECT ida FROM t2 WHERE t2.ida=t1.ida) CONNECT BY LEVEL<3;
EXPLAIN
-> Aggregate: count(0)  (cost=*** rows=***)
    -> Filter: <in_optimizer>(t1.ida,<exists>(select #2))  (cost=*** rows=***)
        -> connect by scan:(level < 3)  (cost=*** rows=***)
            -> Table scan on t1  (cost=*** rows=***)
        -> Select #2 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=*** rows=***)
                -> Filter: ((t2.ida = t1.ida) and (<cache>(t1.ida) = t2.ida))  (cost=*** rows=***)
                    -> Table scan on t2  (cost=*** rows=***)

Warnings:
Note	1276	Field or reference 'test.t1.ida' of SELECT #2 was resolved in SELECT #1
CREATE TABLE student (
id       INT,
name  VARCHAR(10),
grade INT
);
INSERT INTO student VALUES(1, 'John', NULL);
INSERT INTO student VALUES(2, 'Paul', 1);
INSERT INTO student VALUES(3, 'Nancy', 1);
INSERT INTO student VALUES(4, 'Sarah', 3);
SELECT * FROM t1 WHERE EXISTS (SELECT id FROM student t  CONNECT BY t.id = t1.ida  ) CONNECT BY LEVEL< 2;
ida	age	name
1	2	K
5	2	a
3	2	b
SELECT * FROM t1 WHERE EXISTS (SELECT id FROM student t  CONNECT BY nocycle  prior t.id = t1.ida  ) CONNECT BY LEVEL< 3;
ida	age	name
1	2	K
1	2	K
5	2	a
3	2	b
5	2	a
1	2	K
5	2	a
3	2	b
3	2	b
1	2	K
5	2	a
3	2	b
select * from t1,t3  WHERE t1.IDA in (t3.ida, 1 )  connect by level<3;
ida	age	name	ida	age	name
1	2	K	1	3	aa
1	2	K	1	3	aa
1	2	K	1	3	aa
select * from t1,t3  WHERE 1 in (t3.ida, t1.ida , 3)  connect by level<3;
ida	age	name	ida	age	name
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
1	2	K	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
3	2	b	1	3	aa
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
5	2	a	1	3	aa
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
1	2	K	1	3	aa
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
1	2	K	5	5	K
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
select * from t1,t3  WHERE t1.IDA NOT in (t3.ida, t3.age ,1 )  connect by level<3;
ida	age	name	ida	age	name
5	2	a	2	3	a
5	2	a	2	3	a
5	2	a	1	3	aa
3	2	b	5	5	K
5	2	a	2	3	a
5	2	a	1	3	aa
3	2	b	5	5	K
5	2	a	1	3	aa
5	2	a	2	3	a
5	2	a	1	3	aa
3	2	b	5	5	K
3	2	b	5	5	K
5	2	a	2	3	a
5	2	a	1	3	aa
3	2	b	5	5	K
5	2	a	2	3	a
5	2	a	1	3	aa
3	2	b	5	5	K
select * from t1,t3  WHERE t1.IDA NOT in (t3.ida ,1 , 2)  connect by level<3;
ida	age	name	ida	age	name
3	2	b	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	5	5	K
5	2	a	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	5	5	K
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	5	5	K
3	2	b	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	5	5	K
5	2	a	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	5	5	K
3	2	b	5	5	K
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	5	5	K
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	5	5	K
explain format=tree 
select * from t1,t3  WHERE t1.IDA in (t3.ida, 1 )  connect by level<3;
EXPLAIN
-> Filter: (t1.ida = 1)  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Inner hash join (t3.ida = t1.ida)  (cost=*** rows=***)
            -> Table scan on t3  (cost=*** rows=***)
            -> Hash
                -> Table scan on t1  (cost=*** rows=***)

explain format=tree 
select * from t1,t3  WHERE 1 in (t3.ida, t1.ida , 3)  connect by level<3;
EXPLAIN
-> Filter: (1 in (t3.ida,t1.ida,3))  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Inner hash join (no condition)  (cost=*** rows=***)
            -> Table scan on t3  (cost=*** rows=***)
            -> Hash
                -> Table scan on t1  (cost=*** rows=***)

explain format=tree 
select * from t1,t3  WHERE t1.IDA NOT in (t3.ida, t3.age ,1 )  connect by level<3;
EXPLAIN
-> Filter: (t1.ida <> 1)  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Filter: (t1.ida not in (t3.ida,t3.age))  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on t3  (cost=*** rows=***)
                -> Hash
                    -> Table scan on t1  (cost=*** rows=***)

explain format=tree 
select * from t1,t3  WHERE t1.IDA NOT in (t3.ida ,1 , 2)  connect by level<3;
EXPLAIN
-> Filter: (t1.ida not in (1,2))  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Filter: (t1.ida <> t3.ida)  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on t3  (cost=*** rows=***)
                -> Hash
                    -> Table scan on t1  (cost=*** rows=***)

select * from t1,t3  WHERE t1.IDA in (t3.ida, t3.age ,(select ida from t2 limit 1))  connect by level <3;
ida	age	name	ida	age	name
1	2	K	1	3	aa
1	2	K	1	3	aa
1	2	K	1	3	aa
1	2	K	1	3	aa
1	2	K	1	3	aa
explain format=tree 
select * from t1,t3  WHERE t1.IDA in (t3.ida, t3.age ,(select ida from t2 limit 1))  connect by level <3;
EXPLAIN
-> Filter: (t1.ida = (select #2))  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Filter: (t1.ida in (t3.ida,t3.age))  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on t3  (cost=*** rows=***)
                -> Hash
                    -> Table scan on t1  (cost=*** rows=***)
    -> Select #2 (subquery in condition; run only once)
        -> Limit: 1 row(s)  (cost=*** rows=***)
            -> Table scan on t2  (cost=*** rows=***)

select * from t1,t3  WHERE t1.age in (t3.ida, t1.ida )  connect by level<3;
ida	age	name	ida	age	name
explain format=tree 
select * from t1,t3  WHERE t1.age in (t3.ida, t1.ida )  connect by level<3;
EXPLAIN
-> Filter: (t1.age = t1.ida)  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Inner hash join (t3.ida = t1.age)  (cost=*** rows=***)
            -> Table scan on t3  (cost=*** rows=***)
            -> Hash
                -> Table scan on t1  (cost=*** rows=***)

select * from t1,t3  WHERE 1 in (t3.ida, t1.ida , 3)  connect by level<3;
ida	age	name	ida	age	name
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
1	2	K	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
3	2	b	1	3	aa
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
5	2	a	1	3	aa
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
1	2	K	1	3	aa
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
1	2	K	5	5	K
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
1	2	K	5	5	K
explain format=tree 
select * from t1,t3  WHERE 1 in (t3.ida, t1.ida , 3)  connect by level<3;
EXPLAIN
-> Filter: (1 in (t3.ida,t1.ida,3))  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Inner hash join (no condition)  (cost=*** rows=***)
            -> Table scan on t3  (cost=*** rows=***)
            -> Hash
                -> Table scan on t1  (cost=*** rows=***)

select * from t1,t3  WHERE t1.IDA < any (t3.ida ,1 )  connect by level<3;
ida	age	name	ida	age	name
select * from t1,t3  WHERE t1.IDA < any (t3.ida ,1 , 2)  connect by level<3;
ida	age	name	ida	age	name
1	2	K	2	3	a
1	2	K	2	3	a
1	2	K	5	5	K
1	2	K	2	3	a
1	2	K	5	5	K
1	2	K	5	5	K
1	2	K	2	3	a
1	2	K	5	5	K
select * from t1,t3  WHERE t1.IDA < any (t3.ida, t3.age ,1 )  connect by level<3;
ida	age	name	ida	age	name
explain format=tree
select * from t1,t3  WHERE t1.IDA < any (t3.ida ,1 )  connect by level<3;
EXPLAIN
-> Filter: (t1.ida < 1)  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Filter: (t1.ida < t3.ida)  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on t3  (cost=*** rows=***)
                -> Hash
                    -> Table scan on t1  (cost=*** rows=***)

explain format=tree
select * from t1,t3  WHERE t1.IDA < any (t3.ida ,1 , 2)  connect by level<3;
EXPLAIN
-> Filter: (t1.ida < greatest(1,2))  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Filter: (t1.ida < t3.ida)  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on t3  (cost=*** rows=***)
                -> Hash
                    -> Table scan on t1  (cost=*** rows=***)

explain format=tree
select * from t1,t3  WHERE t1.IDA < any (t3.ida, t3.age ,1 )  connect by level<3;
EXPLAIN
-> Filter: (t1.ida < 1)  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Filter: (t1.ida < greatest(t3.ida,t3.age))  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on t3  (cost=*** rows=***)
                -> Hash
                    -> Table scan on t1  (cost=*** rows=***)

select * from t1,t3  WHERE t1.IDA > any (t3.ida ,1 )  connect by level<3;
ida	age	name	ida	age	name
3	2	b	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
5	2	a	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
5	2	a	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
select * from t1,t3  WHERE t1.IDA > any (t3.ida ,1,2 )  connect by level<3;
ida	age	name	ida	age	name
3	2	b	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
5	2	a	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
5	2	a	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
select * from t1,t3  WHERE t1.IDA > any (t3.ida ,1, t3.age )  connect by level<3;
ida	age	name	ida	age	name
3	2	b	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
5	2	a	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
5	2	a	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
select * from t1,t3  WHERE 10 > any (t3.ida ,1, t1.ida )  connect by level<3;
ida	age	name	ida	age	name
3	2	b	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
5	2	a	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
1	2	K	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
3	2	b	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
5	2	a	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
1	2	K	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
3	2	b	5	5	K
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
5	2	a	5	5	K
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
1	2	K	5	5	K
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
select * from t1,t3  WHERE 1 < any (t3.ida ,1, t1.ida )  connect by level<3;
ida	age	name	ida	age	name
3	2	b	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
5	2	a	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
1	2	K	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
3	2	b	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
5	2	a	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
3	2	b	5	5	K
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
5	2	a	5	5	K
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
1	2	K	5	5	K
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
select * from t1,t3  WHERE t1.IDA > any (t3.ida,t3.age )  connect by level<3;
ida	age	name	ida	age	name
3	2	b	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
5	2	a	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
3	2	b	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
5	2	a	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
select * from t1,t3  WHERE t1.IDA >= any (t1.age ,t3.ida,t3.age )  connect by level<3;
ida	age	name	ida	age	name
3	2	b	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
5	2	a	5	5	K
5	2	a	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
5	2	a	5	5	K
3	2	b	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
5	2	a	5	5	K
5	2	a	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
5	2	a	5	5	K
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
5	2	a	5	5	K
5	2	a	5	5	K
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
5	2	a	5	5	K
select * from t1,t3  WHERE t1.IDA >= any (t1.age ,t1.ida)  connect by level<3;
ida	age	name	ida	age	name
3	2	b	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
5	2	a	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
1	2	K	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
3	2	b	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
5	2	a	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
1	2	K	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
3	2	b	5	5	K
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
5	2	a	5	5	K
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
1	2	K	5	5	K
3	2	b	2	3	a
5	2	a	2	3	a
1	2	K	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
3	2	b	5	5	K
5	2	a	5	5	K
1	2	K	5	5	K
explain format=tree
select * from t1,t3  WHERE t1.IDA >= any (t1.age ,t1.ida)  connect by level<3;
EXPLAIN
-> Filter: (t1.ida >= least(t1.age,t1.ida))  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Inner hash join (no condition)  (cost=*** rows=***)
            -> Table scan on t3  (cost=*** rows=***)
            -> Hash
                -> Table scan on t1  (cost=*** rows=***)

explain format=tree
select * from t1,t3  WHERE t1.IDA >= any (t1.age ,t3.ida,t3.age )  connect by level<3;
EXPLAIN
-> Filter: (t1.ida >= t1.age)  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Filter: (t1.ida >= least(t3.ida,t3.age))  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on t3  (cost=*** rows=***)
                -> Hash
                    -> Table scan on t1  (cost=*** rows=***)

explain format=tree
select * from t1,t3  WHERE t1.IDA > any (t3.ida ,1 )  connect by level<3;
EXPLAIN
-> Filter: (t1.ida > 1)  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Filter: (t1.ida > t3.ida)  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on t3  (cost=*** rows=***)
                -> Hash
                    -> Table scan on t1  (cost=*** rows=***)

explain format=tree
select * from t1,t3  WHERE t1.IDA > any (t3.ida ,1,2 )  connect by level<3;
EXPLAIN
-> Filter: (t1.ida > least(1,2))  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Filter: (t1.ida > t3.ida)  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on t3  (cost=*** rows=***)
                -> Hash
                    -> Table scan on t1  (cost=*** rows=***)

explain format=tree
select * from t1,t3  WHERE t1.IDA > any (t3.ida ,1, t3.age )  connect by level<3;
EXPLAIN
-> Filter: (t1.ida > 1)  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Filter: (t1.ida > least(t3.ida,t3.age))  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on t3  (cost=*** rows=***)
                -> Hash
                    -> Table scan on t1  (cost=*** rows=***)

explain format=tree
select * from t1,t3  WHERE 1 < any (t3.ida ,1, t1.ida )  connect by level<3;
EXPLAIN
-> connect by scan:(level < 3)  (cost=*** rows=***)
    -> Filter: (1 < greatest(t3.ida,1,t1.ida))  (cost=*** rows=***)
        -> Inner hash join (no condition)  (cost=*** rows=***)
            -> Table scan on t3  (cost=*** rows=***)
            -> Hash
                -> Table scan on t1  (cost=*** rows=***)

select * from t1,t3  WHERE t1.IDA = any (t3.ida, t3.age ,1 )  connect by level<3;
ida	age	name	ida	age	name
1	2	K	1	3	aa
1	2	K	1	3	aa
1	2	K	1	3	aa
1	2	K	1	3	aa
1	2	K	1	3	aa
explain format=tree
select * from t1,t3  WHERE t1.IDA = any (t3.ida, t3.age ,1 )  connect by level<3;
EXPLAIN
-> Filter: (t1.ida = 1)  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Filter: (t1.ida in (t3.ida,t3.age))  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on t3  (cost=*** rows=***)
                -> Hash
                    -> Table scan on t1  (cost=*** rows=***)

select * from t1,t3  WHERE t1.IDA between t3.ida  and 10   connect by level<3;
ida	age	name	ida	age	name
3	2	b	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
5	2	a	5	5	K
5	2	a	2	3	a
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
5	2	a	5	5	K
3	2	b	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
5	2	a	5	5	K
5	2	a	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
5	2	a	5	5	K
1	2	K	1	3	aa
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
5	2	a	5	5	K
5	2	a	5	5	K
3	2	b	2	3	a
5	2	a	2	3	a
3	2	b	1	3	aa
5	2	a	1	3	aa
1	2	K	1	3	aa
5	2	a	5	5	K
explain format=tree
select * from t1,t3  WHERE t1.IDA between t3.ida  and 10   connect by level<3;
EXPLAIN
-> Filter: (t1.ida <= 10)  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Filter: (t1.ida >= t3.ida)  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on t3  (cost=*** rows=***)
                -> Hash
                    -> Table scan on t1  (cost=*** rows=***)

select * from t1,t3  WHERE t1.IDA not between t3.ida  and 10   connect by level<3;
ida	age	name	ida	age	name
explain format=tree
select * from t1,t3  WHERE t1.IDA not between t3.ida  and 10   connect by level<3;
EXPLAIN
-> Filter: (t1.ida > 10)  (cost=*** rows=***)
    -> connect by scan:(level < 3)  (cost=*** rows=***)
        -> Filter: (t1.ida < t3.ida)  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on t3  (cost=*** rows=***)
                -> Hash
                    -> Table scan on t1  (cost=*** rows=***)

select * from t1,t3  WHERE 10 between t1.ida  and t3.ida   connect by level<3;
ida	age	name	ida	age	name
explain format=tree
select * from t1,t3  WHERE 10 between t1.ida  and t3.ida   connect by level<3;
EXPLAIN
-> connect by scan:(level < 3)  (cost=*** rows=***)
    -> Filter: (10 between t1.ida and t3.ida)  (cost=*** rows=***)
        -> Inner hash join (no condition)  (cost=*** rows=***)
            -> Table scan on t3  (cost=*** rows=***)
            -> Hash
                -> Table scan on t1  (cost=*** rows=***)

drop table student;
drop table t1;
drop table t2;
drop table t3;
create table  emp  
(	 empno  int, 
ename  varchar2(10), 
job  varchar2(9), 
mgr  number(4,0), 
hiredate varchar2(50),
sal  number(7,2), 
comm  number(7,2), 
deptno  number(2,0)
)  partition by hash(empno) partitions 15 ;
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7369,'smith','clerk',7902,'2017-12-08',800,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7499,'allen','salesman',7698,'2020-02-08',1600,300,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7521,'ward','salesman',7698,'2022-02-08',1250,500,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7566,'jones','manager',7839,'2002-10-01',2975,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7654,'martin','salesman',7698,'2001-02-09',1250,1400,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7698,'blake','manager',7839,'2023-03-08',2850,null,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7782,'clark','manager',7839,'2021-01-18',2450,null,10);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7788,'SCOTT','analyst',7566,'2019-06-07',3000,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7839,'KING','president',null,'2019-07-07',5000,null,10);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7844,'turner','salesman',7698,'2021-04-17',1500,0,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7876,'adams','clerk',7788,'2022-01-01',1100,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7900,'james','clerk',7698,'2018-01-08',950,null,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7902,'ford','analyst',7566,'2017-02-08',3000,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7934,'miller','clerk',7782,'2016-02-08',1300,null,10);
select empno from emp where mgr in (select mgr from emp connect by prior empno=mgr start with empno=7839);
empno
7876
7698
7788
7369
7654
7521
7566
7900
7782
7902
7499
7844
7934
explain format=tree
select empno from emp where mgr in (select mgr from emp connect by prior empno=mgr start with empno=7839);
EXPLAIN
-> Filter: <in_optimizer>(emp.mgr,emp.mgr in (select #2))  (cost=*** rows=***)
    -> Table scan on emp  (cost=*** rows=***)
    -> Select #2 (subquery in condition; run only once)
        -> Filter: ((emp.mgr = `<materialized_subquery>`.mgr))  (cost=*** rows=***)
            -> Limit: 1 row(s)  (cost=*** rows=***)
                -> Index lookup on <materialized_subquery> using <auto_distinct_key> (mgr=emp.mgr)
                    -> Materialize with deduplication  (cost=*** rows=***)
                        -> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (mgr=prior emp.empno) (reverse) start with: (emp.empno = 7839)  (cost=*** rows=***)
                            -> Table scan on emp  (cost=*** rows=***)

select empno,mgr from emp b where mgr in (select mgr from emp connect by nocycle prior empno=b.mgr start with empno=7839);
empno	mgr
7698	7839
7566	7839
7782	7839
explain format=tree
select empno,mgr from emp b where mgr in (select mgr from emp connect by nocycle prior empno=b.mgr start with empno=7839);
EXPLAIN
-> Filter: <in_optimizer>(b.mgr,<exists>(select #2))  (cost=*** rows=***)
    -> Table scan on b  (cost=*** rows=***)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=*** rows=***)
            -> Filter: (<cache>(b.mgr) = emp.mgr)  (cost=*** rows=***)
                -> connect by scan:(nocycle)(prior emp.empno = b.mgr) start with: (emp.empno = 7839)  (cost=*** rows=***)
                    -> Table scan on emp  (cost=*** rows=***)

Warnings:
Note	1276	Field or reference 'test.b.mgr' of SELECT #2 was resolved in SELECT #1
select empno,mgr from emp b where mgr in (select mgr from emp connect by nocycle prior  b.mgr = empno start with empno=7839);
empno	mgr
explain format=tree
select empno,mgr from emp b where mgr in (select mgr from emp connect by nocycle prior  b.mgr = empno start with empno=7839);
EXPLAIN
-> Filter: <in_optimizer>(b.mgr,<exists>(select #2))  (cost=*** rows=***)
    -> Table scan on b  (cost=*** rows=***)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=*** rows=***)
            -> Filter: (<cache>(b.mgr) = emp.mgr)  (cost=*** rows=***)
                -> connect by scan:(nocycle)Index lookup on <connect_by_cache> using <auto_key1> (empno=prior b.mgr) (reverse) start with: (emp.empno = 7839)  (cost=*** rows=***)
                    -> Table scan on emp  (cost=*** rows=***)

Warnings:
Note	1276	Field or reference 'test.b.mgr' of SELECT #2 was resolved in SELECT #1
drop table emp;
CREATE TABLE sales ( department VARCHAR2(50), product VARCHAR2(50), amount NUMBER );
INSERT INTO sales VALUES ('A', 'Product1', 100);
INSERT INTO sales VALUES ('A', 'Product2', 200);
INSERT INTO sales VALUES ('A', 'Product3', 300);
INSERT INTO sales VALUES ('B', 'Product1', 150);
INSERT INTO sales VALUES ('B', 'Product2', 250);
INSERT INTO sales VALUES ('B', 'Product3', 350);
select * FROM  sales  connect by level <3 and rownum =3;
department	product	amount
A	Product1	100.000000000000000000000000000000
A	Product2	200.000000000000000000000000000000
A	Product1	100.000000000000000000000000000000
A	Product3	300.000000000000000000000000000000
B	Product1	150.000000000000000000000000000000
B	Product2	250.000000000000000000000000000000
B	Product3	350.000000000000000000000000000000
explain format=tree
select * FROM  sales  connect by level <3 and rownum =3;
EXPLAIN
-> COUNTER ROWNUM
    -> connect by scan:((level < 3) and (rownum = 3))  (cost=*** rows=***)
        -> Table scan on sales  (cost=*** rows=***)

drop table sales;
SELECT row_number() over() rn, level connect by level<10;
rn	level
1	1
2	2
3	3
4	4
5	5
6	6
7	7
8	8
9	9
SELECT row_number() over(order by level) rn, level connect by level<10;
rn	level
1	1
2	2
3	3
4	4
5	5
6	6
7	7
8	8
9	9
SELECT row_number() over(order by level) rn, level connect by level<10 group by level;
rn	level
1	1
2	2
3	3
4	4
5	5
6	6
7	7
8	8
9	9
SELECT row_number() over() rn, level connect by level<10 group by level;
rn	level
1	1
2	2
3	3
4	4
5	5
6	6
7	7
8	8
9	9
SELECT sum(level) over() rn, level connect by level<10;
rn	level
45	1
45	2
45	3
45	4
45	5
45	6
45	7
45	8
45	9
SELECT sum(level) over(order by level) rn, level connect by level<10;
rn	level
1	1
3	2
6	3
10	4
15	5
21	6
28	7
36	8
45	9
SELECT sum(level) over(order by level) rn, level connect by level<10 group by level;
rn	level
1	1
3	2
6	3
10	4
15	5
21	6
28	7
36	8
45	9
SELECT sum(level) over() rn, level connect by level<10 group by level;
rn	level
45	1
45	2
45	3
45	4
45	5
45	6
45	7
45	8
45	9
SELECT sum(level) over() rn, row_number() over(), level connect by level<10;
rn	row_number() over()	level
45	1	1
45	2	2
45	3	3
45	4	4
45	5	5
45	6	6
45	7	7
45	8	8
45	9	9
SELECT sum(level) over() rn, row_number() over(order by level), level connect by level<10;
rn	row_number() over(order by level)	level
45	1	1
45	2	2
45	3	3
45	4	4
45	5	5
45	6	6
45	7	7
45	8	8
45	9	9
SELECT sum(level) over(order by level) rn, row_number() over(), level connect by level<10;
rn	row_number() over()	level
1	1	1
3	2	2
6	3	3
10	4	4
15	5	5
21	6	6
28	7	7
36	8	8
45	9	9
SELECT sum(level) over(order by level) rn, row_number() over(order by level), level connect by level<10;
rn	row_number() over(order by level)	level
1	1	1
3	2	2
6	3	3
10	4	4
15	5	5
21	6	6
28	7	7
36	8	8
45	9	9
SELECT sum(level) over(order by level) rn,row_number() over(), level connect by level<10 group by level;
rn	row_number() over()	level
1	1	1
3	2	2
6	3	3
10	4	4
15	5	5
21	6	6
28	7	7
36	8	8
45	9	9
SELECT sum(level) over(order by level) rn,row_number() over(order by level), level connect by level<10 group by level;
rn	row_number() over(order by level)	level
1	1	1
3	2	2
6	3	3
10	4	4
15	5	5
21	6	6
28	7	7
36	8	8
45	9	9
SELECT sum(level) over() rn, row_number() over(),  level connect by level<10 group by level;
rn	row_number() over()	level
45	1	1
45	2	2
45	3	3
45	4	4
45	5	5
45	6	6
45	7	7
45	8	8
45	9	9
SELECT sum(level) over() rn, row_number() over(order by level),  level connect by level<10 group by level;
rn	row_number() over(order by level)	level
45	1	1
45	2	2
45	3	3
45	4	4
45	5	5
45	6	6
45	7	7
45	8	8
45	9	9
select rownum from dual connect by level <= 10 group by rownum;
rownum
1
2
3
4
5
6
7
8
9
10
select level from dual connect by level <= 10 group by level;
level
1
2
3
4
5
6
7
8
9
10
select level from dual connect by level <= 10 group by rownum;
level
1
2
3
4
5
6
7
8
9
10
select rownum from dual connect by level <= 10 group by level;
rownum
1
2
3
4
5
6
7
8
9
10
create table t1(c1 int primary key, c2 int, key(c2));
create table t2(c1 int, c2 int, key(c1));
select * from t1 
connect by prior t1.c1 = t1.c2
start with t1.c1 in (select c2 from t2 where c1=0);
c1	c2
explain format=tree 
select * from t1 
connect by prior t1.c1 = t1.c2
start with t1.c1 in (select c2 from t2 where c1=0);
EXPLAIN
-> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (c2=prior t1.c1) (reverse) start with: <in_optimizer>(t1.c1,<exists>(select #2))  (cost=*** rows=***)
    -> Index scan on t1 using c2  (cost=*** rows=***)
    -> Select #2 (subquery in start_with; dependent)
        -> Limit: 1 row(s)  (cost=*** rows=***)
            -> Filter: <is_not_null_test>(t2.c2)  (cost=*** rows=***)
                -> Filter: ((<cache>(t1.c1) = t2.c2) or (t2.c2 is null))  (cost=*** rows=***)
                    -> Index lookup on t2 using c1 (c1=0)  (cost=*** rows=***)

explain analyze
select * from t1
connect by prior t1.c1 = t1.c2
start with t1.c1 in (select c2 from t2 where c1=0);
EXPLAIN
-> connect by scan:Index lookup on <connect_by_cache> using <auto_key1> (c2=prior t1.c1) (reverse) start with: <in_optimizer>(t1.c1,<exists>(select #2))  (cost=*** rows=***) (actual time=N.NNN..N.NNN rows=*** loops=1)
    -> Covering index scan on t1 using c2  (cost=*** rows=***) (actual time=N.NNN..N.NNN rows=*** loops=1)
    -> Select #2 (subquery in start_with; dependent)
        -> Limit: 1 row(s)  (cost=*** rows=***) (never executed)
            -> Filter: <is_not_null_test>(t2.c2)  (cost=*** rows=***) (never executed)
                -> Filter: ((<cache>(t1.c1) = t2.c2) or (t2.c2 is null))  (cost=*** rows=***) (never executed)
                    -> Index lookup on t2 using c1 (c1=0)  (cost=*** rows=***) (never executed)

explain analyze
select 1 from  dual connect by level < 10;
EXPLAIN
-> connect by scan:(level < 10)  (cost=*** rows=***) (actual time=N.NNN..N.NNN rows=*** loops=1)
    -> Rows fetched before execution  (cost=*** rows=***) (actual time=N.NNN..N.NNN rows=*** loops=10)

SET profiling = 1;
Warnings:
Warning	1287	'@@profiling' is deprecated and will be removed in a future release.
select * from t1
connect by prior t1.c1 = t1.c2
start with t1.c1 in (select c2 from t2 where c1=0);
c1	c2
SHOW PROFILES;
Query_ID	Duration	Query
1	###	SHOW WARNINGS
2	###	select * from t1
connect by prior t1.c1 = t1.c2
start with t1.c1 in (select c2 from t2 where c1=0)
Warnings:
Warning	###	'SHOW PROFILES' is deprecated and will be removed in a future release. Please use Performance Schema instead
SHOW PROFILE;
Status	Duration
starting	###
query end	###
closing tables	###
freeing items	###
cleaning up	###
Warnings:
Warning	###	'SHOW PROFILE' is deprecated and will be removed in a future release. Please use Performance Schema instead
SHOW PROFILE FOR QUERY 2;
Status	Duration
starting	###
Executing hook on transaction 	###
starting	###
checking permissions	###
checking permissions	###
Opening tables	###
init	###
System lock	###
optimizing	###
statistics	###
preparing	###
optimizing	###
statistics	###
preparing	###
executing	###
end	###
query end	###
waiting for handler commit	###
closing tables	###
freeing items	###
cleaning up	###
Warnings:
Warning	###	'SHOW PROFILE' is deprecated and will be removed in a future release. Please use Performance Schema instead
SET profiling = 0;
Warnings:
Warning	1287	'@@profiling' is deprecated and will be removed in a future release.
drop table t1;
drop table t2;
