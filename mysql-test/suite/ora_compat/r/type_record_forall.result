set sql_mode="oracle";
#
# error ER_SP_MISMATCH_RECORD_VAR
#
CREATE or replace PROCEDURE p1() as
aa int;
type dr_type is table of aa index by binary_integer;
begin
end;
$$
ERROR HY000: The variable: aa is not record type.
#
# error ER_SP_MISMATCH_USE_OF_RECORD_VAR
#
CREATE or replace PROCEDURE p1() as
type stu_record is record(
id int := 1,
name_d  varchar(20) := 'aaa',
score float := 0.1
);
begin
select stu_record.id;
end;
$$
ERROR HY000: The variable: stu_record is type of record,cat't be used as a variable.
#
# error ER_SP_NOT_EXIST_OF_RECORD_TABLE
#
CREATE or replace PROCEDURE p1() as
type stu_record is record(
id int := 1,
name_d  varchar(20) := 'aaa',
score float := 0.1
);
type dr_type is table of stu_record index by binary_integer;
dr_type_t dr_type;
begin
select dr_type_t(0).id;
end;
$$
call p1();
ERROR HY000: The data of record table variable: dr_type_t does not exist.
DROP PROCEDURE p1;
#
# record type select/set
#
create or replace procedure p1 as
type stu_record is record(
id int := 1,
name_d  varchar(20) := 'aaa',
score float := 0.1
);
type stu_record1 is record(
ii int := 1,
stu_record_val1 stu_record
);
type stu_record2 is record(
jj int := 1,
stu_record_val2 stu_record1
);
stu_record_val stu_record2;
id float := 10;
begin
select stu_record_val.stu_record_val2.stu_record_val1.id,stu_record_val.stu_record_val2.stu_record_val1.name_d,stu_record_val.stu_record_val2.stu_record_val1.score;
stu_record_val.stu_record_val2.stu_record_val1.id := 2;
stu_record_val.stu_record_val2.stu_record_val1.name_d := 'bbb';
select stu_record_val.stu_record_val2.stu_record_val1.id,stu_record_val.stu_record_val2.stu_record_val1.name_d;
stu_record_val.jj := 100;
stu_record_val.stu_record_val2.ii := 200;
id := stu_record_val.stu_record_val2.stu_record_val1.id + stu_record_val.stu_record_val2.stu_record_val1.score;
select id,stu_record_val.jj,stu_record_val.stu_record_val2.ii;
end;
$$
CALL p1;
stu_record_val.stu_record_val2.stu_record_val1.id	stu_record_val.stu_record_val2.stu_record_val1.name_d	stu_record_val.stu_record_val2.stu_record_val1.score
1	aaa	0.1
stu_record_val.stu_record_val2.stu_record_val1.id	stu_record_val.stu_record_val2.stu_record_val1.name_d
2	bbb
id	stu_record_val.jj	stu_record_val.stu_record_val2.ii
2.1	100	200
DROP PROCEDURE p1;
#
# record type select/set
#
create or replace procedure p1 as
type stu_record is record(
id int := 1,
name_d  varchar(20) ,
score float := 0
);
stu_record_val stu_record;
begin
select stu_record.id,stu_record.name_d,stu_record.score;
end;
$$
ERROR HY000: The variable: stu_record is type of record,cat't be used as a variable.
#
# record type select/set
#
create or replace procedure p1 as
type stu_record is record(
id int := 1,
name_d  varchar(20) ,
score float := 0
);
stu_record_val stu_record;
begin
select stu_record_val.id,stu_record_val.name_d,stu_record_val.score;
stu_record_val.id := 100;
stu_record_val.name_d := 'aaa';
stu_record_val.score := 3.22;
select stu_record_val.id,stu_record_val.name_d,stu_record_val.score;
end;
$$
CALL p1;
stu_record_val.id	stu_record_val.name_d	stu_record_val.score
1	NULL	0
stu_record_val.id	stu_record_val.name_d	stu_record_val.score
100	aaa	3.22
DROP PROCEDURE p1;
#
# record type table select/set
#
create or replace procedure p1 as
type stu_record is record(
id int := 1,
name_d  varchar(20) ,
score float := 0
);
type tklist is table of stu_record index by binary_integer;
type stu_record1 is record(
ii int := 1,
stu_record_val1 tklist
);
stu_record_val stu_record1;
begin
select stu_record_val.stu_record_val1(1).id;
stu_record_val.stu_record_val1(1).id := 1;
stu_record_val.stu_record_val1(2).name_d := 'aaa';
stu_record_val.stu_record_val1(0).id := 2;
stu_record_val.stu_record_val1(3).score := 3.22;
select stu_record_val.stu_record_val1(1).id,stu_record_val.stu_record_val1(1).name_d,stu_record_val.stu_record_val1(0).id,stu_record_val.stu_record_val1(3).score;
select stu_record_val.ii;
end;
$$
CALL p1;
ERROR HY000: The data of record table variable: stu_record_val1 does not exist.
DROP PROCEDURE p1;
#
# record type table select/set
#
create or replace procedure p1 as
type stu_record is record(
id int := 1,
name_d  varchar(20) ,
score float := 0
);
type tklist is table of stu_record index by binary_integer;
type stu_record1 is record(
ii int := 1,
stu_record_val1 tklist
);
stu_record_val stu_record1;
id int;
begin
stu_record_val.stu_record_val1(1).id := 1;
stu_record_val.stu_record_val1(2).name_d := 'aaa';
stu_record_val.stu_record_val1(0).id := 2;
stu_record_val.stu_record_val1(3).score := 3.22;
select stu_record_val.stu_record_val1(1).id,stu_record_val.stu_record_val1(2).name_d,stu_record_val.stu_record_val1(0).id,stu_record_val.stu_record_val1(3).score;
id := stu_record_val.stu_record_val1(1).id+stu_record_val.stu_record_val1(3).score;
select id,stu_record_val.ii;
end;
$$
CALL p1;
stu_record_val.stu_record_val1(1).id	stu_record_val.stu_record_val1(2).name_d	stu_record_val.stu_record_val1(0).id	stu_record_val.stu_record_val1(3).score
1	aaa	2	3.22
id	stu_record_val.ii
4	1
DROP PROCEDURE p1;
#
# Parameters in SELECT list + stored function
#
CREATE FUNCTION f1 (a VARCHAR(32)) RETURN VARCHAR(32) no sql
is result VARCHAR(32);
BEGIN
result := CONCAT(a,'y');
RETURN(result);
END;
$$
CREATE PROCEDURE p1(a_a VARCHAR(32)) as
type stu_record is record(
id VARCHAR(32),
name_d  varchar(32)
);
type tklist is table of stu_record index by binary_integer;
stu_record_val tklist;
CURSOR c(p_sel_a VARCHAR(32),p_sel_b VARCHAR(32)) is
SELECT p_sel_a,p_sel_b FROM DUAL;
BEGIN
OPEN c(f1(a_a),f1(a_a));
fetch c bulk collect into stu_record_val limit 3;
select stu_record_val(1).id,stu_record_val(1).name_d;
CLOSE c;
END;
$$
CALL p1('x');
stu_record_val(1).id	stu_record_val(1).name_d
xy	xy
CALL p1(f1(COALESCE(NULL, f1('x'))));
stu_record_val(1).id	stu_record_val(1).name_d
xyyy	xyyy
DROP PROCEDURE p1;
DROP FUNCTION f1;
#
# fetch bulk collect into/forall
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
CREATE TABLE t2 (a INT, b VARCHAR(10));
INSERT INTO t1 VALUES (1,'11');
INSERT INTO t1 VALUES (1,'12');
INSERT INTO t1 VALUES (2,'21');
INSERT INTO t1 VALUES (2,'22');
INSERT INTO t1 VALUES (3,'31');
INSERT INTO t1 VALUES (3,'32');
CREATE PROCEDURE p1(a_a INT) as
type stu_record is record(
id int := 1,
name_d  varchar(20)
);
type tklist is table of stu_record index by binary_integer;
stu_record_val tklist;
CURSOR c(p_a INT) is SELECT a,b FROM t1 WHERE a=p_a;
BEGIN
stu_record_val(1).id := 100;
select stu_record_val(1).id;
OPEN c(a_a);
fetch c bulk collect into stu_record_val limit 3;
forall i in stu_record_val.first .. stu_record_val.last 
insert into t2 values stu_record_val(i);
select stu_record_val(1).id;
CLOSE c;
END;
$$
CALL p1(1);
stu_record_val(1).id
100
stu_record_val(1).id
1
SELECT * FROM t2;
a	b
1	11
1	12
CALL p1(2);
stu_record_val(1).id
100
stu_record_val(1).id
2
SELECT * FROM t2;
a	b
1	11
1	12
2	21
2	22
DROP PROCEDURE p1;
#
# fetch bulk collect into/forall in function
#
CREATE or replace FUNCTION f1() RETURN varchar(20) deterministic is
type stu_record is record(
id int := 1,
name_d  varchar(20)
);
type tklist is table of stu_record index by binary_integer;
stu_record_val tklist;
CURSOR c(p_a INT) is SELECT a,b FROM t1 WHERE a=p_a;
BEGIN
stu_record_val(1).id := 100;
OPEN c(1);
fetch c bulk collect into stu_record_val limit 3;
forall i in stu_record_val.first .. stu_record_val.last 
insert into t2 values stu_record_val(i);
CLOSE c;
return 1;
END;
$$
delete from t2;
select f1();
f1()
1
SELECT * FROM t2;
a	b
1	11
1	12
DROP TABLE t1;
DROP TABLE t2;
DROP function f1;
#
# select bulk collect into/forall
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
CREATE TABLE t2 (a INT, b VARCHAR(10));
INSERT INTO t1 VALUES (1,'11');
INSERT INTO t1 VALUES (1,'12');
INSERT INTO t1 VALUES (2,'21');
INSERT INTO t1 VALUES (2,'22');
INSERT INTO t1 VALUES (3,'31');
INSERT INTO t1 VALUES (3,'32');
CREATE PROCEDURE p1(a_a INT) as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
begin
dr_table(100).a := 100;
select dr_table(100).a;
select * BULK COLLECT into dr_table from t1;
FORALL i IN dr_table.first .. dr_table.last
insert into t2 values dr_table (i);
end;
$$
CALL p1(1);
dr_table(100).a
100
SELECT * FROM t2;
a	b
1	11
1	12
2	21
2	22
3	31
3	32
CALL p1(2);
dr_table(100).a
100
SELECT * FROM t2;
a	b
1	11
1	12
2	21
2	22
3	31
3	32
1	11
1	12
2	21
2	22
3	31
3	32
DROP TABLE t1;
DROP TABLE t2;
DROP PROCEDURE p1;
#
# select bulk collect into/forall
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
CREATE TABLE t2 (a INT, b VARCHAR(10));
INSERT INTO t1 VALUES (1,'11');
CREATE PROCEDURE p1() as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
begin
dr_table(100).a := 100;
dr_table(100).b := 'aaa';
select dr_table(100).a,dr_table(100).b;
FORALL i IN dr_table.first .. dr_table.last
insert into t2 values dr_table (i);
end;
$$
CALL p1();
dr_table(100).a	dr_table(100).b
100	aaa
SELECT * FROM t2;
a	b
100	aaa
truncate table t2;
CALL p1();
dr_table(100).a	dr_table(100).b
100	aaa
SELECT * FROM t2;
a	b
100	aaa
CALL p1();
dr_table(100).a	dr_table(100).b
100	aaa
SELECT * FROM t2;
a	b
100	aaa
100	aaa
DROP TABLE t2;
DROP PROCEDURE p1;
#
# duplicate var
#
CREATE PROCEDURE p1() as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
i varchar(10) := 'aaa';
begin
dr_table(1).a := 100;
dr_table(1).b := 'aaa';
FORALL i IN dr_table.first .. dr_table.last
insert into t1 values dr_table (i);
select i;
end;
$$
CALL p1();
i
aaa
select * from t1;
a	b
1	11
100	aaa
DROP PROCEDURE p1;
#
# duplicate var with error ER_BAD_FIELD_ERROR
#
CREATE PROCEDURE p1() as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
begin
dr_table(1).a := 100;
dr_table(1).b := 'aaa';
FORALL i IN dr_table.first .. dr_table.last
insert into t1 values dr_table (i);
select i;
end;
$$
CALL p1();
ERROR 42S22: Unknown column 'i' in 'field list'
DROP PROCEDURE p1;
DROP TABLE t1;
#
# error ER_UNKNOWN_TABLE
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
INSERT INTO t1 VALUES (1,'11');
CREATE PROCEDURE p1() as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
begin
dr_table(100).a := 100;
dr_table(100).b := 'aaa';
select dr_table(100).a,dr_table(100).b;
FORALL i IN dr_table.first .. dr_table1.last
insert into t2 values dr_table (i);
end;
$$
CALL p1();
dr_table(100).a	dr_table(100).b
100	aaa
ERROR 42S02: Unknown table 'dr_table1' in field list
DROP PROCEDURE p1;
DROP TABLE t1;
#
# select bulk collect into/for loop select
#
CREATE TABLE t1 (col1 INT, col2 VARCHAR(10));
INSERT INTO t1 VALUES (1,'11');
CREATE or replace PROCEDURE p1() as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
begin
select * BULK COLLECT into dr_table from t1;
for i IN dr_table.first .. dr_table.last loop
select dr_table(i).col1,dr_table(i).col2;
end loop;
end;
$$
CALL p1();
dr_table(i).col1	dr_table(i).col2
1	11
DROP TABLE t1;
DROP PROCEDURE p1;
#
# select bulk collect into/for loop update
#
CREATE TABLE t1 (col1 INT, col2 VARCHAR(10));
INSERT INTO t1 VALUES (1,'aaa'),(2,'bbb'),(3,'ccc'),(4,'ddd');
CREATE TABLE t2 (col1 INT, col2 VARCHAR(10));
INSERT INTO t2 VALUES (1,null),(2,null),(3,null),(4,null),(5,null);
CREATE or replace PROCEDURE p1() as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
begin
select * BULK COLLECT into dr_table from t1;
for i IN dr_table.first .. dr_table.last loop
select dr_table(i).col1,dr_table(i).col2;
update t2 set col2=dr_table(i).col2 where col1=dr_table(i).col1;
end loop;
end;
$$
CALL p1();
dr_table(i).col1	dr_table(i).col2
1	aaa
dr_table(i).col1	dr_table(i).col2
2	bbb
dr_table(i).col1	dr_table(i).col2
3	ccc
dr_table(i).col1	dr_table(i).col2
4	ddd
select * from t2;
col1	col2
1	aaa
2	bbb
3	ccc
4	ddd
5	NULL
DROP TABLE t1;
DROP TABLE t2;
DROP PROCEDURE p1;
#
# select bulk collect into/for loop set
#
CREATE TABLE t1 (col1 INT, col2 VARCHAR(10));
INSERT INTO t1 VALUES (1,'aaa'),(2,'bbb'),(3,'ccc'),(4,'ddd');
CREATE or replace PROCEDURE p1() as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
result int := 10;
begin
select * BULK COLLECT into dr_table from t1;
for i IN dr_table.first .. dr_table.last loop
result := result+dr_table(i).col1;
select dr_table(i).col1,dr_table(i).col2,result;
end loop;
end;
$$
CALL p1();
dr_table(i).col1	dr_table(i).col2	result
1	aaa	11
dr_table(i).col1	dr_table(i).col2	result
2	bbb	13
dr_table(i).col1	dr_table(i).col2	result
3	ccc	16
dr_table(i).col1	dr_table(i).col2	result
4	ddd	20
DROP TABLE t1;
DROP PROCEDURE p1;
#
# select bulk collect into/for loop delete
#
CREATE TABLE t1 (col1 INT, col2 VARCHAR(10));
INSERT INTO t1 VALUES (1,'aaa'),(2,'bbb'),(3,'ccc'),(4,'ddd');
CREATE TABLE t2 (col1 INT, col2 VARCHAR(10));
INSERT INTO t2 VALUES (1,null),(2,null),(3,null),(4,null),(5,null);
CREATE or replace PROCEDURE p1() as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
result int := 10;
begin
select * BULK COLLECT into dr_table from t1;
for i IN dr_table.first .. dr_table.last loop
delete from t2 where col1=dr_table(i).col1;
end loop;
end;
$$
CALL p1();
select * from t2;
col1	col2
5	NULL
DROP TABLE t1;
DROP TABLE t2;
DROP PROCEDURE p1;
#
# error ER_WRONG_PARAMCOUNT_TO_TYPE_TABLE
#
CREATE PROCEDURE p1() as
type stu_record is record(
id VARCHAR(32) := 0,
name_d  varchar(32)
);
type tklist is table of stu_record index by binary_integer;
stu_record_val tklist;
BEGIN
select stu_record_val(1+1).id,stu_record_val(1).name_d;
END;
$$
CALL p1();
ERROR HY000: The data of record table variable: stu_record_val does not exist.
DROP PROCEDURE p1;
#
# error ER_ROW_VARIABLE_DOES_NOT_HAVE_FIELD
#
CREATE TABLE t1 (col1 INT, col2 VARCHAR(10));
INSERT INTO t1 VALUES (1,'aaa'),(2,'bbb'),(3,'ccc'),(4,'ddd');
CREATE or replace PROCEDURE p1() as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
begin
dr_table(0).a := 1;
end;
$$
CALL p1();
ERROR HY000: Row variable 'dr_table' does not have a field 'a'
DROP TABLE t1;
DROP PROCEDURE p1;
#
# fetch bulk
#
CREATE TABLE t1 (col1 INT, col2 VARCHAR(10));
INSERT INTO t1 VALUES (1,'aaa'),(2,'bbb'),(3,'ccc'),(4,'ddd'),(5,'eee'),(6,'fff'),(7,'ggg'),(8,'hhh'),(9,'iii');
CREATE or replace PROCEDURE p1() as
CURSOR c1 IS SELECT * FROM t1 where col1<=10;
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
ii int := 0;
begin
open c1;
loop
fetch c1 bulk collect into dr_table limit 5;
EXIT WHEN ii>1;
for i in dr_table.first .. dr_table.last loop
select dr_table(i).col1,dr_table(i).col2;
end loop;
ii:=ii+1;
end loop;
close c1;
end;
$$
CALL p1();
dr_table(i).col1	dr_table(i).col2
1	aaa
dr_table(i).col1	dr_table(i).col2
2	bbb
dr_table(i).col1	dr_table(i).col2
3	ccc
dr_table(i).col1	dr_table(i).col2
4	ddd
dr_table(i).col1	dr_table(i).col2
5	eee
dr_table(i).col1	dr_table(i).col2
6	fff
dr_table(i).col1	dr_table(i).col2
7	ggg
dr_table(i).col1	dr_table(i).col2
8	hhh
dr_table(i).col1	dr_table(i).col2
9	iii
DROP TABLE t1;
DROP PROCEDURE p1;
#
# fetch bulk error ER_WRONG_BATCH_FOR_BULK_INTO
#
show variables like 'select_bulk_into_batch';
Variable_name	Value
select_bulk_into_batch	10000
set @@select_bulk_into_batch=5;
show variables like 'select_bulk_into_batch';
Variable_name	Value
select_bulk_into_batch	5
CREATE TABLE t1 (col1 INT, col2 VARCHAR(10));
INSERT INTO t1 VALUES (1,'aaa'),(2,'bbb'),(3,'ccc'),(4,'ddd'),(5,'eee'),(6,'fff'),(7,'ggg'),(8,'hhh'),(9,'iii');
CREATE or replace PROCEDURE p1() as
CURSOR c1 IS SELECT * FROM t1 where col1<=10;
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
ii int := 0;
begin
open c1;
loop
fetch c1 bulk collect into dr_table limit 6;
EXIT WHEN ii>1;
for i in dr_table.first .. dr_table.last loop
select dr_table(i).col1,dr_table(i).col2;
end loop;
ii:=ii+1;
end loop;
close c1;
end;
$$
CALL p1();
ERROR HY000: Batch size of bulk collect is greater than system variable:select_bulk_into_batch.
DROP TABLE t1;
DROP PROCEDURE p1;
set @@select_bulk_into_batch=10000;
show variables like 'select_bulk_into_batch';
Variable_name	Value
select_bulk_into_batch	10000
#
# error ER_SP_BAD_USE_PROC
#
select xx(1).xx from t1;
ERROR HY000: It is only allowed in a procedure
select xx.xx.xx.xx from t;
ERROR HY000: It is only allowed in a procedure
#
# forall in different table
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
INSERT INTO t1 VALUES (1,'11');
CREATE TABLE t2 (a INT, b VARCHAR(10));
CREATE PROCEDURE p1() as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
dr_table1 dr_type;
begin
dr_table(100).a := 100;
dr_table(100).b := 'aaa';
select dr_table(100).a,dr_table(100).b;
FORALL i IN dr_table1.last .. dr_table.first
insert into t2 values dr_table (i);
select * from t2;
end;
$$
CALL p1();
dr_table(100).a	dr_table(100).b
100	aaa
a	b
DROP PROCEDURE p1;
DROP TABLE t1;
DROP TABLE t2;
#
# error ER_SP_MISMATCH_RECORD_VAR
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
INSERT INTO t1 VALUES (1,'11');
CREATE PROCEDURE p1() as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
dr_table1 dr_type;
begin
dr_table(100).a := 100;
dr_table(100).b := 'aaa';
select dr_table(100).a,dr_table(100).b;
FORALL i IN dr_table.first .. dr_table1.last1
insert into t2 values dr_table (i);
end;
$$
ERROR HY000: The variable: dr_table1 is not record type.
DROP TABLE t1;
#
# error ER_WRONG_PARAMCOUNT_TO_BULK
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
INSERT INTO t1 VALUES (1,'11');
declare
type tt is record( id int );
v tt;
c int;
begin
select * bulk collect into v,c from t1;
end;
$$
ERROR HY000: Incorrect parameter count to bulk into,it only supports 1 parameter.
DROP TABLE t1;
#
# error ER_SP_MISMATCH_RECORD_VAR
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
INSERT INTO t1 VALUES (1,'11');
declare
rec t1.a%type;
BEGIN
rec := 1;
SELECT rec.id;
END;
$$
ERROR HY000: The variable: rec is not record type.
#
# %type
#
declare
rec t1.a%type;
BEGIN
rec := 1;
SELECT rec;
END;
$$
rec
1
DROP TABLE t1;
#
# error ER_SP_MISMATCH_RECORD_VAR
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
INSERT INTO t1 VALUES (1,'11');
declare
rec t1.a%type;
BEGIN
rec := 1;
SELECT rec.id.id;
END;
$$
ERROR HY000: The variable: rec is not record type.
DROP TABLE t1;
#
# error ER_SP_MISMATCH_RECORD_VAR
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
create or replace procedure p1 as
type stu_record is record(
id t1.a%type,
name_d  varchar(20) ,
score float := 0
);
stu_record_val stu_record;
begin
select stu_record_val.id,stu_record_val.name_d,stu_record_val.score;
stu_record_val.id := 100;
stu_record_val.name_d := 'aaa';
stu_record_val.score := 3.22;
select stu_record_val.id,stu_record_val.name_d,stu_record_val.score;
end;
$$
ERROR HY000: The variable: t1 is not record type.
DROP TABLE t1;
#
# error ER_TRUNCATED_WRONG_VALUE
#
CREATE TABLE t1 (id TIMESTAMP);
create or replace procedure p1 as
rec1 t1.id%TYPE;
begin
rec1 :='哈哈';
select rec1;
end;
$$
call p1;
ERROR 22007: Incorrect datetime value: '哈哈' for column 'rec1' at row 1
drop PROCEDURE p1;
DROP TABLE t1;
#
# error ER_DATA_TOO_LONG
#
CREATE TABLE t1 (id varchar(10));
create or replace procedure p1 as
rec1 t1.id%TYPE;
begin
rec1 :='1111111111111111111111111111111111';
select rec1;
end;
$$
call p1;
ERROR 22001: Data too long for column 'rec1' at row 1
drop PROCEDURE p1;
DROP TABLE t1;
#
# error ER_TRUNCATED_WRONG_VALUE
#
CREATE TABLE t1(id int(10),name varchar(10));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
CREATE TABLE t2(id decimal(10,6),name TIMESTAMP);
insert into t1 values(1,'t1_name');
insert into t2 values(1.0001,to_date('03-01-02 8:11:2', 'YY-MM-DD HH24:MI:SS'));
create or replace procedure p1 as
CURSOR cur1 IS SELECT name FROM t1;
CURSOR cur2 IS SELECT name FROM t2;
rec1 cur2%ROWTYPE;
BEGIN
OPEN cur1;
LOOP
fetch cur1 INTO rec1;
EXIT WHEN cur1%NOTFOUND;
select rec1.name;
END LOOP;
close cur1;
end;
$$
call p1;
ERROR 22007: Incorrect datetime value: 't1_name' for column 'name' at row 1
drop PROCEDURE p1;
DROP TABLE t1;
DROP TABLE t2;
#
# %TYPE error ER_NOT_SUPPORTED_YET
#
CREATE TEMPORARY TABLE t1(id int(10),name varchar(10));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
create or replace procedure p1 as
rec1 t1.id%TYPE;
rec2 t1.name%TYPE;
begin
insert into t1 values(1,'t10_name');
end;
$$
call p1;
ERROR 42000: This version of MySQL doesn't yet support 'tmp table used with %type or %rowtype'
drop PROCEDURE p1;
#
# error ER_NOT_SUPPORTED_YET
#
create or replace procedure p1 as
rec1 t1%rowtype;
rec2 t1.name%TYPE;
begin
end;
$$
call p1;
ERROR 42000: This version of MySQL doesn't yet support 'tmp table used with %type or %rowtype'
drop PROCEDURE p1;
drop table t1;
#
# error ER_TRUNCATED_WRONG_VALUE
#
CREATE TABLE t1(id int(10),name varchar(10));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
CREATE TABLE t2(id decimal(10,6),name TIMESTAMP);
insert into t1 values(1,'t1_name');
insert into t2 values(1.0001,to_date('03-01-02 8:11:2', 'YY-MM-DD HH24:MI:SS'));
create or replace procedure p1 as
type dr_type is table of t2%ROWTYPE index by binary_integer;
dr_table dr_type;
BEGIN
select * from t1 bulk collect into dr_table;
end;
$$
call p1;
ERROR 22007: Incorrect datetime value: 't1_name' for column 'name' at row 1
drop PROCEDURE p1;
DROP TABLE t1;
DROP TABLE t2;
#
# error ER_TYPE_CANT_OPEN_TABLE
#
CREATE TABLE t1(id decimal(10,6),name TIMESTAMP);
CREATE VIEW test_view as select * from t1 ;
CREATE or replace PROCEDURE p1() as
rec2 test_view.id%TYPE;
begin
select rec2;
end;
$$
call p1;
ERROR HY000: Resolve table test_view failed,or it doesn't support view table.
drop PROCEDURE p1;
#
# error ER_TYPE_CANT_OPEN_TABLE
#
CREATE or replace PROCEDURE p1() as
rec2 test_view%rowtype;
begin
select rec2.id;
end;
$$
call p1;
ERROR HY000: Resolve table test_view failed,or it doesn't support view table.
drop PROCEDURE p1;
DROP TABLE t1;
DROP VIEW test_view;
#
# error ER_NOT_SUPPORTED_YET
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
CREATE TABLE t2 (a INT, b VARCHAR(10));
INSERT INTO t1 VALUES (1,'11');
INSERT INTO t1 VALUES (1,'12');
INSERT INTO t1 VALUES (2,'21');
INSERT INTO t1 VALUES (2,'22');
INSERT INTO t1 VALUES (3,'31');
INSERT INTO t1 VALUES (3,'32');
CREATE PROCEDURE p1(a_a INT) as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
begin
dr_table(100).a := 100;
select dr_table(100).a;
select * BULK COLLECT into dr_table from t1;
FORALL i IN dr_table.first .. dr_table.last
insert into t2 values (dr_table,i);
end;
$$
ERROR 42000: This version of MySQL doesn't yet support 'this value in forall statment'
drop table t1;
drop table t2;
#
#
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
CREATE TABLE t2 (a INT, b VARCHAR(10));
CREATE PROCEDURE p1() as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
begin
dr_table(100).a := 100;
select dr_table(100).a;
select * BULK COLLECT into dr_table from t1;
FORALL i IN dr_table.first .. dr_table.last
insert into t2 values dr_table(i);
end;
$$
call p1();
dr_table(100).a
100
ERROR 02000: No data - zero rows fetched, selected, or processed
select * from t2;
a	b
INSERT INTO t1 VALUES (null,null);
call p1();
dr_table(100).a
100
select * from t2;
a	b
NULL	NULL
alter table t1 add i int;
call p1();
dr_table(100).a
100
ERROR 21S01: Column count doesn't match value count at row 1
select * from t2;
a	b
NULL	NULL
alter table t2 add i int;
call p1();
dr_table(100).a
100
select * from t2;
a	b	i
NULL	NULL	NULL
NULL	NULL	NULL
alter table t1 drop i;
call p1();
dr_table(100).a
100
ERROR 21S01: Column count doesn't match value count at row 1
select * from t2;
a	b	i
NULL	NULL	NULL
NULL	NULL	NULL
alter table t2 drop i;
call p1();
dr_table(100).a
100
select * from t2;
a	b
NULL	NULL
NULL	NULL
NULL	NULL
drop PROCEDURE p1;
drop table t1;
drop table t2;
#
#
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
CREATE PROCEDURE p1() as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
begin
dr_table(100).a := 100;
select dr_table(100).a;
end;
$$
call p1();
dr_table(100).a
100
truncate table t1;
call p1();
dr_table(100).a
100
drop PROCEDURE p1;
drop table t1;
#
# test of value
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
CREATE TABLE t2 (a INT, b VARCHAR(10));
INSERT INTO t1 VALUES (1,'11');
INSERT INTO t1 VALUES (1,'12');
INSERT INTO t1 VALUES (2,'21');
INSERT INTO t1 VALUES (2,'22');
INSERT INTO t1 VALUES (3,'31');
INSERT INTO t1 VALUES (3,'32');
CREATE PROCEDURE p1(a_a INT) as
type stu_record is record(
id int := 1,
value1  varchar(20)
);
type tklist is table of stu_record index by binary_integer;
value tklist;
CURSOR c(p_a INT) is SELECT a,b FROM t1 WHERE a=p_a;
BEGIN
value(1).id := 100;
OPEN c(a_a);
fetch c bulk collect into value limit 3;
forall i in value.first .. value.last 
insert into t2 values value(i);
CLOSE c;
END;
$$
CALL p1(1);
SELECT * FROM t2;
a	b
1	11
1	12
CALL p1(2);
SELECT * FROM t2;
a	b
1	11
1	12
2	21
2	22
DROP TABLE t1;
DROP TABLE t2;
DROP PROCEDURE p1;
#
# test of value
#
CREATE or replace PROCEDURE value() as
value int;
begin
value := 1;
select value;
end;
$$
call value;
value
1
drop PROCEDURE value;
#
# test of text
#
declare
type stu_record is record(
my_a text:=nullptr
);
begin
end;
$$
ERROR 42S22: Unknown column 'nullptr' in 'field list'
#
# test of clob
#
declare
type stu_record is record(
my_a clob:=null
);
begin
end;
$$
#
# test of blob
#
declare
type stu_record is record(
my_a blob:=''
 );
begin
end;
$$
#
# test of default value
#
CREATE or replace PROCEDURE p1() as
type stu_record is record(
id int := 1,
value1  varchar(20) :='aaa',
value2 varchar(20) :='bbb'
  );
type tklist is table of stu_record index by binary_integer;
value1 tklist;
BEGIN
value1(1).id := 100;
select value1(1).id , value1(1).value1,value1(1).value2;
value1(2).value2 := 'after';
select value1(2).id , value1(2).value1,value1(2).value2;
value1(3).value1 := 'after1';
select value1(3).id , value1(3).value1,value1(3).value2;
end;
$$
call p1;
value1(1).id	value1(1).value1	value1(1).value2
100	aaa	bbb
value1(2).id	value1(2).value1	value1(2).value2
1	aaa	after
value1(3).id	value1(3).value1	value1(3).value2
1	after1	bbb
drop PROCEDURE p1;
#
# test of default value
#
CREATE or replace PROCEDURE p1() as
type stu_record is record(
num int := 1,
name1  varchar(20) :='aaa'
  );
type stu_record1 is record(
id int := 2,
value1  stu_record
);
value2 stu_record1;
value3 stu_record1;
BEGIN
select value2.id , value2.value1.num,value2.value1.name1;
select value3.id , value3.value1.num,value3.value1.name1;
end;
$$
call p1;
value2.id	value2.value1.num	value2.value1.name1
2	1	aaa
value3.id	value3.value1.num	value3.value1.name1
2	1	aaa
drop PROCEDURE p1;
#
# test of table().table()
#
CREATE or replace PROCEDURE p1() as
TYPE rec1 IS RECORD (
col1  varchar(30) := 'col1',
col2   varchar(30) := 'col2',
col3   varchar(30) := 'col3'
  ); 
TYPE t_rec1 IS TABLE OF rec1 index by binary_integer; 
TYPE rec2 IS RECORD (
v_t_rec1  t_rec1,  
col4 varchar(30) := 'col4'
  );
TYPE t_rec2 IS TABLE OF rec2 index by binary_integer; 
TYPE rec3 IS RECORD (
v_t_rec2  t_rec2,  
col5 varchar(30) := 'col5'
  );
TYPE t_rec3 IS TABLE OF rec3 index by binary_integer; 
v_t_rec3 rec3;
BEGIN
v_t_rec3.col5 := 'abc';
v_t_rec3.v_t_rec2(0).v_t_rec1(0).col1 :='abc';
select v_t_rec3.v_t_rec2(0).col4,v_t_rec3.col5;
v_t_rec3.v_t_rec2(0).v_t_rec1(1).col2 :='123qwe';
v_t_rec3.v_t_rec2(1).v_t_rec1(0).col2 :='qqqq';
select v_t_rec3.v_t_rec2(0).v_t_rec1(0).col1,v_t_rec3.v_t_rec2(0).v_t_rec1(0).col2,
v_t_rec3.v_t_rec2(0).v_t_rec1(0).col3 ;
select v_t_rec3.v_t_rec2(1).v_t_rec1(0).col1,v_t_rec3.v_t_rec2(1).v_t_rec1(0).col2,
v_t_rec3.v_t_rec2(1).v_t_rec1(0).col3 ;
select v_t_rec3.v_t_rec2(0).v_t_rec1(1).col1,v_t_rec3.v_t_rec2(0).v_t_rec1(1).col2,
v_t_rec3.v_t_rec2(0).v_t_rec1(1).col3 ;
END;
$$
call p1;
v_t_rec3.v_t_rec2(0).col4	v_t_rec3.col5
col4	abc
v_t_rec3.v_t_rec2(0).v_t_rec1(0).col1	v_t_rec3.v_t_rec2(0).v_t_rec1(0).col2	v_t_rec3.v_t_rec2(0).v_t_rec1(0).col3
abc	col2	col3
v_t_rec3.v_t_rec2(1).v_t_rec1(0).col1	v_t_rec3.v_t_rec2(1).v_t_rec1(0).col2	v_t_rec3.v_t_rec2(1).v_t_rec1(0).col3
col1	qqqq	col3
v_t_rec3.v_t_rec2(0).v_t_rec1(1).col1	v_t_rec3.v_t_rec2(0).v_t_rec1(1).col2	v_t_rec3.v_t_rec2(0).v_t_rec1(1).col3
col1	123qwe	col3
drop PROCEDURE p1;
#
# test of table().table.col
#
CREATE or replace PROCEDURE p1() as
TYPE rec1 IS RECORD (
col1  varchar(30) := 'col1',
col2   varchar(30) := 'col2',
col3   varchar(30) := 'col3'
  ); 
TYPE rec2 IS RECORD (
v_t_rec1  rec1,  
col4 varchar(30) := 'col4'
  );
TYPE t_rec2 IS TABLE OF rec1 index by binary_integer; 
TYPE rec3 IS RECORD (
v_t_rec2  t_rec2,  
col5 varchar(30) := 'col5'
  );
v_t_rec3 rec3;
BEGIN
v_t_rec3.col5 := 'abc';
select v_t_rec3.col5;
v_t_rec3.v_t_rec2(0).col1 :='abc';
select v_t_rec3.v_t_rec2(0).col1,v_t_rec3.v_t_rec2(0).col2,
v_t_rec3.v_t_rec2(0).col3 ;
v_t_rec3.v_t_rec2(1).col2 :='qqqq';
select v_t_rec3.v_t_rec2(1).col1,v_t_rec3.v_t_rec2(1).col2,
v_t_rec3.v_t_rec2(1).col3 ;
select v_t_rec3.v_t_rec2(0).col1,v_t_rec3.v_t_rec2(0).col2,
v_t_rec3.v_t_rec2(0).col3 ;
END;
$$
call p1;
v_t_rec3.col5
abc
v_t_rec3.v_t_rec2(0).col1	v_t_rec3.v_t_rec2(0).col2	v_t_rec3.v_t_rec2(0).col3
abc	col2	col3
v_t_rec3.v_t_rec2(1).col1	v_t_rec3.v_t_rec2(1).col2	v_t_rec3.v_t_rec2(1).col3
col1	qqqq	col3
v_t_rec3.v_t_rec2(0).col1	v_t_rec3.v_t_rec2(0).col2	v_t_rec3.v_t_rec2(0).col3
abc	col2	col3
drop PROCEDURE p1;
#
# test of %rowtype and record
#
CREATE TABLE employees (EMPLOYEE_ID NUMBER(6,0), FIRST_NAME VARCHAR2(20), LAST_NAME VARCHAR2(25), EMAIL VARCHAR2(25), PHONE_NUMBER VARCHAR2(20), HIRE_DATE DATE, JOB_ID VARCHAR2(10), SALARY NUMBER(8,2), COMMISSION_PCT NUMBER(2,2), MANAGER_ID NUMBER(6,0), DEPARTMENT_ID NUMBER(4,0));
Insert into employees (EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID) values (145,'John','Russell','JRUSSEL','011.44.1344.429268','2020-3-1','SA_MAN',14000,0.4,100,80);
Insert into employees (EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID) values (146,'Karen','Partners','KPARTNER','011.44.1344.467268','2020-3-1','SA_MAN',13500,0.3,100,80);
CREATE or replace PROCEDURE p1() as
type table_type is table of employees%ROWTYPE index by binary_integer;
TYPE contact IS RECORD (
v_contact table_type,
phone varchar(30) := '088.88.1888.888888'
  );
friend contact;
BEGIN
friend.v_contact(0).first_name := 'John';
friend.v_contact(100).last_name := 'Smith';
friend.phone := '1-650-555-1234';
SELECT friend.v_contact(0).first_name;
select friend.v_contact(100).last_name;
select friend.phone as a;
END;
$$
call p1;
friend.v_contact(0).first_name
John
friend.v_contact(100).last_name
Smith
a
1-650-555-1234
drop PROCEDURE p1;
drop table employees;
#
# test of default value
#
create or replace procedure p1 as
name0  varchar(20) := '00000';
type stu_record is record(
name1  varchar(20) :='10000',
name2  varchar(20) :=name0
);
type tklist is table of stu_record index by binary_integer;
type stu_record1 is record(
ii int := 1,
stu_record_val1 tklist
);
stu_record_val stu_record1;
f blob;
begin
stu_record_val.stu_record_val1(1).name1 := '33333';
select stu_record_val.stu_record_val1(1).name1,stu_record_val.stu_record_val1(1).name2;
end;
$$
call p1;
stu_record_val.stu_record_val1(1).name1	stu_record_val.stu_record_val1(1).name2
33333	00000
drop PROCEDURE p1;
#
# test of error ER_SP_NOT_EXIST_OF_RECORD_TABLE
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
INSERT INTO t1 VALUES (1,'11');
INSERT INTO t1 VALUES (1,'12');
INSERT INTO t1 VALUES (2,'21');
INSERT INTO t1 VALUES (2,'22');
INSERT INTO t1 VALUES (3,'31');
INSERT INTO t1 VALUES (3,'32');
CREATE PROCEDURE p1() as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
begin
select * BULK COLLECT into dr_table from t1;
for i IN 1 .. 10 loop
select dr_table(i).a,dr_table(i).b;
end loop;
END;
$$
call p1();
dr_table(i).a	dr_table(i).b
1	11
dr_table(i).a	dr_table(i).b
1	12
dr_table(i).a	dr_table(i).b
2	21
dr_table(i).a	dr_table(i).b
2	22
dr_table(i).a	dr_table(i).b
3	31
dr_table(i).a	dr_table(i).b
3	32
ERROR HY000: The data of record table variable: dr_table does not exist.
drop PROCEDURE p1;
#
# test of error ER_SP_MISMATCH_RECORD_TABLE_VAR
#
CREATE PROCEDURE p1(a_a INT) as
type stu_record is record(
id int := 1,
name_d  varchar(20)
);
stu_record_val stu_record;
CURSOR c(p_a INT) is SELECT a,b FROM t1 WHERE a=p_a;
BEGIN
OPEN c(a_a);
fetch c bulk collect into stu_record_val limit 3;
CLOSE c;
END;
$$
ERROR HY000: The variable: stu_record_val is not record table type.
DROP TABLE t1;
#
# test of a.b.c(+)
#
select a.b.c(+);
ERROR 42S02: Unknown table 'a.b' in field list
#
# test of %type
#
create or replace procedure p1 as
name0  varchar(20) := '00000';
type stu_record is record(
name1  varchar(20) :='10000',
name2  name0%type := 'asdf'
);
stu_record_val stu_record;
begin
end;
$$
ERROR HY000: The variable: name0 is not record type.
#
# test of default value of function
#
create or replace procedure p1 as
col int :=10;
TYPE rec2 IS RECORD (
v_t_rec1  int := col=3
);
rec rec2;
BEGIN
select rec.v_t_rec1;
end;
$$
call p1;
rec.v_t_rec1
0
drop procedure p1;
#
# test of record used in function
#
set global log_bin_trust_function_creators=1;
CREATE or replace FUNCTION f1() RETURN varchar(20) deterministic is
name0  varchar(20) := '00000';
type stu_record is record(
name1  varchar(20) :='10000',
name2  varchar(20) :=name0
);
type tklist is table of stu_record index by binary_integer;
type stu_record1 is record(
ii int := 1,
stu_record_val1 tklist
);
stu_record_val stu_record1;
BEGIN
stu_record_val.stu_record_val1(1).name1 := '33333';
return stu_record_val.stu_record_val1(1).name1;
end;
$$
select f1();
f1()
33333
drop function f1;
#
# test of error ER_SP_MISMATCH_RECORD_TABLE_VAR
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
CREATE or replace PROCEDURE p1() as
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
type stu_record is record(
name1  varchar(20) :='10000',
b int :=dr_table
);
type tklist is table of stu_record index by binary_integer;
type stu_record1 is record(
ii int := 1,
stu_record_val1 tklist
);
stu_record_val stu_record1;
begin
end;
$$
call p1;
ERROR HY000: inconsistent datatypes: udt type and non udt type
drop procedure p1;
#
# test of error ER_SP_MISMATCH_RECORD_TABLE_VAR
#
CREATE or replace PROCEDURE p1() as
type stu_record1 is record(
ii int := 1,
str varchar(10)
);
type stu_record is record(
name1  varchar(20) :='10000',
b int :=stu_record1
);
stu_record_table stu_record;
begin
end;
$$
call p1;
ERROR HY000: inconsistent datatypes: udt type and non udt type
drop procedure p1;
DROP TABLE t1;
#
# test of ER_NO_SUCH_TABLE
#
CREATE or replace PROCEDURE p1() as
type stu_record1 is record(
ii int := 1,
str varchar(10)
);
type stu_record is record(
name1  varchar(20) :='10000',
b int :=1
);
stu_record_table stu_record%rowtype;
begin
end;
$$
call p1;
ERROR 42S02: Table 'test.stu_record' doesn't exist
drop procedure p1;
#
# test of error ER_UDT_INCONS_DATATYPES
#
CREATE or replace PROCEDURE p1() as
type stu_record is record(
name1  varchar(10) :='10000',
b int :=11
);
type tklist is table of stu_record index by binary_integer;
type stu_record1 is record(
ii int := 1,
stu_record_val1 tklist
);
stu_record_val stu_record1;
result int := 1;
begin
stu_record_val.stu_record_val1 := result;
end;
$$
call p1;
ERROR HY000: inconsistent datatypes: udt type and non udt type
drop procedure p1;
#
# test of error ER_UDT_INCONS_DATATYPES
#
CREATE or replace PROCEDURE p1() as
type stu_record is record(
name1  varchar(10) :='10000',
b int :=11
);
type tklist is table of stu_record index by binary_integer;
type stu_record1 is record(
ii int := 1,
stu_record_val1 stu_record
);
stu_record_val stu_record1;
result int := 1;
begin
stu_record_val.stu_record_val1 := result;
end;
$$
call p1;
ERROR HY000: inconsistent datatypes: udt type and non udt type
drop procedure p1;
#
# test of set record table
#
CREATE or replace PROCEDURE p1() as
type stu_record is record(
name1  varchar(10) :='10000',
b int :=11
);
type tklist is table of stu_record index by binary_integer;
type stu_record1 is record(
stu_record_val1 tklist,
stu_record_val2 tklist
);
stu_record_val stu_record1;
begin
stu_record_val.stu_record_val1(0).name1 := 'aaa1';
stu_record_val.stu_record_val1(1).name1 := 'aaa2';
stu_record_val.stu_record_val2(0).name1 := 'bbb1';
stu_record_val.stu_record_val2(1).name1 := 'bbb2';
select stu_record_val.stu_record_val2(0).name1,stu_record_val.stu_record_val2(1).name1;
stu_record_val.stu_record_val2 := stu_record_val.stu_record_val1;
select stu_record_val.stu_record_val2(0).name1,stu_record_val.stu_record_val2(1).name1;
end;
$$
call p1;
stu_record_val.stu_record_val2(0).name1	stu_record_val.stu_record_val2(1).name1
bbb1	bbb2
stu_record_val.stu_record_val2(0).name1	stu_record_val.stu_record_val2(1).name1
aaa1	aaa2
drop procedure p1;
#
# test of set record
#
CREATE or replace PROCEDURE p1() as
type stu_record is record(
name1  varchar(10) :='10000',
b int :=11
);
type tklist is table of stu_record index by binary_integer;
type stu_record1 is record(
stu_record_val1 tklist,
stu_record_val2 tklist
);
stu_record_val stu_record1;
stu_record_val1 stu_record1;
begin
stu_record_val.stu_record_val1(0).name1 := 'aaa1';
stu_record_val.stu_record_val1(1).name1 := 'aaa2';
stu_record_val.stu_record_val2(0).name1 := 'bbb1';
stu_record_val.stu_record_val2(1).name1 := 'bbb2';
stu_record_val1.stu_record_val1(0).name1 := 'ccc1';
stu_record_val1.stu_record_val1(1).name1 := 'ccc2';
stu_record_val1.stu_record_val2(0).name1 := 'ddd1';
stu_record_val1.stu_record_val2(1).name1 := 'ddd2';
select stu_record_val.stu_record_val1(0).name1,stu_record_val.stu_record_val1(1).name1,
stu_record_val.stu_record_val2(0).name1,stu_record_val.stu_record_val2(1).name1;
stu_record_val := stu_record_val1;
select stu_record_val.stu_record_val1(0).name1,stu_record_val.stu_record_val1(1).name1,
stu_record_val.stu_record_val2(0).name1,stu_record_val.stu_record_val2(1).name1;
end;
$$
call p1;
stu_record_val.stu_record_val1(0).name1	stu_record_val.stu_record_val1(1).name1	stu_record_val.stu_record_val2(0).name1	stu_record_val.stu_record_val2(1).name1
aaa1	aaa2	bbb1	bbb2
stu_record_val.stu_record_val1(0).name1	stu_record_val.stu_record_val1(1).name1	stu_record_val.stu_record_val2(0).name1	stu_record_val.stu_record_val2(1).name1
ccc1	ccc2	ddd1	ddd2
drop procedure p1;
#
# test of set record
#
CREATE or replace PROCEDURE p1() as
type stu_record is record(
name1  varchar(10) :='10000',
b int :=11
);
stu_record_def stu_record;
type tklist is table of stu_record index by binary_integer;
type stu_record1 is record(
stu_record_val1 tklist,
stu_record_val2 tklist
);
stu_record_val stu_record1;
stu_record_val1 stu_record1;
begin
stu_record_val.stu_record_val1(0).name1 := 'aaa1';
stu_record_val.stu_record_val1(1).name1 := 'aaa2';
stu_record_val.stu_record_val2(0).name1 := 'bbb1';
stu_record_val.stu_record_val2(1).name1 := 'bbb2';
stu_record_val1.stu_record_val1(0).name1 := 'ccc1';
stu_record_val1.stu_record_val1(1).name1 := 'ccc2';
stu_record_val1.stu_record_val2(0).name1 := 'ddd1';
stu_record_val1.stu_record_val2(1).name1 := 'ddd2';
select stu_record_val.stu_record_val1(0).name1,stu_record_val.stu_record_val1(1).name1,
stu_record_val.stu_record_val2(0).name1,stu_record_val.stu_record_val2(1).name1;
stu_record_val.stu_record_val1 := stu_record_def;
end;
$$
call p1;
stu_record_val.stu_record_val1(0).name1	stu_record_val.stu_record_val1(1).name1	stu_record_val.stu_record_val2(0).name1	stu_record_val.stu_record_val2(1).name1
aaa1	aaa2	bbb1	bbb2
ERROR HY000: inconsistent datatypes: expected 'test'.'tklist' got 'test'.'stu_record'
drop procedure p1;
#
# test of exception NO_DATA_FOUND
#
CREATE or replace PROCEDURE p1() as
type record1 is record(
id int := 1
);
TYPE table_type1 IS TABLE OF record1  index by binary_integer;  
value1 table_type1;
id int;
begin
select value1(2).id INTO id from dual;
exception
WHEN NO_DATA_FOUND THEN
select 'the data does not exist' as result;
end;
$$
call p1;
result
the data does not exist
drop procedure p1;
#
# test of empty parameter or more than one parameter with table type 
#
CREATE or replace PROCEDURE p1() as
type record1 is record(
id int := 1
);
TYPE table_type1 IS TABLE OF record1  index by binary_integer;  
value1 table_type1;
begin
select value1().id;
end;
$$
ERROR 42000: This version of MySQL doesn't yet support 'empty parameter or more than one parameter with table type'
#
# test of empty parameter or more than one parameter with table type 
#
CREATE or replace PROCEDURE p1() as
type record1 is record(
id int := 1
);
TYPE table_type1 IS TABLE OF record1  index by binary_integer;  
value1 table_type1;
begin
select value1(1,2).id;
end;
$$
ERROR 42000: This version of MySQL doesn't yet support 'empty parameter or more than one parameter with table type'
#
# test of select error ER_SP_UNDECLARED_VAR
#
create or replace procedure p1 as
type stu_record is record(
id int := 1,
namea varchar(10) := 'namea'
);
type tklist is table of stu_record index by binary_integer;
value1 tklist;
type stu_record1 is record(
ii int := 1,
stu_record_val1 tklist
);
stu_record_val stu_record1;
f blob;
begin
stu_record_val.stu_record_val1(1).id := 1;
select stu_record_val.stu_record_val1(1).namea.id;
end ;
$$
call p1;
ERROR 42000: Undeclared variable: namea
drop procedure p1;
#
# test of set error ER_SP_UNDECLARED_VAR
#
create or replace procedure p1 as
type stu_record is record(
id int := 1,
namea varchar(10) := 'namea'
);
type tklist is table of stu_record index by binary_integer;
value1 tklist;
type stu_record1 is record(
ii int := 1,
stu_record_val1 tklist
);
stu_record_val stu_record1;
f blob;
begin
stu_record_val.stu_record_val1(1).namea.id := 1;
select stu_record_val.stu_record_val1(1).namea.id;
end ;
$$
call p1;
ERROR 42000: Undeclared variable: namea
drop procedure p1;
#
# bugfix#6226: fetch bulk collect into without limit
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
INSERT INTO t1 VALUES (1,'11');
INSERT INTO t1 VALUES (1,'12');
INSERT INTO t1 VALUES (2,'21');
INSERT INTO t1 VALUES (2,'22');
INSERT INTO t1 VALUES (3,'31');
INSERT INTO t1 VALUES (3,'32');
set @@select_bulk_into_batch=5;
show variables like 'select_bulk_into_batch';
Variable_name	Value
select_bulk_into_batch	5
CREATE or replace PROCEDURE p1() as
CURSOR c1 IS SELECT * FROM t1;
type dr_type is table of t1%ROWTYPE index by binary_integer;
dr_table dr_type;
ii int := 0;
begin
open c1;
loop
select ii;
EXIT WHEN ii % @@select_bulk_into_batch > 1;
fetch c1 bulk collect into dr_table;
for i in dr_table.first .. dr_table.last loop
select dr_table(i).a,dr_table(i).b;
end loop;
ii:=ii+1;
end loop;
close c1;
end;
$$
CALL p1();
ii
0
dr_table(i).a	dr_table(i).b
1	11
dr_table(i).a	dr_table(i).b
1	12
dr_table(i).a	dr_table(i).b
2	21
dr_table(i).a	dr_table(i).b
2	22
dr_table(i).a	dr_table(i).b
3	31
ii
1
dr_table(i).a	dr_table(i).b
3	32
ii
2
CALL p1();
ii
0
dr_table(i).a	dr_table(i).b
1	11
dr_table(i).a	dr_table(i).b
1	12
dr_table(i).a	dr_table(i).b
2	21
dr_table(i).a	dr_table(i).b
2	22
dr_table(i).a	dr_table(i).b
3	31
ii
1
dr_table(i).a	dr_table(i).b
3	32
ii
2
set @@select_bulk_into_batch=3;
show variables like 'select_bulk_into_batch';
Variable_name	Value
select_bulk_into_batch	3
CALL p1();
ii
0
dr_table(i).a	dr_table(i).b
1	11
dr_table(i).a	dr_table(i).b
1	12
dr_table(i).a	dr_table(i).b
2	21
ii
1
dr_table(i).a	dr_table(i).b
2	22
dr_table(i).a	dr_table(i).b
3	31
dr_table(i).a	dr_table(i).b
3	32
ii
2
#
# test of bug8761
#
insert into t1 values a(b);
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'a(b)' at line 1
DROP TABLE t1;
DROP PROCEDURE p1;
#
# test of duplicat var
#
CREATE or replace PROCEDURE p1() as
i varchar(10) := 'aa';
j int:=10;
BEGIN
FOR i IN 1 .. 3 LOOP
j := i+j;
select i,j;
END LOOP;
select i;
END;
$$
call p1;
i	j
1	11
i	j
2	13
i	j
3	16
i
aa
drop procedure p1;
