SET SQL_MODE=oracle;

--echo # oracle-style variables declarations
--echo # Testing AS/IS on top-level
CREATE PROCEDURE p1() AS BEGIN END;
DROP PROCEDURE p1;
CREATE PROCEDURE p1() IS BEGIN END;
DROP PROCEDURE p1;

DELIMITER /;
CREATE FUNCTION f1() RETURN INT AS BEGIN RETURN 1; END/
DROP FUNCTION f1/
CREATE FUNCTION f1() RETURN INT IS BEGIN RETURN 1; END/
DROP FUNCTION f1/
DELIMITER ;/

--echo # Testing top-level declarations
DELIMITER /;
CREATE PROCEDURE p1 (p1 OUT VARCHAR2(10))
AS
  p2 VARCHAR(10);
BEGIN
  SET p2:='p1new';
  SET p1:=p2;
END;
/

DELIMITER ;/
SET @p1='p1';
CALL p1(@p1);
SELECT @p1;
DROP PROCEDURE p1;

DELIMITER /;
CREATE FUNCTION f1 (p1 VARCHAR2(10)) RETURN VARCHAR(20)
AS
  p2 VARCHAR(10);
BEGIN
  SET p2:='new';
  RETURN CONCAT(p1, p2);
END;
/
DELIMITER ;/
SET @p1='p1';
SELECT f1(@p1);
DROP FUNCTION f1;

--echo # Testing non-top declarations

DELIMITER /;
CREATE PROCEDURE p1 (p1 OUT VARCHAR2(10))
AS
BEGIN
  DECLARE
    p2 VARCHAR(10);
  BEGIN
    SET p2:='p1new';
    SET p1:=p2;
  END;
  DECLARE
    t1 VARCHAR(10);
    t2 VARCHAR(10);
  BEGIN
  END;
END;
/

DELIMITER ;/
SET @p1='p1';
CALL p1(@p1);
SELECT @p1;
DROP PROCEDURE p1;

DELIMITER /;
CREATE FUNCTION f1 (p1 VARCHAR2(10)) RETURN VARCHAR(20)
AS
BEGIN
  DECLARE
    p2 VARCHAR(10);
  BEGIN
    SET p2:='new';
    RETURN CONCAT(p1, p2);
  END;
  DECLARE
    t1 VARCHAR(10);
    t2 VARCHAR(10);
  BEGIN
  END;
END;
/
DELIMITER ;/
SET @p1='p1';
SELECT f1(@p1);
DROP FUNCTION f1;

#
# Testing CONDITIONs, HANDLERs and CURORs
# Note that all the cases in this section are copied from
# sp.test after modifying the constructure to apply to
# the syntax under oracle mode
#

CREATE TABLE t1 (
  id   CHAR(16) NOT NULL DEFAULT '',
  data INT NOT NULL
) ENGINE=MYISAM;
CREATE TABLE t2 (
  s   CHAR(16),
  i   INT,
  d   DOUBLE
) ENGINE=MYISAM;

-- echo # CONDITIONs and HANDLERs
DELIMITER /;
--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS hndlr1/
CREATE PROCEDURE hndlr1(val int)
AS
x INT DEFAULT 0;
foo CONDITION FOR 1136;
bar CONDITION FOR SQLSTATE '42S98';  # Just for testing syntax
zip CONDITION FOR SQLSTATE VALUE '42S99';  # Just for testing syntax
CONTINUE handler FOR foo SET x = 1;

BEGIN
  INSERT INTO test.t1 VALUES ('hndlr1', val, 2);  # Too many values
  IF (x) THEN
    INSERT INTO test.t1 VALUES ('hndlr1', val);   # This instead then
  END IF;
END/

CALL hndlr1(42)/
SELECT * FROM t1/
DELETE FROM t1/
DROP PROCEDURE HNDLR1/

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS hndlr2/
CREATE PROCEDURE hndlr2(VAL INT)
AS
  x INT DEFAULT 0;
BEGIN
  DECLARE
    EXIT HANDLER FOR SQLSTATE '21S01' SET x = 1;
  BEGIN
    INSERT INTO test.t1 VALUES ('hndlr2', val, 2); # Too many values
  END;

  INSERT INTO test.t1 VALUES ('hndlr2', x);
END/

CALL hndlr2(42)/
SELECT * FROM t1/
DELETE FROM t1/
DROP PROCEDURE hndlr2/

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS hndlr3/
CREATE PROCEDURE hndlr3(val INT)
AS
  x INT DEFAULT 0;
  CONTINUE HANDLER FOR sqlexception
  DECLARE
    z INT;
  BEGIN
    SET z = 2 * val;
    SET x = 1;
  END;
BEGIN
  IF val < 10 THEN
    DECLARE
      y INT;
    BEGIN
      SET y = val + 10;
      INSERT INTO test.t1 VALUES ('hndlr3', y, 2);  # Too many values
      IF x THEN
        INSERT INTO test.t1 VALUES ('hndlr3', y);
      END IF;
    END;
  END IF;
END/

CALL hndlr3(3)/
SELECT * FROM t1/
DELETE FROM t1/
DROP PROCEDURE hndlr3/

CREATE TABLE t3 ( id CHAR(16), data INT )/

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS hndlr4/
CREATE PROCEDURE hndlr4()
AS
  x INT DEFAULT 0;
  val INT;                               # No default
  CONTINUE HANDLER FOR SQLSTATE '02000' SET x=1;
BEGIN
  SELECT data INTO val FROM test.t3 WHERE id='z' LIMIT 1;  # No hits

  INSERT INTO test.t3 VALUES ('z', val);
END/

CALL hndlr4()/
--sorted_result
SELECT * FROM t3/
DROP TABLE t3/
DROP PROCEDURE hndlr4/


# Cursors

INSERT INTO t2 VALUES ('foo', 42, -1.9), ('bar', 3, 12.1), ('zap', 666, -3.14)/
SELECT * FROM t1/

CREATE TABLE t3 ( s CHAR(16), i INT )/

SELECT * FROM t3 ORDER BY i,s/
DELETE FROM t1/
DELETE FROM t2/
DROP TABLE t3/

DELIMITER ;/
DROP TABLE t1;
DROP TABLE t2;

--echo # Testing that (some) ident_keywords_unambiguous are allowed in Oracle-style assignments
DELIMITER /;
CREATE PROCEDURE p1 (action INT) AS BEGIN action:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (backup INT) AS BEGIN backup:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (binlog INT) AS BEGIN binlog:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (bool INT) AS BEGIN bool:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (close INT) AS BEGIN close:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (day INT) AS BEGIN day:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (error INT) AS BEGIN error:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (name INT) AS BEGIN name:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (password INT) AS BEGIN password:=10; END;/
DROP PROCEDURE p1/
DELIMITER ;/

--echo # Testing ident_keywords_ambiguous_2_labels
DELIMITER /;
CREATE PROCEDURE p1 (ascii INT) AS BEGIN ascii:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (byte INT) AS BEGIN byte:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (charset INT) AS BEGIN charset:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (compression_dictionary INT) AS BEGIN compression_dictionary:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (contains INT) AS BEGIN contains:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (language INT) AS BEGIN language:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (no INT) AS BEGIN no:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (signed INT) AS BEGIN signed:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (slave INT) AS BEGIN slave:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (unicode INT) AS BEGIN unicode:=10; END;/
DROP PROCEDURE p1/
DELIMITER ;/

--echo # Testing ident_keywords_ambiguous_3_roles
DELIMITER /;
CREATE PROCEDURE p1 (event INT) AS BEGIN event:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (file INT) AS BEGIN file:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (none INT) AS BEGIN none:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (process INT) AS BEGIN process:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (proxy INT) AS BEGIN proxy:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (reload INT) AS BEGIN reload:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (replication INT) AS BEGIN replication:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (resource INT) AS BEGIN resource:=10; END;/
DROP PROCEDURE p1/
CREATE PROCEDURE p1 (super INT) AS BEGIN super:=10; END;/
DROP PROCEDURE p1/
DELIMITER ;/

--echo # Testing that keywords that do not work in :=
DELIMITER /;
--error ER_PARSE_ERROR
CREATE PROCEDURE p1 (execute INT) AS BEGIN execute:=10; END;/
--error ER_PARSE_ERROR
CREATE PROCEDURE p1 (restart INT) AS BEGIN restart:=10; END;/
--error ER_PARSE_ERROR
CREATE PROCEDURE p1 (shutdown INT) AS BEGIN shutdown:=10; END;/
--error ER_PARSE_ERROR
CREATE PROCEDURE p1 (global INT) AS BEGIN global:=10; END;/
--error ER_PARSE_ERROR
CREATE PROCEDURE p1 (local INT) AS BEGIN local:=10; END;/
--error ER_PARSE_ERROR
CREATE PROCEDURE p1 (persist INT) AS BEGIN persist:=10; END;/
--error ER_PARSE_ERROR
CREATE PROCEDURE p1 (persist_only INT) AS BEGIN persist_only:=10; END;/
--error ER_PARSE_ERROR
CREATE PROCEDURE p1 (session INT) AS BEGIN session:=10; END;/
DELIMITER ;/

--echo #
--echo # Tests for common usages of create or replace stored programs
--echo #

SET SQL_MODE=default;
DELIMITER $$;

CREATE OR REPLACE PROCEDURE p1() SELECT 1 FROM dual;$$
CALL p1();$$

--error ER_SP_ALREADY_EXISTS
CREATE PROCEDURE p1() SELECT 2 FROM dual;$$
CALL p1();$$

CREATE OR REPLACE PROCEDURE p1() select 2 FROM dual;$$
CALL p1();$$
CREATE OR REPLACE PROCEDURE P1() select 3 from dual;$$
CALL p1();$$

DROP PROCEDURE p1;$$
CREATE OR REPLACE PROCEDURE p1() SELECT 4 FROM dual;$$
CALL p1();$$
DROP PROCEDURE p1;$$

DELIMITER ;$$

--echo #
--echo # Tests for checking permission denied on CREATE OR REPLACE if DROP
--echo # access is revoked
--echo #

SELECT CURRENT_USER;
CREATE USER mysqluser1@localhost;

DELIMITER $$;
CREATE OR REPLACE PROCEDURE proc1(cnt INT) BEGIN END$$
CREATE FUNCTION func1() RETURNS VARCHAR(30)
BEGIN
  DECLARE tmp varchar(30);
  SELECT 1 FROM dual into tmp;
  RETURN '1';
END$$
DELIMITER ;$$

--connect (conn1, localhost, mysqluser1)
SELECT CURRENT_USER;

DELIMITER $$;
--error ER_SPECIFIC_ACCESS_DENIED_ERROR
CREATE OR REPLACE PROCEDURE proc1(cnt INT) BEGIN END$$
--error ER_SPECIFIC_ACCESS_DENIED_ERROR
CREATE OR REPLACE FUNCTION func1() RETURNS VARCHAR(30)
BEGIN
  DECLARE tmp varchar(30);
  SELECT 1 FROM dual into tmp;
  RETURN '1';
END$$
DELIMITER ;$$

--connection default
SELECT CURRENT_USER;
DROP PROCEDURE proc1;
DROP FUNCTION func1;
DROP USER mysqluser1@localhost;

-- echo # Tests for CREATE with definers
CREATE TABLE t1 (
  int_field INTEGER UNSIGNED NOT NULL,
  char_field CHAR(10),
  INDEX(`int_field`)
);

CREATE USER usr1@localhost;

DELIMITER /;
CREATE DEFINER=usr1@localhost PROCEDURE p1()
  SELECT * FROM test1.t1; /
CREATE OR REPLACE DEFINER=usr1@localhost PROCEDURE p1()
  SELECT * FROM test1.t1; /

CREATE DEFINER = usr1@localhost FUNCTION f1() RETURNS INT
 RETURN (SELECT COUNT(*) FROM test1.t1); /

CREATE OR REPLACE DEFINER = usr1@localhost FUNCTION f1() RETURNS INT
 RETURN (SELECT COUNT(*) FROM test1.t1); /

DELIMITER ;/
DROP PROCEDURE p1;
DROP FUNCTION f1;
DROP TABLE t1;
DROP USER usr1@localhost;
--echo # Testing routines with no parameters
SET SQL_MODE=oracle;
CREATE PROCEDURE p1 AS BEGIN END;
CALL p1;
DROP PROCEDURE p1;

DELIMITER /;
CREATE FUNCTION f1 RETURN INT AS BEGIN RETURN 1; END/
SELECT f1()/
DROP FUNCTION f1/
CREATE FUNCTION f1 RETURN INT IS BEGIN RETURN 1; END/
SELECT f1()/
DROP FUNCTION f1/
DELIMITER ;/

DELIMITER /;
CREATE FUNCTION f1 RETURN INT
AS
BEGIN
  RETURN 10;
END;
/

SHOW CREATE FUNCTION f1/
SELECT f1()/
DROP FUNCTION f1/

CREATE PROCEDURE p1
AS
BEGIN
  SET @a=10;
END;
/
SHOW CREATE PROCEDURE p1/
SET @a=0/
CALL p1()/
SELECT @a/
DROP PROCEDURE p1/

SET @@global.max_sp_recursion_depth = 5 /
SET @@session.max_sp_recursion_depth = 5 /
CREATE OR REPLACE FUNCTION recur() RETURN INT AS
BEGIN RETURN recur(); END; /
--error ER_SP_NO_RECURSION
SELECT recur() /
CREATE OR REPLACE FUNCTION recur() RETURN VARCHAR(10) AS
BEGIN RETURN recur(); END; /
--error ER_SP_NO_RECURSION
SELECT recur() /
CREATE OR REPLACE FUNCTION recur() RETURN DECIMAL AS
BEGIN RETURN recur(); END; /
--error ER_SP_NO_RECURSION
SELECT recur() /

SET SQL_MODE=DEFAULT;
CREATE OR REPLACE FUNCTION recur() RETURNS INT DETERMINISTIC RETURN recur() /
--error ER_SP_NO_RECURSION
SELECT recur() /
CREATE OR REPLACE FUNCTION recur() RETURNS VARCHAR(10) DETERMINISTIC RETURN recur() /
--error ER_SP_NO_RECURSION
SELECT recur() /
CREATE OR REPLACE FUNCTION recur() RETURNS DECIMAL(5) DETERMINISTIC RETURN recur() /
--error ER_SP_NO_RECURSION
SELECT recur() /


DROP FUNCTION recur /
SET @@global.max_sp_recursion_depth = 0 /
SET @@session.max_sp_recursion_depth = 0 /
DELIMITER ;/

--echo #
--echo # type: VARCHAR、NVARCHAR、VARBINARY without indicate length
--echo # 
DELIMITER |;

SET sql_mode=DEFAULT|

CREATE PROCEDURE p1(str VARCHAR(16383)) BEGIN DECLARE x VARCHAR(16383); SET x = str; SELECT x; END;|
--error 1064
CREATE PROCEDURE p2(str VARCHAR) BEGIN DECLARE x VARCHAR(16383); SET x = str; SELECT x; END;|
--error 1064
CREATE PROCEDURE p3(str VARCHAR(16383)) BEGIN DECLARE x VARCHAR; SET x = str; SELECT x; END;|
CALL p1('hello world')|
DROP PROCEDURE p1|

CREATE PROCEDURE p1(str NVARCHAR(21845)) BEGIN DECLARE x NVARCHAR(21845); SET x = str; SELECT x; END;|
--error 1064
CREATE PROCEDURE p2(str NVARCHAR) BEGIN DECLARE x NVARCHAR(21845); SET x = str; SELECT x; END;|
--error 1064
CREATE PROCEDURE p3(str NVARCHAR(21845)) BEGIN DECLARE x NVARCHAR; SET x = str; SELECT x; END;|
CALL p1('hello world')|
DROP PROCEDURE p1|

CREATE PROCEDURE p1(str VARBINARY(65535)) BEGIN DECLARE x VARBINARY(65535); SET x = str; SELECT x; END;|
--error 1064
CREATE PROCEDURE p2(str VARCHAR) BEGIN DECLARE x VARBINARY(65535); SET x = str; SELECT x; END;|
--error 1064
CREATE PROCEDURE p3(str VARBINARY(65535)) BEGIN DECLARE x VARCHAR; SET x = str; SELECT x; END;|
CALL p1('hello world')|
DROP PROCEDURE p1|

SET sql_mode=ORACLE|

CREATE PROCEDURE p1(str VARCHAR(16383)) AS x VARCHAR(16383); BEGIN x := str; SELECT x; END;|
CREATE PROCEDURE p2(str VARCHAR) AS x VARCHAR(16383); BEGIN x := str; SELECT x; END;|
--error 1064
CREATE PROCEDURE p3(str VARCHAR(16383)) AS x VARCHAR; BEGIN x := str; SELECT x; END;|
CALL p1('hello world')|
CALL p2('hello world')|
DROP PROCEDURE p1|
DROP PROCEDURE p2|

CREATE PROCEDURE p1(str NVARCHAR(21845)) AS x NVARCHAR(21845); BEGIN SET x = str; SELECT x; END;|
CREATE PROCEDURE p2(str NVARCHAR) AS x NVARCHAR(21845); BEGIN SET x = str; SELECT x; END;|
--error 1064
CREATE PROCEDURE p3(str NVARCHAR(21845)) AS x NVARCHAR; BEGIN SET x = str; SELECT x; END;|
CALL p1('hello world')|
CALL p2('hello world')|
DROP PROCEDURE p1|
DROP PROCEDURE p2|

CREATE PROCEDURE p1(str VARBINARY(65535)) AS x VARBINARY(65535); BEGIN SET x = str; SELECT x; END;|
CREATE PROCEDURE p2(str VARCHAR) AS x VARBINARY(65535); BEGIN SET x = str; SELECT x; END;|
--error 1064
CREATE PROCEDURE p3(str VARBINARY(65535)) AS x VARCHAR; BEGIN SET x = str; SELECT x; END;|
CALL p1('hello world')|
CALL p2('hello world')|
DROP PROCEDURE p1|
DROP PROCEDURE p2|

SET sql_mode=DEFAULT|

CREATE FUNCTION f1(str VARCHAR(16383)) RETURNS VARCHAR(16383) BEGIN DECLARE x VARCHAR(16383); SET x = str; RETURN x; END;|
--error 1064
CREATE FUNCTION f2(str VARCHAR) RETURNS VARCHAR(16383) BEGIN DECLARE x VARCHAR(16383); SET x = str; RETURN x; END;|
--error 1064
CREATE FUNCTION f3(str VARCHAR(16383)) RETURNS VARCHAR BEGIN DECLARE x VARCHAR(16383); SET x = str; RETURN x; END;|
--error 1064
CREATE FUNCTION f4(str VARCHAR(16383)) RETURNS VARCHAR(16383) BEGIN DECLARE x VARCHAR; SET x = str; RETURN x; END;|
SELECT f1('hello world')|
DROP FUNCTION f1|

CREATE FUNCTION f1(str NVARCHAR(21845)) RETURNS NVARCHAR(21845) BEGIN DECLARE x NVARCHAR(21845); SET x = str; RETURN x; END;|
--error 1064
CREATE FUNCTION f2(str NVARCHAR) RETURNS NVARCHAR(21845) BEGIN DECLARE x NVARCHAR(21845); SET x = str; RETURN x; END;|
--error 1064
CREATE FUNCTION f3(str NVARCHAR(21845)) RETURNS NVARCHAR BEGIN DECLARE x NVARCHAR(21845); SET x = str; RETURN x; END;|
--error 1064
CREATE FUNCTION f4(str NVARCHAR(21845)) RETURNS NVARCHAR(21845) BEGIN DECLARE x NVARCHAR; SET x = str; RETURN x; END;|
SELECT f1('hello world')|
DROP FUNCTION f1|

CREATE FUNCTION f1(str VARBINARY(65535)) RETURNS VARBINARY(65535) BEGIN DECLARE x VARBINARY(65535); SET x = str; RETURN x; END;|
--error 1064
CREATE FUNCTION f2(str VARBINARY) RETURNS VARBINARY(65535) BEGIN DECLARE x VARBINARY(65535); SET x = str; RETURN x; END;|
--error 1064
CREATE FUNCTION f3(str VARBINARY(65535)) RETURNS VARBINARY BEGIN DECLARE x VARBINARY(65535); SET x = str; RETURN x; END;|
--error 1064
CREATE FUNCTION f4(str VARBINARY(65535)) RETURNS VARBINARY(65535) BEGIN DECLARE x VARBINARY; SET x = str; RETURN x; END;|
SELECT f1('hello world')|
DROP FUNCTION f1|

SET sql_mode=ORACLE|

CREATE FUNCTION f1(str VARCHAR(16383)) RETURN VARCHAR(16383) AS x VARCHAR(16383); BEGIN x := str; RETURN x; END;|
CREATE FUNCTION f2(str VARCHAR) RETURN VARCHAR(16383) AS x VARCHAR(16383); BEGIN x := str; RETURN x; END;|
CREATE FUNCTION f3(str VARCHAR(16383)) RETURN VARCHAR AS x VARCHAR(16383); BEGIN x := str; RETURN x; END;|
--error 1064
CREATE FUNCTION f4(str VARCHAR(16383)) RETURN VARCHAR(16383) AS x VARCHAR; BEGIN x := str; RETURN x; END;|
CREATE FUNCTION f5(str VARCHAR) RETURN VARCHAR AS x VARCHAR(16383); BEGIN x := str; RETURN x; END;|
SELECT f1('hello world')|
SELECT f2('hello world')|
SELECT f3('hello world')|
SELECT f5('hello world')|
DROP FUNCTION f1|
DROP FUNCTION f2|
DROP FUNCTION f3|
DROP FUNCTION f5|

CREATE FUNCTION f1(str NVARCHAR(21845)) RETURN NVARCHAR(21845) AS x NVARCHAR(21845); BEGIN x := str; RETURN x; END;|
CREATE FUNCTION f2(str NVARCHAR) RETURN NVARCHAR(21845) AS x NVARCHAR(21845); BEGIN x := str; RETURN x; END;|
CREATE FUNCTION f3(str NVARCHAR(21845)) RETURN NVARCHAR AS x NVARCHAR(21845); BEGIN x := str; RETURN x; END;|
--error 1064
CREATE FUNCTION f4(str NVARCHAR(21845)) RETURN NVARCHAR(21845) AS x NVARCHAR; BEGIN x := str; RETURN x; END;|
CREATE FUNCTION f5(str NVARCHAR) RETURN NVARCHAR AS x NVARCHAR(21845); BEGIN x := str; RETURN x; END;|
SELECT f1('hello world')|
SELECT f2('hello world')|
SELECT f3('hello world')|
SELECT f5('hello world')|
DROP FUNCTION f1|
DROP FUNCTION f2|
DROP FUNCTION f3|
DROP FUNCTION f5|

CREATE FUNCTION f1(str VARBINARY(65535)) RETURN VARBINARY(65535) AS x VARBINARY(65535); BEGIN x := str; RETURN x; END;|
CREATE FUNCTION f2(str VARBINARY) RETURN VARBINARY(65535) AS x VARBINARY(65535); BEGIN x := str; RETURN x; END;|
CREATE FUNCTION f3(str VARBINARY(65535)) RETURN VARBINARY AS x VARBINARY(65535); BEGIN x := str; RETURN x; END;|
--error 1064
CREATE FUNCTION f4(str VARBINARY(65535)) RETURN VARBINARY(65535) AS x VARBINARY; BEGIN x := str; RETURN x; END;|
CREATE FUNCTION f5(str VARBINARY) RETURN VARBINARY AS x VARBINARY(65535); BEGIN x := str; RETURN x; END;|
SELECT f1('hello world')|
SELECT f2('hello world')|
SELECT f3('hello world')|
SELECT f5('hello world')|
DROP FUNCTION f1|
DROP FUNCTION f2|
DROP FUNCTION f3|
DROP FUNCTION f5|

SET sql_mode=DEFAULT|
--error 1064
CREATE PROCEDURE p1(str VARCHAR(16383)) BEGIN DECLARE x VARCHAR(16383); SET x = str; SELECT x; END p1;|
--error 1064
CREATE FUNCTION f1(str VARCHAR(16383)) RETURNS VARCHAR(16383) BEGIN DECLARE x VARCHAR(16383); SET x = str; RETURN x; END f1;|

SET sql_mode=ORACLE|
CREATE PROCEDURE p1(str VARBINARY(65535)) AS x VARBINARY(65535); BEGIN SET x = str; SELECT x; END p1;|
CALL p1('hello world')|
CALL p1('hello world')|
DROP PROCEDURE p1|
--error 7510
CREATE PROCEDURE p1(str VARBINARY(65535)) AS x VARBINARY(65535); BEGIN SET x = str; SELECT x; END p2;|
--error 7510
CREATE PROCEDURE p1(str VARBINARY(65535)) AS x VARBINARY(65535); BEGIN SET x = str; SELECT x; END test.p1;|

CREATE FUNCTION f1(str VARBINARY(65535)) RETURN VARBINARY(65535) AS x VARBINARY(65535); BEGIN x := str; RETURN x; END f1;|
SELECT f1('hello world')|
SELECT f1('hello world')|
DROP FUNCTION f1|
--error 7510
CREATE FUNCTION f1(str VARBINARY(65535)) RETURN VARBINARY(65535) AS x VARBINARY(65535); BEGIN x := str; RETURN x; END f2;|
--error 7510
CREATE FUNCTION f1(str VARBINARY(65535)) RETURN VARBINARY(65535) AS x VARBINARY(65535); BEGIN x := str; RETURN x; END test.f1;|

DELIMITER ;|

