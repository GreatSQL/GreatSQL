#  Hierarchical Queries
# [ START WITH condition ]
# CONNECT BY [ NOCYCLE ] condition

set sql_mode=oracle;

SELECT level FROM dual CONNECT BY level <= 5;

# SYS_CONNECT_BY_PATH func
# SELECT level,SYS_CONNECT_BY_PATH('a', '/')  AS path FROM dual CONNECT BY level <= 5;


CREATE TABLE student (
    id       INT,
    name  VARCHAR(10),
    grade INT
);

INSERT INTO student VALUES(1, 'John', NULL);
INSERT INTO student VALUES(2, 'Paul', 1);
INSERT INTO student VALUES(3, 'Nancy', 1);
INSERT INTO student VALUES(4, 'Sarah', 3);


SELECT id, name, grade, level
FROM student
CONNECT BY PRIOR id = grade
ORDER BY id;

SELECT DISTINCT id, name, grade
FROM student
CONNECT BY PRIOR id = grade
ORDER BY id;


SELECT id, name, grade, level path
FROM student
CONNECT BY PRIOR id = grade
ORDER BY id;

# level alias
SELECT id, name, grade, level  path
FROM student
CONNECT BY  id = PRIOR grade
ORDER BY id;

# start with
SELECT id, name, grade, level
FROM student
START WITH id > 1
CONNECT BY  id =  grade
ORDER BY id;

SELECT id, name, grade, level
FROM student t1
START WITH id > 1
CONNECT BY  prior t1.id =  t1.grade
ORDER BY id;

SELECT t1.id, name, grade, level
FROM student t1
START WITH id > 1
CONNECT BY  prior t1.id =  t1.grade
ORDER BY id;

# start with 2
SELECT id, name, grade, level
FROM student
CONNECT BY  id =  grade
START WITH id > 1
ORDER BY id;

SELECT id, name, grade, level
FROM student
where id > 1
CONNECT BY  id =  grade
ORDER BY id;

SELECT id, name, grade, level
FROM student
where id > 1
start with grade < 3
CONNECT BY  id =  grade
ORDER BY id;

SELECT id, name, grade, level
FROM student
start with grade =1
CONNECT BY  id =  grade
ORDER BY id;


SELECT t.id, name, grade, (t.id+1),level
FROM student t
start with grade =1
CONNECT BY  id =  grade
ORDER BY id;

SELECT id, name, grade, level FROM student t1 CONNECT BY PRIOR id = grade order by  id desc, level ;

SELECT id,name, grade, level FROM student t1 CONNECT BY PRIOR id = grade order by  t1.id desc, level ;

SELECT t1.name, grade, level FROM student t1 CONNECT BY PRIOR id = grade order by  id desc, level ;

SELECT t1.name, grade, level FROM  student t1 CONNECT BY PRIOR id = grade order by  t1.id , level ;


select 1 , 'b' , 'c' from student t1 connect by prior id = grade ;

SELECT t1.name, grade, level, rownum FROM  student t1 CONNECT BY PRIOR id = grade  ;

SELECT level, rownum FROM  student t1  where rownum < 3 CONNECT BY PRIOR id = grade  ;

SET @v = 0;
prepare stmt FROM 'SELECT t1.name, grade, level FROM student t1 CONNECT BY PRIOR id = grade start with id >? ';
EXECUTE stmt using @v;
DEALLOCATE prepare stmt;

prepare stmt FROM 'SELECT t1.name, grade, level FROM ( select  * from student where id < ? )  t1 CONNECT BY PRIOR id = grade ';
EXECUTE stmt using @v;
DEALLOCATE prepare stmt;

SELECT id,PRIOR name, grade, level  path
FROM student
CONNECT BY  id = PRIOR grade
ORDER BY id;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format =tree
SELECT id,count(id)
FROM student
where id > 1
start with grade < 3
CONNECT BY  id =  grade
group by id;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain SELECT id, name, grade, level
FROM student
CONNECT BY PRIOR id = grade order by id;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
SELECT id, name, grade, level
FROM student
CONNECT BY PRIOR id = grade order by id;

--error ER_BAD_FIELD_ERROR
SELECT t1.id, name, grade, t1.level
FROM student t1
START WITH id > 1
CONNECT BY  prior t1.id =  t1.grade
ORDER BY id;

--error ER_BAD_FIELD_ERROR
SELECT t1.id, name, grade
FROM student t1
START WITH id > 1
CONNECT BY  prior t2.id =  t1.grade
ORDER BY id;

--error ER_BAD_FIELD_ERROR
SELECT t1.id, name, grade
FROM student t1
START WITH t2.id > 1
CONNECT BY  prior id =  t1.grade
ORDER BY id;

--error ER_BAD_FIELD_ERROR
SELECT t1.id, name, grade
FROM student t1
CONNECT BY  prior id =  t1.grade
ORDER BY t2.id;

--error ER_BAD_FIELD_ERROR
SELECT t2.id, name, grade
FROM student t1
CONNECT BY  prior id =  t1.grade
ORDER BY id;

--error ER_BAD_FIELD_ERROR
SELECT id, name, grade
FROM student t1
where t2.id != 0
CONNECT BY  prior id =  t1.grade
ORDER BY id;

CREATE TABLE t2 (
    id       INT,
    name  VARCHAR(10),
    grade INT
);


SELECT t1.id, t2.name, t1.grade
FROM student t1,t2
START WITH t2.id > 1
CONNECT BY  prior t2.id =  t1.grade
ORDER BY t1.id;

drop table t2;

SELECT a.id,name, grade, level FROM student a where a.id > 1  CONNECT BY PRIOR id = grade;

SELECT id,name, grade, level FROM student a where a.id > 1  CONNECT BY PRIOR id = grade;


SELECT * FROM student a where a.id > 1  CONNECT BY PRIOR id = grade;

# dup column name by index
SELECT *,id FROM student a CONNECT BY PRIOR id = grade;

SELECT id FROM student a CONNECT BY PRIOR id = grade group by id ;

SELECT id FROM student a CONNECT BY PRIOR id = grade group by a.id ;

--error ER_BAD_FIELD_ERROR
SELECT id FROM student a CONNECT BY PRIOR id = grade group by t2.id;

SELECT id FROM student a CONNECT BY PRIOR id = grade group by a.id having id > 1;

SELECT id FROM student a CONNECT BY PRIOR id = grade group by a.id having a.id > 1;

--error ER_BAD_FIELD_ERROR
SELECT id FROM student a CONNECT BY PRIOR id = grade group by a.id having b.id > 1;

--error ER_NON_BOOLEAN_EXPR_FOR_CHECK_CONSTRAINT
SELECT t1.name, grade, level FROM  student t1 CONNECT BY level;

select *  from student connect by prior id = grade;

select * from student connect by NOCYCLE  prior id = (grade+1);

select id from student connect by  prior id = grade;

select name from student connect by  prior id = grade;

select grade from student connect by  prior id = grade;

select name,prior name  from student connect by  prior id = grade;

select *,prior name from student connect by  prior id = grade;

select *,prior id from student connect by  prior id = grade;

select *,prior grade from student connect by  prior id = grade;

select *,level from student connect by  prior id = grade;

select id,grade, level,SYS_CONNECT_BY_PATH(id ,'->'),prior name, CONNECT_BY_ROOT id from student connect by prior id = grade;

--error ER_CONNECT_BY_LOOP
select * from  student connect by  prior id = (grade+1);

select * from  student connect by NOCYCLE  prior id = (grade+1);

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select *,connect_by_iscycle from  student connect by prior id = (grade+1);

select *,connect_by_isleaf from  student connect by NOCYCLE  prior id = (grade+1);

select id,grade, level,concat(SYS_CONNECT_BY_PATH(id ,'->'),'tetst')  from student connect by prior id = grade;
--error ER_CONNECT_BY_LOOP
select id,grade, level,concat(SYS_CONNECT_BY_PATH(id ,'->'),'tetst')  from student connect by prior id = (grade+1);

select id,grade, level,concat(SYS_CONNECT_BY_PATH(id ,'->'),'tetst')  from student connect by NOCYCLE prior id = (grade+1);

select 12,'test1' from student connect by prior id = grade;

--error ER_CONNECT_BY_LOOP
select 12,23 from student connect by prior id = grade+1;

--error ER_CONNECT_BY_LOOP
select 12,23,level from student connect by prior id = grade+1;

--error ER_CONNECT_BY_LOOP
select 12,23,CONNECT_BY_ROOT name from student connect by prior id = grade+1;

select id,CONNECT_BY_ROOT name from student connect by NOCYCLE prior id = grade+1;




DROP TABLE student;

###
# icdpub bug
###

set sql_mode=default;

DROP TABLE IF EXISTS `t_ucp_authelement`;
CREATE TABLE `t_ucp_authelement` (
  `AUTHID` varchar(80) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `MODULEID` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `AUTHCODE` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `SUPERCODE` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `AUTHNAME` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `MENUFLAG` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `DESCRIPTION` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `HOSTEDCCID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `AUTHTYPE` tinyint DEFAULT '1',
  `REGION` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CREATOR` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CREATEORG` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ISPUBLIC` tinyint DEFAULT '1',
  `CREATEDATE` datetime DEFAULT NULL,
  `STATUS` tinyint DEFAULT '1',
  `STATUSDATE` datetime DEFAULT NULL,
  `NOTES` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `RIGHTGROUP` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CREATETYPE` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `DISPLAYNO` int DEFAULT NULL,
  `SYSTEMID` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ISDEFORG` tinyint DEFAULT '0',
  `STARTDATE` datetime DEFAULT NULL,
  `ENDDATE` datetime DEFAULT NULL,
  PRIMARY KEY (`AUTHID`)
);


DROP TABLE IF EXISTS `t_ucp_orgainfo`;
CREATE TABLE `t_ucp_orgainfo` (
  `ORGAID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `ORGANAME` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ORGATYPEID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ORGASTATE` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CITYFLAG` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ORGACODE` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `SUPERORGACODE` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ORGADESC` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `PTEAMID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CCFLAG` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `AREACODE` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `MONITORID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `SUPERVISORIDS` varchar(1000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ORDERNUM` int DEFAULT NULL,
  `HOSTEDCCID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT '001',
  `UPDATETIME` datetime DEFAULT CURRENT_TIMESTAMP,
  `BELONGORGA` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ORGALEVEL` tinyint DEFAULT NULL,
  `CREATEDATE` datetime DEFAULT NULL,
  `BEGINDATE` datetime DEFAULT NULL,
  `ENDDATE` datetime DEFAULT NULL,
  `STATUSDATE` datetime DEFAULT NULL,
  `ISCOUNTY` tinyint DEFAULT NULL,
  `ISINNER` tinyint DEFAULT '1',
  `BOSSORGAID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `BOSSSUPERORGAID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `MAXLOGINNUM` int DEFAULT NULL,
  `PARENTID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `OPENPHONE` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ADDRESS` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `POSTALCODE` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CONTACTSTAFFNO` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CONTACTTELNO` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `FAXNO` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `EMAIL` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `OWNERTYPE` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `USERCOUNT` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CANTONTYPE` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `VALIDATEMODE` tinyint DEFAULT '0',
  `AGENTTYPEID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `STARLEVEL` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `DISTTYPEID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ISCHANNELAUTHFILTER` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT 'N',
  `CHANNELTYPEID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `DEPARTCODE` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ISPROVCHAIN` tinyint DEFAULT NULL,
  `CHAINNAME` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `REGION` int DEFAULT NULL,
  `DEALER` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ISTERMINALFEEINCOME` tinyint DEFAULT '1',
  `AGENTSTYLE` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `AGENTTYPE` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `REALNAMECODE` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `LSCHANNELID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ISECLCBUSINESS` tinyint DEFAULT NULL,
  `ISSTATMOBSELL` varchar(5) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CMIOTFLAG` tinyint DEFAULT NULL,
  `GRPCUSTTYPE` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CONTACTPARTYMEMBERNAME` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CONTACTPARTYMEMBERPHONE` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ORGSUBTYPE` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  KEY `IX_UCP_ORGAINFO_PARENTID` (`PARENTID`));


DROP TABLE IF EXISTS `t_ucp_putroleuser`;
CREATE TABLE `t_ucp_putroleuser` (
  `STAFFID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `ROLEID` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `CONDITIONSTR` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `HOSTEDCCID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  PRIMARY KEY (`ROLEID`,`STAFFID`));

DROP TABLE IF EXISTS `t_ucp_role`;
CREATE TABLE `t_ucp_role` (
  `ROLEID` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `ROLECODE` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `SUPERCODE` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `ROLENAME` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `DESCRIPTION` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CTIFLAG` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `CTIROLEID` varchar(3) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CCID` bigint DEFAULT NULL,
  `VDNID` bigint DEFAULT NULL,
  `HOSTEDCCID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ISPUBLIC` tinyint DEFAULT '1',
  `CREATOR` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CREATEDATE` datetime DEFAULT NULL,
  `CREATEORG` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `STATUS` tinyint DEFAULT NULL,
  `STATUSDATE` datetime DEFAULT NULL,
  `REGION` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ROLETYPE` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `DISPLAYNO` int DEFAULT '99999',
  `WORKSHOPID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ISMODIFYCONTROL` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT '0',
  `NOTES` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `REQUIREOP` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `REQUIREORG` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `MANAGEOP` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `MANAGEORG` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  PRIMARY KEY (`ROLEID`));

DROP TABLE IF EXISTS `t_ucp_roleputauth`;
CREATE TABLE `t_ucp_roleputauth` (
  `ROLEID` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `MODULEID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `AUTHID` varchar(80) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `CONDITIONSTR` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `HOSTEDCCID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  PRIMARY KEY (`ROLEID`,`MODULEID`,`AUTHID`));

DROP TABLE IF EXISTS `t_ucp_staffbasicinfo`;
CREATE TABLE `t_ucp_staffbasicinfo` (
  `STAFFID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `STAFFNAME` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `STAFFSTATE` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `STAFFIDSTATUS` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `DLEVELID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `DLMODULUS` decimal(4,2) DEFAULT NULL,
  `SECONDPOST` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `DUTYID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `SECONDDUTY` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `PTEAMID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ORGAID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `POSTID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `STAFFACCOUNT` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `DISABLEBEGINDATE` datetime DEFAULT NULL,
  `DISABLEENDDATE` datetime DEFAULT NULL,
  `HOSTEDCCID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `PERSONALCFGID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `UPDATETIME` datetime DEFAULT CURRENT_TIMESTAMP,
  `BATCHNO` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `STAFFTYPE` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ISMANAGER` tinyint DEFAULT NULL,
  `HRSTATUS` tinyint DEFAULT NULL,
  `CREATEDATE` datetime DEFAULT NULL,
  `STATUSDATE` datetime DEFAULT NULL,
  `REMARK` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `REGION` int DEFAULT NULL,
  `BEGINDATE` datetime DEFAULT NULL,
  `ENDDATE` datetime DEFAULT NULL,
  `RELESTAFFID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `WORKEFFICIENCY` int DEFAULT NULL,
  `TELNO` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `LOGINTYPE` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `WORKTYPE` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `AREAID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `EMPLOYEETYPE` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `STAFFNUMBER` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `STAFFIDUSE` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ISADMIN` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `PETNAME` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `ISMODIFYCONTROL` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT '0',
  `RESPCITYID` varchar(40) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `NOTMODSTATUS` varchar(8) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CURRENTORGAID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CURRENTREGION` int DEFAULT NULL,
  `SALESCENE` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `CHANNELTYPE` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `LOGINCHKPHOTO` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT '0',
  `UPLOADPHOTO` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT '0',
  `USERNAME` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  PRIMARY KEY (`STAFFID`));

DROP TABLE IF EXISTS `t_ucp_staffrole`;
CREATE TABLE `t_ucp_staffrole` (
  `ROLEID` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `STAFFID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `CONDITIONSTR` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `HOSTEDCCID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `STATUS` tinyint DEFAULT '1',
  `STATUSDATE` datetime DEFAULT CURRENT_TIMESTAMP,
  `CREATEDATE` datetime DEFAULT CURRENT_TIMESTAMP,
  `ORGAID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `BEGINDATE` datetime DEFAULT CURRENT_TIMESTAMP,
  `ENDDATE` datetime DEFAULT CURRENT_TIMESTAMP,
  `ROAMSTATIONID` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT '0',
  `NOTES` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  KEY `IX_UCP_STAFFROLE_STAFF` (`STAFFID`));


DROP TABLE IF EXISTS `t_ucp_putauth`;
CREATE TABLE `t_ucp_putauth` (
  `STAFFID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `MODULEID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `AUTHID` varchar(80) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL,
  `CONDITIONSTR` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `HOSTEDCCID` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL,
  `BEGINDATE` datetime DEFAULT CURRENT_TIMESTAMP,
  `ENDDATE` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`STAFFID`,`MODULEID`,`AUTHID`));

set sql_mode=oracle;

select * from (select distinct a.authid, a.authcode, a.supercode, a.authname, a.menuflag, a.description, a.moduleid, a.region, a.creator, a.createorg, a.ispublic, a.createdate, a.status, a.statusdate, a.createtype, a.rightgroup, a.displayno, a.systemid from t_ucp_authelement a connect by prior a.supercode = a.authcode start with exists (select authid from ( select b.authid from t_ucp_putauth b where b.staffid = 1 union all select c.authid from t_ucp_roleputauth c, t_ucp_staffrole d where c.roleid = d.roleid and d.staffid = 1 ) where authid = a.authid )) where 1 = 1 and supercode = 2 and status = 1 order by displayno, supercode, authcode;
select * from (select distinct a.authid, a.authcode, a.supercode, a.authname, a.menuflag, a.description, a.moduleid, a.region, a.creator, a.createorg, a.ispublic, a.createdate, a.status, a.statusdate, a.createtype, a.rightgroup, a.displayno, a.systemid from t_ucp_authelement a connect by prior a.supercode = a.authcode start with exists (select authid from ( select b.authid from t_ucp_putauth b where b.staffid = 1 union all select c.authid from t_ucp_roleputauth c, t_ucp_staffrole d where c.roleid = d.roleid and d.staffid = 1 ) where authid = a.authid )) where 1 = 1 and supercode = 2 order by displayno, supercode, authcode;
select * from (select distinct a.ctiroleid, a.rolename, a.rolecode, a.description, a.ccid, a.roleid, a.supercode, a.vdnid, a.ctiflag, a.roletype, a.displayno, a.status from t_ucp_role a connect by prior a.supercode = a.rolecode start with exists (select b.roleid from t_ucp_putroleuser b where a.roleid = b.roleid and b.staffid = 1)) where 1 = 1 and status = 1 and supercode = 2 order by displayno, rolecode;
select * from (select distinct a.ctiroleid, a.rolename, a.rolecode, a.description, a.ccid, a.roleid, a.supercode, a.vdnid, a.ctiflag, a.roletype, a.workshopid, a.displayno from t_ucp_role a connect by prior a.supercode = a.rolecode start with exists (select b.roleid from t_ucp_putroleuser b where a.roleid = b.roleid and b.staffid = 1 )) where 1 = 1 and supercode = 2 order by displayno, rolecode;
select * from (select distinct a.ctiroleid, a.rolename, a.rolecode, a.description, a.ccid, a.roleid, a.supercode, a.vdnid, a.ctiflag, a.roletype, a.workshopid, a.displayno from t_ucp_role a connect by prior a.supercode = a.rolecode start with exists (select b.roleid from t_ucp_putroleuser b where a.roleid = b.roleid and b.staffid = 1 )) where 1 = 1 order by displayno, rolecode;
select authid, authcode, supercode, authname, menuflag, description, moduleid, region, creator, createorg, ispublic, createdate, status, statusdate, createtype, rightgroup, systemid from t_ucp_authelement start with authid = 11 connect by prior supercode = authcode;
select ctiroleid, rolename, rolecode, description, ccid, roleid, supercode, vdnid, ctiflag from t_ucp_role start with roleid = 1 connect by prior supercode = rolecode;
select ctiroleid, rolename, rolecode, description, ccid, roleid, supercode, vdnid, ctiflag from t_ucp_role start with roleid = 1 connect by prior supercode = rolecode;
select distinct a.orgacode from t_ucp_orgainfo a connect by prior a.superorgacode = a.orgacode start with a.orgacode = 1;
select distinct a.orgaid from t_ucp_orgainfo a connect by prior a.parentid = a.orgaid start with a.orgaid = 1;
select distinct t1.staffid, t1.staffname, t1.staffstate, t1.staffidstatus, t1.orgaid, t1.dlevelid, t1.dlmodulus, t1.secondpost, t1.dutyid, t1.secondduty, t1.postid, t1.pteamid, t1.hostedccid, t1.staffaccount, t1.disableenddate, t1.disablebegindate, t1.personalcfgid, t1.batchno, t1.workefficiency, t1.region, t1.stafftype, t1.ismanager, t1.hrstatus, t1.createdate, t1.begindate, t1.enddate, t1.statusdate, t1.remark, t1.relestaffid, t1.telno, t1.logintype, t1.worktype, t1.employeetype, t1.areaid from t_ucp_staffbasicinfo t1, t_ucp_staffrole t2 where t1.orgaid in (select orgaid from (select level aaa, a.orgaid from t_ucp_orgainfo a start with orgaid = (select orgaid from t_ucp_staffbasicinfo where staffid = 1 ) connect by prior parentid = orgaid) t where t.aaa <= 1 ) and t1.staffstate = '1' and t1.staffidstatus = '01' and t2.staffid = t1.staffid and t2.roleid = 1 order by t1.staffid asc;
select distinct t1.staffid, t1.staffname, t1.staffstate, t1.staffidstatus, t1.orgaid, t1.dlevelid, t1.dlmodulus, t1.secondpost, t1.dutyid, t1.secondduty, t1.postid, t1.pteamid, t1.hostedccid, t1.staffaccount, t1.disableenddate, t1.disablebegindate, t1.personalcfgid, t1.batchno, t1.workefficiency, t1.region, t1.stafftype, t1.ismanager, t1.hrstatus, t1.createdate, t1.begindate, t1.enddate, t1.statusdate, t1.remark, t1.relestaffid, t1.telno, t1.logintype, t1.worktype, t1.employeetype, t1.areaid from t_ucp_staffbasicinfo t1, t_ucp_staffrole t2 where t1.orgaid in (select orgaid from (select level aaa, a.orgaid from t_ucp_orgainfo a start with orgaid = (select orgaid from t_ucp_staffbasicinfo where staffid = 1 ) connect by prior parentid = orgaid) t where t.aaa <= 1 ) and t1.staffstate = '1' and t1.staffidstatus = '01' and t2.staffid = t1.staffid and t2.roleid like 'monitorconfirm%';
select orgacode, orgadesc, organame, orgatypeid, orgastate, cityflag, pteamid, orgaid, superorgacode, ccflag, areacode, monitorid, maxloginnum, supervisorids, ordernum, belongorga, orgalevel, createdate, begindate, enddate, statusdate, isinner, parentid, openphone, address, postalcode, contactstaffno, contacttelno, faxno, email, ownertype, validatemode, cantontype from t_ucp_orgainfo t start with t.orgaid = 1 connect by prior t.parentid = t.orgaid order by t.orgacode;
select orgacode, orgadesc, organame, orgatypeid, orgastate, cityflag, pteamid, orgaid, superorgacode, ccflag, areacode, monitorid, maxloginnum, supervisorids, ordernum, belongorga, orgalevel, createdate, begindate, enddate, statusdate, isinner, parentid, openphone, address, postalcode, contactstaffno, contacttelno, faxno, email, ownertype, validatemode, cantontype from t_ucp_orgainfo t start with t.orgaid = 1 connect by prior t.parentid = t.orgaid order by t.orgacode;
select t.roleid, b.rolename, t.staffid from t_ucp_staffrole t, t_ucp_role b where t.roleid in (select t.roleid from t_ucp_role t start with t.rolename like '_报表话务员类型%' connect by prior t.rolecode = t.supercode) and t.roleid = b.roleid and translate(t.staffid, 'a0123456789', 'a') is null;
drop table t_ucp_authelement,t_ucp_orgainfo,t_ucp_putroleuser,t_ucp_role,t_ucp_roleputauth,t_ucp_staffbasicinfo,t_ucp_staffrole,t_ucp_putauth;


create table tt1
(
 id varchar(64),
 pid varchar(64)
);

INSERT INTO tt1 VALUES('1',  NULL);
INSERT INTO tt1 VALUES('2',  '1');
INSERT INTO tt1 VALUES('3',  '1');
INSERT INTO tt1 VALUES('4',  '3');

# bug 4012
select * from tt1 aa connect by aa.id = prior aa.pid;

drop table tt1;

select level from dual connect by level < 1;
select level from dual connect by level < 2;
select level from dual connect by level < 3;

set timestamp=1;
select now() from dual connect by level < 3;
select 1 from dual connect by level < 3;

set sql_mode=oracle;
set shrink_sql_mode='STRICT_TRANS_TABLES,STRICT_ALL_TABLES';

DROP TABLE IF EXISTS tbl_test;
CREATE TABLE tbl_test
(
 ID int,
 NAME VARCHAR2(100),
 PID NUMBER DEFAULT 0
) partition by hash(id) partitions 15 ;

INSERT INTO tbl_test(ID,NAME,PID) VALUES(1,'10','0');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(2,'11','1');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(3,'20','0');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(4,'12','1');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(5,'121','2');
DROP TABLE IF EXISTS emp;
 create table  emp
   (	 empno  int,
	 ename  varchar2(10),
	 job  varchar2(9),
	 mgr  number(4,0),
	 hiredate  date,
	 sal  number(7,2),
	 comm  number(7,2),
	 deptno  number(2,0)
   )  partition by hash(empno) partitions 15 ;
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7369,'smith','clerk',7902,'2017-12-08',800,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7499,'allen','salesman',7698,'2020-02-08',1600,300,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7521,'ward','salesman',7698,'2022-02-08',1250,500,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7566,'jones','manager',7839,'2002-10-01',2975,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7654,'martin','salesman',7698,'2001-02-09',1250,1400,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7698,'blake','manager',7839,'2023-03-08',2850,null,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7782,'clark','manager',7839,'2021-01-18',2450,null,10);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7788,'SCOTT','analyst',7566,'2019-06-07',3000,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7839,'KING','president',null,'2019-07-07',5000,null,10);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7844,'turner','salesman',7698,'2021-04-17',1500,0,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7876,'adams','clerk',7788,'2022-01-01',1100,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7900,'james','clerk',7698,'2018-01-08',950,null,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7902,'ford','analyst',7566,'2017-02-08',3000,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7934,'miller','clerk',7782,'2016-02-08',1300,null,10);

DROP TABLE IF EXISTS empmessage;
 create table empmessage(
      empno number,
      weight varchar(100)
);

insert into empmessage values(7369,'70kg');
insert into empmessage values(7499,'74kg');
insert into empmessage values(7521,'73kg');
insert into empmessage values(7566,'80kg');
insert into empmessage values(7654,'90kg');
insert into empmessage values(7698,'81kg');
insert into empmessage values(7782,'83kg');
insert into empmessage values(7788,'84kg');
insert into empmessage values(7839,'88kg');

select * from tbl_test  connect by prior id = pid;

select * from tbl_test  connect by pid  =  prior id;


DROP TABLE IF EXISTS t1,t2,t3,t4;
DROP TABLE IF EXISTS emp,empmessage,tbl_test;


CREATE TABLE student (
    id       INT,
    name  VARCHAR(10),
    grade INT
);

INSERT INTO student VALUES(1, 'John', -1);
INSERT INTO student VALUES(2, 'Paul', 1);
INSERT INTO student VALUES(3, 'Nancy', 1);
INSERT INTO student VALUES(4, 'Sarah', 2);

#
# prior
#
--error ER_PSEUDOCOLUMN_NOT_ALLOW
select id,name,grade,prior name from student;

select id,name,grade,prior name from student connect by prior id = grade;

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select id,name,grade,prior level from student connect by prior id = grade;

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select *,prior name from student start with  prior name is not null connect by id < 1;

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select id,prior max(id) from student  connect by prior id = grade;

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select id,prior max(id) from student  connect by prior id = grade;

select id,name,grade,prior name from student where prior name is not  null  connect by prior id = grade;

select id from student   connect by prior id = grade group by id,prior grade;

select id from student connect by prior id = grade order by id,prior grade;

select id , lag(id, 1)over() from student connect by prior id = grade;

select id , lag(id, 1)over() from student connect by prior id = grade group by id ;

select id ,prior grade from student connect by prior id = grade ;

select id ,(prior grade)+1 from student connect by prior id = grade ;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select id from student connect by prior id = grade group by id,prior grade;

#
# connect_by_root
#
--error ER_PSEUDOCOLUMN_NOT_ALLOW
select id,name,grade,connect_by_root name from student;

select id,connect_by_root name from student connect by prior id = grade;

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select id,connect_by_root level from student connect by prior id = grade;

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select id,connect_by_root name  from student start with connect_by_root id connect by prior id = grade;

select id  from student where connect_by_root name is not null connect by prior id = grade;

select id  from student connect by prior id = grade group by id, connect_by_root name;

select id  from student connect by prior id = grade order by connect_by_root grade ;
#
# sys_connect_by_path
#
--error ER_PSEUDOCOLUMN_NOT_ALLOW
select id,name,grade,SYS_CONNECT_BY_PATH(name,'->') from student;

select id,SYS_CONNECT_BY_PATH(name,'->') from student connect by id < 1;

select id,concat(SYS_CONNECT_BY_PATH(name,'->'), ' end_str') from student connect by prior id = grade;

select id,SYS_CONNECT_BY_PATH(level,'->') from student connect by prior id = grade;

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select id,name,grade from student where SYS_CONNECT_BY_PATH(name,'->') is not null connect by id < 1;

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select id from student  connect by id < 1 group by SYS_CONNECT_BY_PATH(name,'->');

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select id from student  connect by id < 1 order by SYS_CONNECT_BY_PATH(name,'->');

#
# level
#
--error ER_BAD_FIELD_ERROR
select *,level from student;

select id,name,grade,level from student connect by id < 1;

select id,name,grade from student start with level = 0  connect by id < 1;

select id,name,grade from student where level <> 0  connect by id < 1;

select level from student connect by id < 1 group by level ;

--error ER_BAD_FIELD_ERROR
select id from student  connect by id < 1 group by id,level having level <> 1 ;

#select id,level from student  connect by id < 1 group by id,level having level <> 1 ;

select level from student  connect by id < 1  order  by level;

#
# connect_by_isleaf
#

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select *,connect_by_isleaf from student;

select *,connect_by_isleaf from student connect by level < 1;

select id,name,grade,connect_by_isleaf from student connect by nocycle level < 1;

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select id,name,grade from student start with connect_by_isleaf = 0 connect by nocycle level < 1;

select id,name,grade from student where connect_by_isleaf = 1 connect by nocycle level < 1;

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select id,name,grade from student where connect_by_isleaf = 1 connect by nocycle connect_by_isleaf < 1;

select id from student connect by nocycle level < 1 group by id, connect_by_isleaf;

select id from student connect by nocycle level < 1 group by id, connect_by_isleaf having connect_by_isleaf <> 1;

select id,connect_by_isleaf from student connect by nocycle level < 1 order by connect_by_isleaf;


select id,name,grade,connect_by_isleaf from student connect by nocycle prior id = (grade +1);
#
# connect_by_iscycle
#

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select *,connect_by_iscycle from student;

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select *,connect_by_iscycle from student connect by level < 1;

select id,name,grade,connect_by_iscycle from student connect by nocycle level < 1;

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select * from student start with connect_by_iscycle = 0 connect by nocycle level < 1;

--error ER_PSEUDOCOLUMN_NOT_ALLOW
select * from student  connect by nocycle connect_by_iscycle  <> 0;

select id,name,grade from student where connect_by_iscycle = 0 connect by nocycle level < 1;

select id,name,grade from student where connect_by_iscycle = 1 connect by nocycle level < 1;

select id from student connect by nocycle level < 1 group by id, connect_by_iscycle;

select id from student connect by nocycle level < 1 group by id, connect_by_iscycle having connect_by_iscycle <> 1;

select id,connect_by_iscycle from student connect by nocycle level < 1 order by connect_by_iscycle;


select id,name,grade,connect_by_iscycle from student connect by nocycle prior id = (grade +1);
#
# cycle
#

# const
--error ER_CONNECT_BY_LOOP
select 1 ,'test' from student connect by prior id = (grade +1);

select 1 ,'test' from student connect by nocycle prior id = (grade +1);

--error ER_CTE_MAX_RECURSION_DEPTH
select 1 ,'test' from student connect by nocycle id < 3;

select id,grade,name,level from student connect by nocycle prior id = (grade +1);

# pseudo column
set timestamp=1;
select id,grade,now() from student connect by nocycle prior id = (grade +1);

# with group func
select max(id) from student connect by prior id = grade group by id;

select id,max(id) from student connect by prior id = grade group by id;

select max(id),LISTAGG(name, '->') from student connect by prior id = grade;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select id,max(id) from student connect by prior id = grade group by id;

# hash field index
select id,LISTAGG(name, '->') from student connect by NOCYCLE prior id = (grade +1) group by id;

#with connect_by func
select max(id),LISTAGG(level, '->') from student connect by prior id = grade;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select max(id),LISTAGG(level, '->') from student connect by prior id = grade;

select max(id),LISTAGG(level, '->') from student connect by prior id = grade group by id;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select max(id),LISTAGG(level, '->') from student connect by prior id = grade group by id;

select * from (select id,grade from student connect by prior id = grade) s2 where id > 3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select * from (select id,grade from student connect by prior id = grade) s2 where id > 3;

select  * from (select * from student connect by prior id = grade) a where id = 2;

select  * from (select * from student where id > 1) a  connect by prior id = grade;

select * from (select * from (select id, grade from student) t connect by prior id = grade) t2 where id =2;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select  * from (select * from student connect by prior id = grade) a where id = 2;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select  * from (select * from student where id > 1) a  connect by prior id = grade;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select * from (select * from (select id, grade from student) t connect by prior id = grade) t2 where id =2;

drop table student;

# order index scan
CREATE TABLE student (
    id    INT primary key,
    name  VARCHAR(10),
    grade INT
);

INSERT INTO student VALUES(1, 'John', -1);
INSERT INTO student VALUES(2, 'Paul', 1);
INSERT INTO student VALUES(3, 'Nancy', 1);
INSERT INTO student VALUES(4, 'Sarah', 2);

# skip index scan
select id,max(id) from student connect by prior id = grade group by id;

#
# join
#
create table t2(grade int,name varchar2(200));
insert into t2 values(1, 'test1');
insert into t2 values(2, 'test2');
insert into t2 values(3, 'test3');
insert into t2 values(4, 'test4');
create table s1(id int,grade int);
insert into s1 values(1, -1);
insert into s1 values(2, 1);
insert into s1 values(3, 1);
insert into s1 values(4, 2);

select s1.id , s1.grade, t2.name  from s1,t2 where s1.id = t2.grade connect by prior s1.id = s1.grade;

select s1.id , s1.grade, t2.name  from s1 join t2 on s1.id = t2.grade connect by prior s1.id = s1.grade;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select s1.id , s1.grade, t2.name  from s1,t2 where s1.id = t2.grade connect by prior s1.id = s1.grade;

# join on with cond

select s1.id , s1.grade, t2.name  from s1 join t2 on s1.id = t2.grade and s1.id > 3  connect by prior s1.id = s1.grade;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select s1.id , s1.grade, t2.name  from s1 join t2 on s1.id = t2.grade and s1.id > 3  connect by prior s1.id = s1.grade;



create index idx1 on s1(id);

select s1.id , s1.grade, t2.name  from s1,t2 where s1.id = t2.grade connect by prior s1.id = s1.grade;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select s1.id , s1.grade, t2.name  from s1,t2 where s1.id = t2.grade connect by prior s1.id = s1.grade;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select s1.id , s1.grade, t2.name  from s1 join t2 on s1.id = t2.grade connect by prior s1.id = s1.grade;


select s1.id , s1.grade, t2.name  from s1,t2 where s1.id = t2.grade and s1.id > 3  connect by prior s1.id = s1.grade;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select s1.id , s1.grade, t2.name  from s1,t2 where s1.id = t2.grade and s1.id > 3  connect by prior s1.id = s1.grade;


# join on with cond

select s1.id , s1.grade, t2.name  from s1 join t2 on s1.id = t2.grade and s1.id > 3  connect by prior s1.id = s1.grade;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select s1.id , s1.grade, t2.name  from s1 join t2 on s1.id = t2.grade and s1.id > 3  connect by prior s1.id = s1.grade;


--error ER_CONNECT_BY_LOOP
SELECT *, connect_by_isleaf , connect_by_iscycle ,level   FROM  student CONNECT BY nocycle 1=1;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select * from (select * from s1 connect by prior id = grade) s1;

select id  from student connect by prior id = grade group by id ;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select id  from student connect by prior id = grade group by id ;

select  * from (select * from student connect by prior id = grade) a where id = 2;

select  * from (select * from student where id > 1) a  connect by prior id = grade;

select * from (select * from (select id, grade from student) t connect by prior id = grade) t2 where id =2;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select  * from (select * from student connect by prior id = grade) a where id = 2;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select  * from (select * from student where id > 1) a  connect by prior id = grade;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select * from (select * from (select id, grade from student) t connect by prior id = grade) t2 where id =2;

drop table student,t2,s1;

CREATE TABLE tb_ct2
AS
SELECT 'a' AS rn, '1,2,3' AS i_name
FROM dual
UNION ALL
SELECT 'b', '4,5,6'
FROM dual;

SELECT rn, i_name
FROM   tb_ct2
CONNECT BY   PRIOR rand() IS NOT NULL AND   PRIOR rn = rn AND  LEVEL <= 3;

drop  table tb_ct2;

create table t1 (id int , pid int);
insert into t1 values (1,0);
insert into t1 values (2,1);
insert into t1 values (3,1);
insert into t1 values (4,2);
insert into t1 values (5,2);
insert into t1 values (6,5);
insert into t1 values (7,5);
insert into t1 values (1,2);

select *, sys_connect_by_path(id, '->') from t1 connect by nocycle pid = prior id start with id = 2;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select * from t1 where level < 2 connect by nocycle pid = prior id start with id = 2;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select * from t1 where connect_by_iscycle < 2 connect by nocycle pid = prior id start with id = 2;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select * from t1 where connect_by_isleaf != 0 connect by nocycle pid = prior id start with id = 2;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select * from t1 where level < id connect by nocycle pid = prior id start with id = 2;

drop table t1;

create table t1(c1 int primary key,c2 int);
insert into t1 values(1,1);
insert into t1 values(2,2);
insert into t1 values(3,3);
insert into t1 values(4,4);

create table t2(c1 int primary key,c2 int);
insert into t2 values(1,1);
insert into t2 values(2,2);

select *
from t1, t2
where (t1.c1=1 or  t2.c1=2)  and t2.c2 >1
connect by nocycle prior t1.c1= t2.c1;

select *  from t1, t2    connect by nocycle prior t1.c1= t2.c1;

select *  from t1, t2   where t1.c1=1  or t2.c2 >1  connect by nocycle prior t1.c1= t2.c1;

drop table t1;
drop table t2;

#bug5460
select rownum from dual connect by rownum <= 10;



CREATE TABLE ne_cmd_schema (
  SCHEMA_ID decimal(65,0) NOT NULL,
  ELEMENT_ID decimal(65,0) NOT NULL,
  PARENT_ELEMENT_ID decimal(65,0) NOT NULL,
  ELEMENT_NAME varchar(50) COLLATE utf8mb4_bin NOT NULL,
  ELEMENT_CONSTR varchar(10) COLLATE utf8mb4_bin DEFAULT NULL,
  TYPE varchar(10) COLLATE utf8mb4_bin DEFAULT NULL,
  DATA_TYPE varchar(100) COLLATE utf8mb4_bin DEFAULT NULL ,
  DATA_FORMAT varchar(100) COLLATE utf8mb4_bin DEFAULT NULL,
  DATA_SOURCE_TYPE varchar(100) COLLATE utf8mb4_bin DEFAULT NULL,
  PATH text COLLATE utf8mb4_bin ,
  MAPPING_KEY varchar(50) COLLATE utf8mb4_bin DEFAULT NULL ,
  IS_MAPPING decimal(65,0) DEFAULT NULL ,
  IS_PRIMARY_KEY decimal(65,0) DEFAULT NULL ,
  NE_CMD_TEMPLATE_ID decimal(65,0) NOT NULL,
  ELEMENT_DESC varchar(100) COLLATE utf8mb4_bin DEFAULT NULL,
  DATA_SOURCE varchar(100) COLLATE utf8mb4_bin DEFAULT NULL,
  VARIABLE_NAME varchar(50) COLLATE utf8mb4_bin DEFAULT NULL ,
  VALUE_NAME varchar(30) COLLATE utf8mb4_bin DEFAULT NULL ,
  IS_ENCRYPT varchar(10) COLLATE utf8mb4_bin DEFAULT NULL ,
  PRIMARY KEY (SCHEMA_ID)
);

select schema_id,
element_id,
parent_element_id,
element_name,
element_constr,
type,
data_type,
data_format,
data_source_type,
path,
mapping_key,
is_mapping,
is_primary_key,
ne_cmd_template_id,
element_desc,
data_source,
value_name,
is_encrypt,
variable_name
from (select schema_id,
element_id,
parent_element_id,
element_name,
element_constr,
type,
data_type,
data_format,
data_source_type,
path,
mapping_key,
is_mapping,
is_primary_key,
ne_cmd_template_id,
element_desc,
data_source,
value_name,
is_encrypt,
variable_name
from ne_cmd_schema a
where a.NE_CMD_TEMPLATE_ID = '1' ) b CONNECT BY PRIOR b.element_id = b.parent_element_id
START WITH b.parent_element_id = '0';

drop table ne_cmd_schema;

select 2 a from dual connect by level <=3;

explain select 2 a from dual connect by level <=3;

explain format=json select 2 a from dual connect by level <=3;

select a from  (select 2 a from dual connect by level <=3) t1 ;

explain select a from  (select 2 a from dual connect by level <=3) t1 ;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select a from  (select 2 a from dual connect by level <=3) t1 ;

explain format=json select a from  (select 2 a from dual connect by level <=3) t1 ;

select sum(a) over() from  (select 2 a from dual connect by level <=3) t1 ;

explain select sum(a) over() from  (select 2 a from dual connect by level <=3) t1;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select sum(a) over() from  (select 2 a from dual connect by level <=3) t1;

explain format=json select sum(a) over() from  (select 2 a from dual connect by level <=3) t1;

select ratio_to_report(6) over() from dual connect by level<=5;

explain select ratio_to_report(6) over() from dual connect by level<=5;
--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select ratio_to_report(6) over() from dual connect by level<=5;
explain format=json select ratio_to_report(6) over() from dual connect by level<=5;

CREATE TABLE tbl_test
(
 ID int,
 NAME VARCHAR2(100),
 PID NUMBER DEFAULT 0
) partition by hash(id) partitions 15 ;

INSERT INTO tbl_test(ID,NAME,PID) VALUES(1,'10','0');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(2,'11','1');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(3,'20','0');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(4,'12','1');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(5,'121','2');

select id from tbl_test  connect by  not exists (select id from tbl_test ) start with id=5;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree  select id from tbl_test  connect by  not exists (select id from tbl_test ) start with id=5;

select id from tbl_test  connect by  1=2  start with id=5;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree  select id from tbl_test  connect by  1=2  start with id=5;

select id from tbl_test where pid > 0 start with id<5 connect by 1=2;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select id from tbl_test where pid > 0 start with id<5 connect by 1=2;

DROP TABLE IF EXISTS tbl_test;
set sql_mode=oracle;
set timestamp = 1;
select sysdate - (to_number(to_char(sysdate - 1, 'd')) - 1) - (rownum - 1) * 7 as startDate,
       sysdate + (7 - to_number(to_char(sysdate - 1, 'd'))) - (rownum - 1) * 7 as endDate,
       to_number(to_char(sysdate, 'iw')) - rownum + 1 as weekIndex,level,rownum
  from dual
connect by level<= 12;


create table plan1 (
id int PRIMARY key,
name varchar(255)
);
create table plandetail(
id int PRIMARY key,
name varchar(255),
state int,
planId int
);

insert into plan1 values(1,'计划一');
insert into plan1 values(2,'计划二');
insert into plan1 values(3,'计划三');

insert into plandetail values(1,'明细一',0,1);
insert into plandetail values(2,'明细2',1,1);
insert into plandetail values(3,'明细3',1,1);

insert into plandetail values(4,'明细一',0,2);
insert into plandetail values(5,'明细2',0,2);
insert into plandetail values(6,'明细3',1,2);

insert into plandetail values(7,'明细一',1,3);
insert into plandetail values(8,'明细2',1,3);
insert into plandetail values(9,'明细3',1,3);

select t1.name ,LISTAGG(t2.name,',')  WITHIN GROUP (order by t2.planid asc) from plan1 t1
 LEFT JOIN plandetail t2 on t1.id = t2.planid
 CONNECT BY nocycle prior t1.id = t2.planid  GROUP BY t1.name ;

select *
from plan1 t1
LEFT JOIN plandetail t2 on t1.id = t2.planid
CONNECT BY nocycle prior t1.id = t2.planid;

drop table plan1;
drop table plandetail;


CREATE TABLE tbl_test
(
 ID int,
 NAME VARCHAR2(100),
 PID int DEFAULT 0
);

INSERT INTO tbl_test(ID,NAME,PID) VALUES(1,'10','0');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(2,'11','1');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(3,'20','0');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(4,'12','1');
INSERT INTO tbl_test(ID,NAME,PID) VALUES(5,'121','2');
select id from tbl_test start with id=5 connect by prior pid = id and prior id= pid;

select id from tbl_test connect by prior pid = id and prior id= pid;

select id,pid from tbl_test connect by prior pid = id and prior id= pid;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select id,pid from tbl_test connect by prior pid = id and prior id= pid;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select pid,id from tbl_test connect by prior pid = id and prior id= pid;

drop table tbl_test;


create table t1(c1 int, c2 varchar2(10)) ;
create table t2(c1 int, c2 varchar2(10)) ;
insert into t1 values(1, 'abc');
insert into t1 values(2, 'cde');
insert into t1 values(4, 'egf');
insert into t1 values(5, 'xyz');
insert into t1 values(6, 'aaa');
insert into t1 values(7, 'bbb');
insert into t1 values(8, 'ccc');
insert into t1 values(9, 'ddd');
insert into t1 values(10, 'eee');
insert into t1 values(11, 'fff');
insert into t1 values(23, null);
insert into t1 values(null, null);
insert into t1 values(null, 'xinei');
insert into t1 values(24, '');

insert into t2 values(1, 'fgh');
insert into t2 values(3, 'ijk');
insert into t2 values(3, 'ijk');
insert into t2 values(4, 'lmn');
insert into t2 values(5, 'opq');
insert into t2 values(7, 'rst');
insert into t2 values(9, 'uvw');
insert into t2 values(11, 'xyz');
insert into t2 values(null, 'xinei');
insert into t2 values(null, null);
insert into t2 values(23, '');
insert into t2 values(23, null);
insert into t2 values(24, '');
insert into t2 values(25, '');

--error ER_NON_BOOLEAN_EXPR_FOR_CHECK_CONSTRAINT
select t1.c1,t2.c1+1 from t1,t2 where t1.c1=t2.c1(+) and t2.c2 is not null start with t1.c1(+) connect by prior t1.c1 = t2.c1+1 order by t1.c1;

--error ER_NON_BOOLEAN_EXPR_FOR_CHECK_CONSTRAINT
select t1.c1,t2.c1+1 from t1,t2 where t1.c1=t2.c1(+) and t2.c2 is not null start with t1.c1 connect by prior t1.c1(+) = t2.c1+1 order by t1.c1;

select t1.c1,t2.c1+1 from t1,t2 where t1.c1=t2.c1(+) and t2.c2 is not null start with t1.c1(+)=5 connect by prior t1.c1 = t2.c1+1 order by t1.c1;

--error ER_OUTER_JOIN_INVALID
select t1.c1,t2.c1+1 from t1,t2 where t1.c1=t2.c1(+) and t2.c2 is not null connect by prior t1.c1(+) = t2.c1(+)+1 order by t1.c1;

DROP TABLE t1;
DROP TABLE t2;
drop table if exists student;

CREATE TABLE student (
           id       raw,
           name  VARCHAR(10),
           grade raw
);
INSERT INTO student VALUES('1', 'John', NULL);
INSERT INTO student VALUES('2', 'Paul', '1');
INSERT INTO student VALUES('3', 'Nancy', '1');
INSERT INTO student VALUES('4', 'Sarah', '3');
select level from student connect by prior id = grade;
drop table student;

select level,rownum from dual connect by level < 4;

select sys_connect_by_path(rownum, '->') from dual connect by level < 4;

--error ER_CONNECT_BY_LOOP
select 1 from dual connect by prior sysdate=sysdate ;

# const item
select sys_connect_by_path('abc', '->') from dual connect by level < 4;

CREATE TABLE student (
    id       INT,
    name  VARCHAR(10),
    grade INT
);

INSERT INTO student VALUES(1, 'John', -1);
INSERT INTO student VALUES(2, 'Paul', 1);
INSERT INTO student VALUES(3, 'Nancy', 1);
INSERT INTO student VALUES(4, 'Sarah', 2);



select id,name,grade ,level , rownum , sys_connect_by_path(rownum,'->')
 from student connect by nocycle prior id = grade and rownum < 4;

select rownum *id +1 ,id, name from student connect by nocycle prior id = grade;

select rownum *id +1 ,id, name from student start with rownum < 3 connect by nocycle prior id = grade;

drop table student;

set timestamp =1;
SELECT sysdate - (to_number(to_char(sysdate - 1, 'd')) - 1) - (rownum - 1) * 7 AS startDate , sysdate + (7 - to_number(to_char(sysdate - 1, 'd'))) - (rownum - 1) * 7 AS endDate , level FROM dual CONNECT BY level <= 5;

select level from dual where level=2 connect by level<=10;
select level from dual where level=2 or level=1 connect by level<=10;
select level from dual where (level=2 or level=1) or (level=8) connect by level<=10;

select level,rownum from dual where rownum < 3 and level=2 connect by level<=10;


set sql_mode=default;

CREATE TABLE student (
    id       INT,
    name  VARCHAR(10),
    grade INT
);

INSERT INTO student VALUES(1, 'John', 0);
INSERT INTO student VALUES(2, 'Paul', 1);
INSERT INTO student VALUES(3, 'Nancy', 1);
INSERT INTO student VALUES(4, 'Sarah', 3);


delimiter //;

create function f1(id int)
returns int
NOT DETERMINISTIC
return id+id;
//

delimiter ;//

select CONNECT_BY_ROOT f1(id), level, id,name,grade from student connect by prior id=grade;

select CONNECT_BY_ROOT f1(id),level, id,name,grade from student connect by nocycle prior id = (grade+1);

drop function f1;
drop table student;
 
create table  emp  
   (	 empno  int, 
	 ename  varchar2(10), 
	 job  varchar2(9), 
	 mgr  number(4,0), 
	 hiredate  date, 
	 sal  number(7,2), 
	 comm  number(7,2), 
	 deptno  number(2,0)
   );
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7369,'smith','clerk',7902,'2017-12-08',800,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7499,'allen','salesman',7698,'2020-02-08',1600,300,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7521,'ward','salesman',7698,'2022-02-08',1250,500,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7566,'jones','manager',7839,'2002-10-01',2975,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7654,'martin','salesman',7698,'2001-02-09',1250,1400,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7698,'blake','manager',7839,'2023-03-08',2850,null,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7782,'clark','manager',7839,'2021-01-18',2450,null,10);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7788,'SCOTT','analyst',7566,'2019-06-07',3000,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7839,'KING','president',null,'2019-07-07',5000,null,10);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7844,'turner','salesman',7698,'2021-04-17',1500,0,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7876,'adams','clerk',7788,'2022-01-01',1100,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7900,'james','clerk',7698,'2018-01-08',950,null,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7902,'ford','analyst',7566,'2017-02-08',3000,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7934,'miller','clerk',7782,'2016-02-08',1300,null,10);



create table t1(
    id number,
    fname varchar(100),
    gfname varchar(100),
    fid varchar(100),
    gfid varchar(100),
    mname varchar(100),
    gmname varchar(100),
    mid varchar(100),
    gmid varchar(100)
);

insert into t1 values (1,'0011','0000','001100','000000','a11','b11','a1100','b1100');
insert into t1 values (2,'0012','0011','001101','000001','a12','a11','a1200','a1100');
insert into t1 values (3,'0013','0011','001102','000002','a13','a11','a1300','a1100');
insert into t1 values (4,'0014','0011','001103','000003','a14','a11','a1400','a1100');

--replace_column 1 #
select CONNECT_BY_ROOT sysdate, CONNECT_BY_ISLEAF,deptno,empno,ename,mgr from emp,t1 connect by prior empno=mgr start with empno=7698;

drop table t1;
drop table emp;

select 1 from (select 1 from dual) connect by level < 3;

--error ER_SUBQUERY_NO_1_ROW
select (select 1 from dual connect by level < 3) from dual;

set sql_mode=default;
--error ER_CONNECT_BY_LOOP
select 1 from dual CONNECT BY  prior sysdate= sysdate;

CREATE TABLE student (
    id       INT primary key,
    name  VARCHAR(10),
    grade INT
);

INSERT INTO student VALUES(1, 'John', 0);
INSERT INTO student VALUES(2, 'Paul', 1);
INSERT INTO student VALUES(3, 'Nancy', 1);
INSERT INTO student VALUES(4, 'Sarah', 3);

select * from student where id is not null connect by prior id = grade;


select avg(id), first_value(grade) over() from student connect by level < 3 group by id,grade;

drop table student;

# bugfix8864
set sql_mode=oracle;
CREATE TABLE t1 (s1 INT, s2 varchar(100),s3 timestamp(3), student_id int, KEY s_id (student_id),PRIMARY KEY (s1));
INSERT INTO t1 VALUES (1,'aa','2021-01-19 03:14:07.123',1);
INSERT INTO t1 VALUES (2,null,'2022-01-19 03:14:07.123',2);

delimiter //;
CREATE or replace FUNCTION f1(a INT) RETURN INT
AS BEGIN
  RETURN a;
END //

delimiter ;//

SELECT f1(a=>( select s1+s1 connect by level<1)) as col_f1 from t1;
SELECT f1((select s1+s1 connect by level<1)) as col_f1 from t1;
set sql_mode=default;
drop function f1;
drop table t1;

CREATE TABLE c1(id int , sid int); INSERT INTO c1 values( 1, 2); INSERT INTO c1 values( 2, 3); INSERT INTO c1 values( 3, 4);
CREATE TABLE c2(id int , sid int); INSERT INTO c2 values( 1, 2); INSERT INTO c2 values( 2, 3); INSERT INTO c2 values( 3, 4);
CREATE TABLE c3(id int , sid int); INSERT INTO c3 values( 1, 2); INSERT INTO c3 values( 2, 3); INSERT INTO c3 values( 3, 4);
CREATE TABLE c4(id int , sid int); INSERT INTO c4 values( 1, 2); INSERT INTO c4 values( 2, 3); INSERT INTO c4 values( 3, 4); 
select * from c1 join c2 on (c2.id = c1.id ) where c2.sid = c1.sid  connect by level < 2;

select * from c1 join c2 on (c2.id <> c1.id)+sysdate or c1.id <> 1 where (c2.id <> c1.id)+sysdate  or c1.id <> 1 connect by level < 2;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree 
select * from c1 join c2 on (c2.id <> c1.id)+sysdate or c1.id <> 1 where (c2.id <> c1.id)+sysdate  or c1.id <> 1 connect by level < 2;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree 
select * from c1 join c2 on (c2.id <> c1.id) or c1.id <> 1 where (c2.id <> c1.id)+sysdate  or c1.id <> 1 connect by level < 2;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree 
select * from c1 join c2 on (c2.id <> c1.id)+sysdate or c1.id <> 1 where (c2.id <> c1.id)  or c1.id <> 1 connect by level < 2;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select * from c1 join c2 on (c2.id = c1.id ) where c2.sid = c1.sid connect by level < 2;

SELECT * FROM c2, c1 INNER JOIN c3 ON (c1.id =c3.id ) WHERE c2.id= c3.id AND c1.sid = c2.sid CONNECT BY LEVEL < 2;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree SELECT * FROM c2, c1 INNER JOIN c3 ON (c1.id =c3.id ) WHERE c2.id= c3.id AND c1.sid = c2.sid CONNECT BY LEVEL < 2;

SELECT * FROM c2, c1 INNER JOIN c3 ON (c1.id =c3.id ) WHERE c2.id= c3.id AND c1.sid = c2.sid AND c1.id <> 1 CONNECT BY LEVEL < 2;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
SELECT * FROM c2, c1 INNER JOIN c3 ON (c1.id =c3.id ) WHERE c2.id= c3.id AND c1.sid = c2.sid AND c1.id <> 1 CONNECT BY LEVEL < 2;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * from  c4,c1 inner join c2 ON  c1.id = c2.id   JOIN c3 ON c1.id = c2.id    where c3.sid = c4.sid    CONNECT BY LEVEL < 2 ;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * from c1 inner join c2 ON  c1.id = c2.id   JOIN c3 ON c1.id = c2.id   where c3.sid = c1.sid    CONNECT BY LEVEL < 2 ;


--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * from c4,c1 inner join (c2, c3) on c1.id = c2.id  where  c3.sid = c1.sid connect by level < 2 ;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree 
select * from c4,c1 inner join ((select 1 as a,2 as b) cc ,c3,c2)  on c1.id = c2.id  where  
c3.sid = c1.sid and cc.a <> c1.id and c4.id = cc.b  connect by level < 2;


drop table c1;
drop table c2;
drop table c3;
drop table c4;

create table t1(ida int, age int, name varchar(10));
insert into t1 values(1, 2, '');
insert into t1 values(NULL, 2, 'a');
insert into t1 values(3, 2, 'b');

create table t3(ida int, age int, name varchar(10));
insert into t3 values(2, 3, 'a');
insert into t3 values(1, 3, 'aa');
insert into t3 values(5, NULL, '');

select * from t1 where t1.name IN (select name from t3) connect by level<3;
select * from t1 where t1.name NOT IN (select name from t3) connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select * from t1 where t1.name IN (select name from t3) connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select * from t1 where t1.name NOT IN (select name from t3) connect by level<3;

select * from t1 aa where EXISTS (select name from t3 b WHERE aa.name=b.name) connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select * from t1 aa where EXISTS (select name from t3 b WHERE aa.name=b.name) connect by level<3;

select * from t1 aa where NOT EXISTS (select name from t3 b WHERE aa.name=b.name) connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree select * from t1 aa where EXISTS (select name from t3 b WHERE aa.name=b.name) connect by level<3;

drop table t1;
drop table t3;

create table t1(ida int, age int, name varchar(10));
insert into t1 values(1, 2, 'K');
insert into t1 values(5, 2, 'a');
insert into t1 values(3, 2, 'b');
create table t2(ida int, age int, name varchar(10));
insert into t2 values(1, 2, 'K');
insert into t2 values(2, 2, 'a');
insert into t2 values(3, 1, 'b');
create table t3(ida int, age int, name varchar(10));
insert into t3 values(2, 3, 'a');
insert into t3 values(1, 3, 'aa');
insert into t3 values(5, 5, 'K');
SELECT * FROM t1 WHERE EXISTS (SELECT 1 FROM t2 WHERE t2.ida=t1.ida CONNECT BY LEVEL<=3);
SELECT * FROM t1 WHERE EXISTS (SELECT 1 FROM t2 WHERE 1=t1.ida CONNECT BY LEVEL<=3);
SELECT * FROM t1 WHERE NOT EXISTS (SELECT 1 FROM t2 WHERE t2.ida=t1.ida CONNECT BY LEVEL<=3);
SELECT * FROM t1 WHERE EXISTS (SELECT ida FROM t3 WHERE t3.ida = t1.ida CONNECT BY LEVEL <=3) CONNECT BY LEVEL<3;
SELECT * FROM t1 WHERE NOT EXISTS (SELECT ida FROM t3 WHERE t3.ida = t1.ida CONNECT BY LEVEL <=3) CONNECT BY LEVEL<3;
SELECT * FROM t1 WHERE ida in (SELECT ida FROM t3 WHERE t3.ida = t1.ida CONNECT BY LEVEL <=3) CONNECT BY LEVEL<3;
SELECT * FROM t1 WHERE ida NOT in (SELECT ida FROM t3 WHERE t3.ida = t1.ida CONNECT BY LEVEL <=3) CONNECT BY LEVEL<3;
SELECT ida,level FROM t1 WHERE ida IN (SELECT ida FROM t2 WHERE t2.ida=t1.ida) CONNECT BY LEVEL<3;
SELECT count(*) FROM t1 WHERE ida IN (SELECT ida FROM t2 WHERE t2.ida=t1.ida) CONNECT BY LEVEL<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree 
SELECT * FROM t1 WHERE EXISTS (SELECT 1 FROM t2 WHERE t2.ida=t1.ida CONNECT BY LEVEL<=3);

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree 
SELECT * FROM t1 WHERE NOT EXISTS (SELECT 1 FROM t2 WHERE t2.ida=t1.ida CONNECT BY LEVEL<=3);

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree 
SELECT name FROM t1 WHERE EXISTS (SELECT ida FROM t3 WHERE t3.ida = t1.ida CONNECT BY LEVEL <=3) CONNECT BY LEVEL<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree 
SELECT count(*) FROM t1 WHERE ida IN (SELECT ida FROM t2 WHERE t2.ida=t1.ida) CONNECT BY LEVEL<3;

CREATE TABLE student (
    id       INT,
    name  VARCHAR(10),
    grade INT
);

INSERT INTO student VALUES(1, 'John', NULL);
INSERT INTO student VALUES(2, 'Paul', 1);
INSERT INTO student VALUES(3, 'Nancy', 1);
INSERT INTO student VALUES(4, 'Sarah', 3);

SELECT * FROM t1 WHERE EXISTS (SELECT id FROM student t  CONNECT BY t.id = t1.ida  ) CONNECT BY LEVEL< 2;

SELECT * FROM t1 WHERE EXISTS (SELECT id FROM student t  CONNECT BY nocycle  prior t.id = t1.ida  ) CONNECT BY LEVEL< 3;

select * from t1,t3  WHERE t1.IDA in (t3.ida, 1 )  connect by level<3;

select * from t1,t3  WHERE 1 in (t3.ida, t1.ida , 3)  connect by level<3;

select * from t1,t3  WHERE t1.IDA NOT in (t3.ida, t3.age ,1 )  connect by level<3;

select * from t1,t3  WHERE t1.IDA NOT in (t3.ida ,1 , 2)  connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree 
select * from t1,t3  WHERE t1.IDA in (t3.ida, 1 )  connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree 
select * from t1,t3  WHERE 1 in (t3.ida, t1.ida , 3)  connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree 
select * from t1,t3  WHERE t1.IDA NOT in (t3.ida, t3.age ,1 )  connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree 
select * from t1,t3  WHERE t1.IDA NOT in (t3.ida ,1 , 2)  connect by level<3;

select * from t1,t3  WHERE t1.IDA in (t3.ida, t3.age ,(select ida from t2 limit 1))  connect by level <3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree 
select * from t1,t3  WHERE t1.IDA in (t3.ida, t3.age ,(select ida from t2 limit 1))  connect by level <3;

select * from t1,t3  WHERE t1.age in (t3.ida, t1.ida )  connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree 
select * from t1,t3  WHERE t1.age in (t3.ida, t1.ida )  connect by level<3;

select * from t1,t3  WHERE 1 in (t3.ida, t1.ida , 3)  connect by level<3;
--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree 
select * from t1,t3  WHERE 1 in (t3.ida, t1.ida , 3)  connect by level<3;

select * from t1,t3  WHERE t1.IDA < any (t3.ida ,1 )  connect by level<3;

select * from t1,t3  WHERE t1.IDA < any (t3.ida ,1 , 2)  connect by level<3;
 
select * from t1,t3  WHERE t1.IDA < any (t3.ida, t3.age ,1 )  connect by level<3;


--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * from t1,t3  WHERE t1.IDA < any (t3.ida ,1 )  connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * from t1,t3  WHERE t1.IDA < any (t3.ida ,1 , 2)  connect by level<3;
 
--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * from t1,t3  WHERE t1.IDA < any (t3.ida, t3.age ,1 )  connect by level<3;



select * from t1,t3  WHERE t1.IDA > any (t3.ida ,1 )  connect by level<3;

select * from t1,t3  WHERE t1.IDA > any (t3.ida ,1,2 )  connect by level<3;

select * from t1,t3  WHERE t1.IDA > any (t3.ida ,1, t3.age )  connect by level<3;

select * from t1,t3  WHERE 10 > any (t3.ida ,1, t1.ida )  connect by level<3;

select * from t1,t3  WHERE 1 < any (t3.ida ,1, t1.ida )  connect by level<3;

select * from t1,t3  WHERE t1.IDA > any (t3.ida,t3.age )  connect by level<3;

select * from t1,t3  WHERE t1.IDA >= any (t1.age ,t3.ida,t3.age )  connect by level<3;

select * from t1,t3  WHERE t1.IDA >= any (t1.age ,t1.ida)  connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * from t1,t3  WHERE t1.IDA >= any (t1.age ,t1.ida)  connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * from t1,t3  WHERE t1.IDA >= any (t1.age ,t3.ida,t3.age )  connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * from t1,t3  WHERE t1.IDA > any (t3.ida ,1 )  connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * from t1,t3  WHERE t1.IDA > any (t3.ida ,1,2 )  connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * from t1,t3  WHERE t1.IDA > any (t3.ida ,1, t3.age )  connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * from t1,t3  WHERE 1 < any (t3.ida ,1, t1.ida )  connect by level<3;

select * from t1,t3  WHERE t1.IDA = any (t3.ida, t3.age ,1 )  connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * from t1,t3  WHERE t1.IDA = any (t3.ida, t3.age ,1 )  connect by level<3;


select * from t1,t3  WHERE t1.IDA between t3.ida  and 10   connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * from t1,t3  WHERE t1.IDA between t3.ida  and 10   connect by level<3;

select * from t1,t3  WHERE t1.IDA not between t3.ida  and 10   connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * from t1,t3  WHERE t1.IDA not between t3.ida  and 10   connect by level<3;

select * from t1,t3  WHERE 10 between t1.ida  and t3.ida   connect by level<3;

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * from t1,t3  WHERE 10 between t1.ida  and t3.ida   connect by level<3;

drop table student;
drop table t1;
drop table t2;
drop table t3;

create table  emp  
   (	 empno  int, 
	 ename  varchar2(10), 
	 job  varchar2(9), 
	 mgr  number(4,0), 
	 hiredate varchar2(50),
	 sal  number(7,2), 
	 comm  number(7,2), 
	 deptno  number(2,0)
   )  partition by hash(empno) partitions 15 ;
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7369,'smith','clerk',7902,'2017-12-08',800,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7499,'allen','salesman',7698,'2020-02-08',1600,300,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7521,'ward','salesman',7698,'2022-02-08',1250,500,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7566,'jones','manager',7839,'2002-10-01',2975,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7654,'martin','salesman',7698,'2001-02-09',1250,1400,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7698,'blake','manager',7839,'2023-03-08',2850,null,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7782,'clark','manager',7839,'2021-01-18',2450,null,10);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7788,'SCOTT','analyst',7566,'2019-06-07',3000,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7839,'KING','president',null,'2019-07-07',5000,null,10);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7844,'turner','salesman',7698,'2021-04-17',1500,0,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7876,'adams','clerk',7788,'2022-01-01',1100,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7900,'james','clerk',7698,'2018-01-08',950,null,30);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7902,'ford','analyst',7566,'2017-02-08',3000,null,20);
insert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) values (7934,'miller','clerk',7782,'2016-02-08',1300,null,10);


select empno from emp where mgr in (select mgr from emp connect by prior empno=mgr start with empno=7839);

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select empno from emp where mgr in (select mgr from emp connect by prior empno=mgr start with empno=7839);

select empno,mgr from emp b where mgr in (select mgr from emp connect by nocycle prior empno=b.mgr start with empno=7839);

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select empno,mgr from emp b where mgr in (select mgr from emp connect by nocycle prior empno=b.mgr start with empno=7839);

select empno,mgr from emp b where mgr in (select mgr from emp connect by nocycle prior  b.mgr = empno start with empno=7839);

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select empno,mgr from emp b where mgr in (select mgr from emp connect by nocycle prior  b.mgr = empno start with empno=7839);

drop table emp;


CREATE TABLE sales ( department VARCHAR2(50), product VARCHAR2(50), amount NUMBER );
INSERT INTO sales VALUES ('A', 'Product1', 100);
INSERT INTO sales VALUES ('A', 'Product2', 200);
INSERT INTO sales VALUES ('A', 'Product3', 300);
INSERT INTO sales VALUES ('B', 'Product1', 150);
INSERT INTO sales VALUES ('B', 'Product2', 250);
INSERT INTO sales VALUES ('B', 'Product3', 350);

select * FROM  sales  connect by level <3 and rownum =3;
--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree
select * FROM  sales  connect by level <3 and rownum =3;

drop table sales;

SELECT row_number() over() rn, level connect by level<10;
SELECT row_number() over(order by level) rn, level connect by level<10;
SELECT row_number() over(order by level) rn, level connect by level<10 group by level;
SELECT row_number() over() rn, level connect by level<10 group by level;


SELECT sum(level) over() rn, level connect by level<10;
SELECT sum(level) over(order by level) rn, level connect by level<10;
SELECT sum(level) over(order by level) rn, level connect by level<10 group by level;
SELECT sum(level) over() rn, level connect by level<10 group by level;


SELECT sum(level) over() rn, row_number() over(), level connect by level<10;
SELECT sum(level) over() rn, row_number() over(order by level), level connect by level<10;
SELECT sum(level) over(order by level) rn, row_number() over(), level connect by level<10;
SELECT sum(level) over(order by level) rn, row_number() over(order by level), level connect by level<10;


SELECT sum(level) over(order by level) rn,row_number() over(), level connect by level<10 group by level;
SELECT sum(level) over(order by level) rn,row_number() over(order by level), level connect by level<10 group by level;
SELECT sum(level) over() rn, row_number() over(),  level connect by level<10 group by level;
SELECT sum(level) over() rn, row_number() over(order by level),  level connect by level<10 group by level;

select rownum from dual connect by level <= 10 group by rownum;

select level from dual connect by level <= 10 group by level;

select level from dual connect by level <= 10 group by rownum;

select rownum from dual connect by level <= 10 group by level;

create table t1(c1 int primary key, c2 int, key(c2));

create table t2(c1 int, c2 int, key(c1));

select * from t1 
connect by prior t1.c1 = t1.c2
  start with t1.c1 in (select c2 from t2 where c1=0);

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/
explain format=tree 
select * from t1 
connect by prior t1.c1 = t1.c2
  start with t1.c1 in (select c2 from t2 where c1=0);


--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/ /time=\d+\.\d+\.\.\d+\.\d+/time=N.NNN..N.NNN/
explain analyze
select * from t1
connect by prior t1.c1 = t1.c2
  start with t1.c1 in (select c2 from t2 where c1=0);

--replace_regex /cost=\d+.\d+(\.\.\d+\.\d+)?/cost=***/  /rows=\d+(\.\.\d+\.\d+)?/rows=***/ /time=\d+\.\d+\.\.\d+\.\d+/time=N.NNN..N.NNN/
explain analyze
select 1 from  dual connect by level < 10;

SET profiling = 1;

select * from t1
connect by prior t1.c1 = t1.c2
  start with t1.c1 in (select c2 from t2 where c1=0);

--replace_column 2 ###
SHOW PROFILES;
--replace_column 2 ###
SHOW PROFILE;

--replace_column 2 ###
SHOW PROFILE FOR QUERY 2;
SET profiling = 0;
drop table t1;
drop table t2;

create table t1 (c1 int primary key, c2 varchar(32),date1 datetime);
insert into t1 values (1,'aaa','2021-03-25 16:44:00.123456'),(2,'bbb','2022-03-25 16:44:00.123456'),(3,'ccc','2023-03-25 16:44:00.123456');

select c2,sum(c1) from t1 connect by level<2 group by c2 with rollup;
drop table t1;


CREATE TABLE t1(id int, type char(1));
INSERT INTO t1 VALUES
  (1,"A"),(2,"C"),(3,"A"),(4,"A"),(5,"B"),
  (6,"B"),(7,"A"),(8,"C"),(9,"A"),(10,"C");
CREATE VIEW v1 AS SELECT * FROM t1;

--error ER_FIELD_IN_GROUPING_NOT_GROUP_BY
SELECT type FROM v1 connect by level<1  GROUP BY type WITH ROLLUP;
drop view v1;

drop table t1;
CREATE TABLE t1 (
  pk INTEGER NOT NULL AUTO_INCREMENT,
  col_int INTEGER DEFAULT NULL,
  PRIMARY KEY (pk)
);

INSERT INTO t1 VALUES (1,1);

--error  ER_INVALID_GROUP_FUNC_USE
SELECT ((table1.col_int) * (table1.col_int)) AS field2 FROM (t1 AS table1)   WHERE (table1.col_int != 1 OR table1.pk) connect by level<1
   GROUP BY field2 WITH ROLLUP   HAVING (field2 <> 239 ) ORDER BY GROUPING(field2);
drop table t1;
CREATE TABLE t1 (a INTEGER);
CREATE TABLE t2 (c INTEGER);

INSERT INTO t1 VALUES (7),(8);
INSERT INTO t2 VALUES (-3);

--error ER_NOT_SUPPORTED_YET
SELECT c, a, SUM(c) OVER () FROM t1,t2 connect by level<1 GROUP BY c,a WITH ROLLUP;
drop table t1;
drop table t2;

CREATE TABLE t1 (
  f1 INTEGER
);
INSERT INTO t1 VALUES (1), (2), (3);

CREATE TABLE t2 (
  pk INTEGER,
  blobfield LONGTEXT
);
INSERT INTO t2 VALUES (4, '');

--error ER_NOT_SUPPORTED_YET
SELECT * FROM t1, t2, LATERAL (   SELECT pk, blobfield   GROUP BY pk, blobfield WITH ROLLUP ) AS d1 connect by level<1 ORDER BY t1.f1, t2.pk;

drop table t1;
drop table t2;


CREATE TABLE t (a varchar(10), FULLTEXT (a));
INSERT INTO t VALUES ('abc'), ('xyz');
--error ER_NOT_SUPPORTED_YET
SELECT 1 FROM t WHERE MATCH (a) AGAINST ('abc') connect by level<1 GROUP BY a WITH ROLLUP;
drop table t;


CREATE TABLE t1 (pk INTEGER, PRIMARY KEY (pk));
CREATE TABLE t2 (pk INTEGER, PRIMARY KEY (pk));

INSERT INTO t2 VALUES (1),(2);
--error ER_INVALID_GROUP_FUNC_USE
SELECT GROUPING(alias2.pk) AS field2 FROM t2 AS alias1 LEFT JOIN t1 AS alias2  
 ON 0 connect by level<1 GROUP BY alias2.pk WITH ROLLUP ORDER BY GROUPING(alias2.pk);

drop table t1;
drop table t2; 
